

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Types &mdash; Hail</title>
  

  
  
    <link rel="shortcut icon" href="hail_logo_sq.png"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="navbar.css" type="text/css" />
  
    <link rel="stylesheet" href="_static/rtd_modifications.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="Hail" href="index.html"/>
        <link rel="up" title="Expression Language" href="exprlang.html"/>
        <link rel="next" title="Functions" href="functions.html"/>
        <link rel="prev" title="Operators" href="operators.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>
  
  

</head>

<body class="wy-body-for-nav" role="document">

  <nav class="navbar navbar-default navbar-static-top" id="hail-navbar">
<div class="container-fluid" id="hail-container-fluid">
    <div class="navbar-header" id="hail-navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#hail-navbar-collapse" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
   
      <a class="navbar-left" id="hail-navbar-brand" href="../index.html"><img alt="Hail" id="logo" src="hail-logo-cropped.png"></a>

    </div>

    <div class="collapse navbar-collapse" id="hail-navbar-collapse">
      <ul class="nav navbar-nav navbar-right">
          <li id="home" class="nav-item"><a href="../index.html">HOME</a></li>
          <li id="docs" class="nav-item"><a href="index.html">DOCS</a></li>
          <li id="forum" class="nav-item"><a href="http://discuss.hail.is">FORUM</a></li>
          <li id="chat" class="nav-item dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">CHAT<span class="caret"></span></a>
          <ul class="dropdown-menu dropdown-menu-left">
            <li><a class="dropdown-item" href="https://gitter.im/hail-is/hail">General</a></li>
            <li><a class="dropdown-item" href="https://gitter.im/hail-is/hail-dev">Developers</a></li>
          </ul>
        </li>
       <li id="code" class="nav-item"><a href="https://github.com/hail-is/hail">CODE</a></li>
      </ul>
    </div>
  </div>
</nav>

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Hail
          

          
          </a>

          
            
            
              <div class="version">
                devel
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="exprlang.html">Expression Language</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="language_constructs.html">Language Constructs</a></li>
<li class="toctree-l2"><a class="reference internal" href="operators.html">Operators</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#aggregable">Aggregable</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#aggregable-array-double">Aggregable[Array[Double]]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aggregable-array-float">Aggregable[Array[Float]]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aggregable-array-int">Aggregable[Array[Int]]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aggregable-array-long">Aggregable[Array[Long]]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aggregable-double">Aggregable[Double]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aggregable-float">Aggregable[Float]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aggregable-genotype">Aggregable[Genotype]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aggregable-int">Aggregable[Int]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aggregable-long">Aggregable[Long]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aggregable-t">Aggregable[T]</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#altallele">AltAllele</a></li>
<li class="toctree-l3"><a class="reference internal" href="#array">Array</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#array-array-t">Array[Array[T]]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#array-boolean">Array[Boolean]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#array-double">Array[Double]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#array-float">Array[Float]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#array-int">Array[Int]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#array-long">Array[Long]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#array-string">Array[String]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#array-t">Array[T]</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#boolean">Boolean</a></li>
<li class="toctree-l3"><a class="reference internal" href="#call">Call</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dict">Dict</a></li>
<li class="toctree-l3"><a class="reference internal" href="#double">Double</a></li>
<li class="toctree-l3"><a class="reference internal" href="#float">Float</a></li>
<li class="toctree-l3"><a class="reference internal" href="#genotype">Genotype</a></li>
<li class="toctree-l3"><a class="reference internal" href="#int">Int</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interval">Interval</a></li>
<li class="toctree-l3"><a class="reference internal" href="#locus">Locus</a></li>
<li class="toctree-l3"><a class="reference internal" href="#long">Long</a></li>
<li class="toctree-l3"><a class="reference internal" href="#set">Set</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#set-double">Set[Double]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-float">Set[Float]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-int">Set[Int]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-long">Set[Long]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-set-t">Set[Set[T]]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-string">Set[String]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-t">Set[T]</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#string">String</a></li>
<li class="toctree-l3"><a class="reference internal" href="#struct">Struct</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variant">Variant</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="functions.html">Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="annotationdb.html">Annotation Database</a></li>
<li class="toctree-l1"><a class="reference internal" href="other_resources.html">Other Resources</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Hail</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="exprlang.html">Expression Language</a> &raquo;</li>
        
      <li>Types</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/types.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

/* nice headers on first paragraph of info/warning boxes */
.admonition .first {
    margin: -12px;
    padding: 6px 12px;
    margin-bottom: 12px;
    color: #fff;
    line-height: 1;
    display: block;
}
.admonition.warning .first {
    background: #f0b37e;
}
.admonition.note .first {
    background: #6ab0de;
}
.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}
</style>
<div class="section" id="types">
<h1>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h1>
<div class="section" id="aggregable">
<span id="id1"></span><h2>Aggregable<a class="headerlink" href="#aggregable" title="Permalink to this headline">¶</a></h2>
<p>An <code class="docutils literal"><span class="pre">Aggregable</span></code> is a Hail data type representing a distributed row or column of a matrix. Hail exposes a number of methods to compute on aggregables depending on the data type.</p>
<div class="section" id="aggregable-array-double">
<span id="id2"></span><h3>Aggregable[Array[Double]]<a class="headerlink" href="#aggregable-array-double" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><strong>sum()</strong>: <em>Array[Double]</em> &#8211; Compute the sum by index. All elements in the aggregable must have the same length.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="aggregable-array-float">
<span id="id3"></span><h3>Aggregable[Array[Float]]<a class="headerlink" href="#aggregable-array-float" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><strong>sum()</strong>: <em>Array[Float]</em> &#8211; Compute the sum by index. All elements in the aggregable must have the same length.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="aggregable-array-int">
<span id="id4"></span><h3>Aggregable[Array[Int]]<a class="headerlink" href="#aggregable-array-int" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><p class="first"><strong>sum()</strong>: <em>Array[Int]</em></p>
<blockquote>
<div><p>Compute the sum by index. All elements in the aggregable must have the same length.</p>
<p><strong>Examples</strong></p>
<p>Count the total number of occurrences of each allele across samples, per variant:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="s1">&#39;va.AC = gs.map(g =&gt; g.oneHotAlleles(v)).sum()&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="aggregable-array-long">
<span id="id5"></span><h3>Aggregable[Array[Long]]<a class="headerlink" href="#aggregable-array-long" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><strong>sum()</strong>: <em>Array[Long]</em> &#8211; Compute the sum by index. All elements in the aggregable must have the same length.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="aggregable-double">
<span id="id6"></span><h3>Aggregable[Double]<a class="headerlink" href="#aggregable-double" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><p class="first"><strong>hist(start: Double, end: Double, bins: Int)</strong>: <em>Struct</em></p>
<blockquote>
<div><div class="annotation docutils container">
<ul class="simple">
<li><strong>binEdges</strong> (<em>Array[Double]</em>) &#8211; Array of bin cutoffs</li>
<li><strong>binFrequencies</strong> (<em>Array[Long]</em>) &#8211; Number of elements that fall in each bin.</li>
<li><strong>nLess</strong> (<em>Long</em>) &#8211; Number of elements less than the minimum bin</li>
<li><strong>nGreater</strong> (<em>Long</em>) &#8211; Number of elements greater than the maximum bin</li>
</ul>
</div>
<p>Compute frequency distributions of numeric parameters.</p>
<p><strong>Examples</strong></p>
<p>Compute GQ-distributions per variant:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="s1">&#39;va.gqHist = gs.map(g =&gt; g.gq).hist(0, 100, 20)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute global GQ-distribution:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gq_hist</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_genotypes</span><span class="p">(</span><span class="s1">&#39;gs.map(g =&gt; g.gq).hist(0, 100, 100)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<ul class="simple">
<li>The start, end, and bins params are no-scope parameters, which means that while computations like 100 / 4 are acceptable, variable references like <code class="docutils literal"><span class="pre">global.nBins</span></code> are not.</li>
<li>Bin size is calculated from (<code class="docutils literal"><span class="pre">end</span></code> - <code class="docutils literal"><span class="pre">start</span></code>) / <code class="docutils literal"><span class="pre">bins</span></code></li>
<li>(<code class="docutils literal"><span class="pre">bins</span></code> + 1) breakpoints are generated from the range (start to end by binsize)</li>
<li>Each bin is left-inclusive, right-exclusive except the last bin, which includes the maximum value. This means that if there are N total bins, there will be N + 1 elements in <code class="docutils literal"><span class="pre">binEdges</span></code>. For the invocation <code class="docutils literal"><span class="pre">hist(0,</span> <span class="pre">3,</span> <span class="pre">3)</span></code>, <code class="docutils literal"><span class="pre">binEdges</span></code> would be <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> where the bins are <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">1),</span> <span class="pre">[1,</span> <span class="pre">2),</span> <span class="pre">[2,</span> <span class="pre">3]</span></code>.</li>
</ul>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>start</strong> (<em>Double</em>) &#8211; Starting point of first bin</li>
<li><strong>end</strong> (<em>Double</em>) &#8211; End point of last bin</li>
<li><strong>bins</strong> (<em>Int</em>) &#8211; Number of bins to create.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>max()</strong>: <em>Double</em> &#8211; Compute the maximum of all non-missing elements. The empty max is missing.</p>
</li>
<li><p class="first"><strong>min()</strong>: <em>Double</em> &#8211; Compute the minimum of all non-missing elements. The empty min is missing.</p>
</li>
<li><p class="first"><strong>stats()</strong>: <em>Struct</em></p>
<blockquote>
<div><div class="annotation docutils container">
<ul class="simple">
<li><strong>mean</strong> (<em>Double</em>) &#8211; Mean value</li>
<li><strong>stdev</strong> (<em>Double</em>) &#8211; Standard deviation</li>
<li><strong>min</strong> (<em>Double</em>) &#8211; Minimum value</li>
<li><strong>max</strong> (<em>Double</em>) &#8211; Maximum value</li>
<li><strong>nNotMissing</strong> (<em>Long</em>) &#8211; Number of non-missing values</li>
<li><strong>sum</strong> (<em>Double</em>) &#8211; Sum of all elements</li>
</ul>
</div>
<p>Compute summary statistics about a numeric aggregable.</p>
<p><strong>Examples</strong></p>
<p>Compute the mean genotype quality score per variant:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="s1">&#39;va.gqMean = gs.map(g =&gt; g.gq).stats().mean&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute summary statistics on the number of singleton calls per sample:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">singleton_stats</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">sample_qc</span><span class="p">()</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">query_samples</span><span class="p">([</span><span class="s1">&#39;samples.map(s =&gt; sa.qc.nSingleton).stats()&#39;</span><span class="p">]))</span>
</pre></div>
</div>
<p>Compute GQ and DP statistics stratified by genotype call:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gq_dp</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span><span class="s1">&#39;va.homrefGQ = gs.filter(g =&gt; g.isHomRef()).map(g =&gt; g.gq).stats()&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;va.hetGQ = gs.filter(g =&gt; g.isHet()).map(g =&gt; g.gq).stats()&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;va.homvarGQ = gs.filter(g =&gt; g.isHomVar()).map(g =&gt; g.gq).stats()&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;va.homrefDP = gs.filter(g =&gt; g.isHomRef()).map(g =&gt; g.dp).stats()&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;va.hetDP = gs.filter(g =&gt; g.isHet()).map(g =&gt; g.dp).stats()&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;va.homvarDP = gs.filter(g =&gt; g.isHomVar()).map(g =&gt; g.dp).stats()&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="n">gq_dp</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>The <code class="docutils literal"><span class="pre">stats()</span></code> aggregator can be used to replicate some of the values computed by <a class="reference internal" href="hail.VariantDataset.html#hail.VariantDataset.variant_qc" title="hail.VariantDataset.variant_qc"><code class="xref py py-meth docutils literal"><span class="pre">variant_qc()</span></code></a> and <a class="reference internal" href="hail.VariantDataset.html#hail.VariantDataset.sample_qc" title="hail.VariantDataset.sample_qc"><code class="xref py py-meth docutils literal"><span class="pre">sample_qc()</span></code></a> such as <code class="docutils literal"><span class="pre">dpMean</span></code> and <code class="docutils literal"><span class="pre">dpStDev</span></code>.</p>
</div></blockquote>
</li>
<li><p class="first"><strong>sum()</strong>: <em>Double</em> &#8211; Compute the sum of all non-missing elements. The empty sum is zero.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="aggregable-float">
<span id="id7"></span><h3>Aggregable[Float]<a class="headerlink" href="#aggregable-float" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><strong>max()</strong>: <em>Float</em> &#8211; Compute the maximum of all non-missing elements. The empty max is missing.</li>
<li><strong>min()</strong>: <em>Float</em> &#8211; Compute the minimum of all non-missing elements. The empty min is missing.</li>
<li><strong>sum()</strong>: <em>Float</em> &#8211; Compute the sum of all non-missing elements. The empty sum is zero.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="aggregable-genotype">
<span id="id8"></span><h3>Aggregable[Genotype]<a class="headerlink" href="#aggregable-genotype" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><p class="first"><strong>callStats(f: Genotype =&gt; Variant)</strong>: <em>Struct</em></p>
<blockquote>
<div><div class="annotation docutils container">
<ul class="simple">
<li><strong>AC</strong> (<em>Array[Int]</em>) &#8211; Allele count. One element per allele <strong>including reference</strong>. There are two elements for a biallelic variant, or 4 for a variant with three alternate alleles.</li>
<li><strong>AF</strong> (<em>Array[Double]</em>) &#8211; Allele frequency. One element per allele including reference. Sums to 1.</li>
<li><strong>AN</strong> (<em>Int</em>) &#8211; Allele number. This is equal to the sum of AC, or 2 * the total number of called genotypes in the aggregable.</li>
<li><strong>GC</strong> (<em>Array[Int]</em>) &#8211; Genotype count. One element per possible genotype, including reference genotypes &#8211; 3 for biallelic, 6 for triallelic, 10 for 3 alt alleles, and so on. The sum of this array is the number of called genotypes in the aggregable.</li>
</ul>
</div>
<p>Compute four commonly-used metrics over a set of genotypes in a variant.</p>
<p><strong>Examples</strong></p>
<p>Compute phenotype-specific call statistics:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pheno_stats</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>  <span class="s1">&#39;va.case_stats = gs.filter(g =&gt; sa.pheno.isCase).callStats(g =&gt; v)&#39;</span><span class="p">,</span>
<span class="gp">... </span>  <span class="s1">&#39;va.control_stats = gs.filter(g =&gt; !sa.pheno.isCase).callStats(g =&gt; v)&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="n">pheno_stats</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">va.eur_stats.AC</span></code> will be the allele count (AC) computed from individuals marked as &#8220;EUR&#8221;.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>Genotype =&gt; Variant</em>) &#8211; Variant lambda expression such as <code class="docutils literal"><span class="pre">g</span> <span class="pre">=&gt;</span> <span class="pre">v</span></code>.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>hardyWeinberg()</strong>: <em>Struct</em></p>
<blockquote>
<div><div class="annotation docutils container">
<ul class="simple">
<li><strong>rExpectedHetFrequency</strong> (<em>Double</em>) &#8211; Expected rHeterozygosity based on Hardy Weinberg Equilibrium</li>
<li><strong>pHWE</strong> (<em>Double</em>) &#8211; p-value</li>
</ul>
</div>
<p>Compute Hardy-Weinberg equilibrium p-value.</p>
<p><strong>Examples</strong></p>
<p>Add a new variant annotation that calculates HWE p-value by phenotype:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">([</span>
<span class="gp">... </span>  <span class="s1">&#39;va.hweCase = gs.filter(g =&gt; sa.pheno.isCase).hardyWeinberg()&#39;</span><span class="p">,</span>
<span class="gp">... </span>  <span class="s1">&#39;va.hweControl = gs.filter(g =&gt; !sa.pheno.isCase).hardyWeinberg()&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>Hail computes the exact p-value with mid-p-value correction, i.e. the probability of a less-likely outcome plus one-half the probability of an equally-likely outcome. See this <a class="reference external" href="../LeveneHaldane.pdf">document</a> for details on the Levene-Haldane distribution and references.</p>
</div></blockquote>
</li>
<li><p class="first"><strong>inbreeding(af: Genotype =&gt; Double)</strong>: <em>Struct</em></p>
<blockquote>
<div><div class="annotation docutils container">
<ul class="simple">
<li><strong>Fstat</strong> (<em>Double</em>) &#8211; Inbreeding coefficient</li>
<li><strong>nTotal</strong> (<em>Long</em>) &#8211; Number of genotypes analyzed</li>
<li><strong>nCalled</strong> (<em>Long</em>) &#8211; number of genotypes with non-missing calls</li>
<li><strong>expectedHoms</strong> (<em>Double</em>) &#8211; Expected number of homozygote calls</li>
<li><strong>observedHoms</strong> (<em>Long</em>) &#8211; Total number of homozygote calls observed</li>
</ul>
</div>
<p>Compute inbreeding metric. This aggregator is equivalent to the <a class="reference external" href="https://www.cog-genomics.org/plink2/basic_stats#ibc">`&#8211;het` method in PLINK</a>.</p>
<p><strong>Examples</strong></p>
<p>Calculate the inbreeding metric per sample:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">variant_qc</span><span class="p">()</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">annotate_samples_expr</span><span class="p">(</span><span class="s1">&#39;sa.inbreeding = gs.inbreeding(g =&gt; va.qc.AF)&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>To obtain the same answer as <a class="reference external" href="https://www.cog-genomics.org/plink2">PLINK</a>, use the following series of commands:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">variant_qc</span><span class="p">()</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">filter_variants_expr</span><span class="p">(</span><span class="s1">&#39;va.qc.AC &gt; 1 &amp;&amp; va.qc.AF &gt;= 1e-8 &amp;&amp; va.qc.nCalled * 2 - va.qc.AC &gt; 1 &amp;&amp; va.qc.AF &lt;= 1 - 1e-8 &amp;&amp; v.isAutosomal()&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">annotate_samples_expr</span><span class="p">(</span><span class="s1">&#39;sa.inbreeding = gs.inbreeding(g =&gt; va.qc.AF)&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>The Inbreeding Coefficient (F) is computed as follows:</p>
<ol class="arabic simple">
<li>For each variant and sample with a non-missing genotype call, <code class="docutils literal"><span class="pre">E</span></code>, the expected number of homozygotes (computed from user-defined expression for minor allele frequency), is computed as <code class="docutils literal"><span class="pre">1.0</span> <span class="pre">-</span> <span class="pre">(2.0*maf*(1.0-maf))</span></code></li>
<li>For each variant and sample with a non-missing genotype call, <code class="docutils literal"><span class="pre">O</span></code>, the observed number of homozygotes, is computed as <code class="docutils literal"><span class="pre">0</span> <span class="pre">=</span> <span class="pre">heterozygote;</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">homozygote</span></code></li>
<li>For each variant and sample with a non-missing genotype call, <code class="docutils literal"><span class="pre">N</span></code> is incremented by 1</li>
<li>For each sample, <code class="docutils literal"><span class="pre">E</span></code>, <code class="docutils literal"><span class="pre">O</span></code>, and <code class="docutils literal"><span class="pre">N</span></code> are combined across variants</li>
<li><code class="docutils literal"><span class="pre">F</span></code> is calculated by <code class="docutils literal"><span class="pre">(O</span> <span class="pre">-</span> <span class="pre">E)</span> <span class="pre">/</span> <span class="pre">(N</span> <span class="pre">-</span> <span class="pre">E)</span></code></li>
</ol>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>af</strong> (<em>Genotype =&gt; Double</em>) &#8211; Lambda expression for the alternate allele frequency.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>infoScore()</strong>: <em>Struct</em></p>
<blockquote>
<div><div class="annotation docutils container">
<ul class="simple">
<li><strong>score</strong> (<em>Double</em>) &#8211; IMPUTE info score</li>
<li><strong>nIncluded</strong> (<em>Int</em>) &#8211; Number of samples with non-missing dosages</li>
</ul>
</div>
<p>Compute the IMPUTE information score.</p>
<p><strong>Examples</strong></p>
<p>Calculate the info score per variant:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">hc</span><span class="o">.</span><span class="n">import_gen</span><span class="p">(</span><span class="s2">&quot;data/example.gen&quot;</span><span class="p">,</span> <span class="s2">&quot;data/example.sample&quot;</span><span class="p">)</span>
<span class="gp">... </span>   <span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="s1">&#39;va.infoScore = gs.infoScore()&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Calculate group-specific info scores per variant:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="p">(</span><span class="n">hc</span><span class="o">.</span><span class="n">import_gen</span><span class="p">(</span><span class="s2">&quot;data/example.gen&quot;</span><span class="p">,</span> <span class="s2">&quot;data/example.sample&quot;</span><span class="p">)</span>
<span class="gp">... </span>   <span class="o">.</span><span class="n">annotate_samples_expr</span><span class="p">(</span><span class="s2">&quot;sa.isCase = pcoin(0.5)&quot;</span><span class="p">)</span>
<span class="gp">... </span>   <span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">([</span><span class="s2">&quot;va.infoScore.case = gs.filter(g =&gt; sa.isCase).infoScore()&quot;</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="s2">&quot;va.infoScore.control = gs.filter(g =&gt; !sa.isCase).infoScore()&quot;</span><span class="p">]))</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>We implemented the IMPUTE info measure as described in the <a class="reference external" href="http://www.nature.com/nrg/journal/v11/n7/extref/nrg2796-s3.pdf">supplementary information from Marchini &amp; Howie. Genotype imputation for genome-wide association studies. Nature Reviews Genetics (2010)</a>.</p>
<p>To calculate the info score <span class="math">\(I_{A}\)</span> for one SNP:</p>
<div class="math">
\[\begin{split}I_{A} =
\begin{cases}
1 - \frac{\sum_{i=1}^{N}(f_{i} - e_{i}^2)}{2N\hat{\theta}(1 - \hat{\theta})} &amp; \text{when } \hat{\theta} \in (0, 1) \\
1 &amp; \text{when } \hat{\theta} = 0, \hat{\theta} = 1\\
\end{cases}\end{split}\]</div>
<ul class="simple">
<li><span class="math">\(N\)</span> is the number of samples with imputed genotype probabilities [<span class="math">\(p_{ik} = P(G_{i} = k)\)</span> where <span class="math">\(k \in \{0, 1, 2\}\)</span>]</li>
<li><span class="math">\(e_{i} = p_{i1} + 2p_{i2}\)</span> is the expected genotype per sample</li>
<li><span class="math">\(f_{i} = p_{i1} + 4p_{i2}\)</span></li>
<li><span class="math">\(\hat{\theta} = \frac{\sum_{i=1}^{N}e_{i}}{2N}\)</span> is the MLE for the population minor allele frequency</li>
</ul>
<p>Hail will not generate identical results as <a class="reference external" href="http://www.well.ox.ac.uk/~gav/qctool/#overview">QCTOOL</a> for the following reasons:</p>
<blockquote>
<div><ul class="simple">
<li>The floating point number Hail stores for each dosage is slightly different than the original data due to rounding and normalization of probabilities.</li>
<li>Hail automatically removes dosages that do not meet certain requirements on data import with <a class="reference internal" href="hail.HailContext.html#hail.HailContext.import_gen" title="hail.HailContext.import_gen"><code class="xref py py-meth docutils literal"><span class="pre">import_gen()</span></code></a> and <a class="reference internal" href="hail.HailContext.html#hail.HailContext.import_bgen" title="hail.HailContext.import_bgen"><code class="xref py py-meth docutils literal"><span class="pre">import_bgen()</span></code></a>.</li>
<li>Hail does not use the population frequency to impute dosages when a dosage has been set to missing.</li>
<li>Hail calculates the same statistic for sex chromosomes as autosomes while QCTOOL incorporates sex information</li>
</ul>
</div></blockquote>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<ul class="last simple">
<li>The info score Hail reports will be extremely different from qctool when a SNP has a high missing rate.</li>
<li>If the genotype data was not imported using the <a class="reference internal" href="hail.HailContext.html#hail.HailContext.import_gen" title="hail.HailContext.import_gen"><code class="xref py py-meth docutils literal"><span class="pre">import_gen()</span></code></a> or <a class="reference internal" href="hail.HailContext.html#hail.HailContext.import_bgen" title="hail.HailContext.import_bgen"><code class="xref py py-meth docutils literal"><span class="pre">import_bgen()</span></code></a> commands, then the results for all variants will be <code class="docutils literal"><span class="pre">score</span> <span class="pre">=</span> <span class="pre">NA</span></code> and <code class="docutils literal"><span class="pre">nIncluded</span> <span class="pre">=</span> <span class="pre">0</span></code>.</li>
<li>It only makes sense to compute the info score for an Aggregable[Genotype] per variant. While a per-sample info score will run, the result is meaningless.</li>
</ul>
</div>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="aggregable-int">
<span id="id9"></span><h3>Aggregable[Int]<a class="headerlink" href="#aggregable-int" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><strong>max()</strong>: <em>Int</em> &#8211; Compute the maximum of all non-missing elements. The empty max is missing.</li>
<li><strong>min()</strong>: <em>Int</em> &#8211; Compute the minimum of all non-missing elements. The empty min is missing.</li>
<li><strong>sum()</strong>: <em>Int</em> &#8211; Compute the sum of all non-missing elements. The empty sum is zero.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="aggregable-long">
<span id="id10"></span><h3>Aggregable[Long]<a class="headerlink" href="#aggregable-long" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><strong>max()</strong>: <em>Long</em> &#8211; Compute the maximum of all non-missing elements. The empty max is missing.</li>
<li><strong>min()</strong>: <em>Long</em> &#8211; Compute the minimum of all non-missing elements. The empty min is missing.</li>
<li><strong>sum()</strong>: <em>Long</em> &#8211; Compute the sum of all non-missing elements. The empty sum is zero.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="aggregable-t">
<span id="id11"></span><h3>Aggregable[T]<a class="headerlink" href="#aggregable-t" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><p class="first"><strong>collect()</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Returns an array with all of the elements in the aggregable. Missing values are removed.</p>
<p><strong>Examples</strong></p>
<p>Collect the list of sample IDs with heterozygote genotype calls per variant:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="s1">&#39;va.hetSamples = gs.filter(g =&gt; g.isHet()).map(g =&gt; s).collect()&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">va.hetSamples</span></code> will have the type <code class="docutils literal"><span class="pre">Array[String]</span></code>.</p>
</div></blockquote>
</li>
<li><p class="first"><strong>count()</strong>: <em>Long</em></p>
<blockquote>
<div><p>Counts the number of elements in an aggregable.</p>
<p><strong>Examples</strong></p>
<p>Count the number of heterozygote genotype calls in an aggregable of genotypes (<code class="docutils literal"><span class="pre">gs</span></code>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="s1">&#39;va.nHets = gs.filter(g =&gt; g.isHet()).count()&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first"><strong>counter()</strong>: <em>Dict[T, Long]</em></p>
<blockquote>
<div><p>Counts the number of occurrences of each element in an aggregable.</p>
<p><strong>Examples</strong></p>
<p>Compute the number of indels in each chromosome:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">indels_per_chr</span><span class="p">]</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_variants</span><span class="p">([</span><span class="s1">&#39;variants.filter(v =&gt; v.altAllele().isIndel()).map(v =&gt; v.contig).counter()&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>We recommend this function is used with the <a class="reference external" href="https://docs.python.org/2/library/collections.html#collections.Counter">Python counter object</a>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_variants</span><span class="p">([</span><span class="s1">&#39;variants.flatMap(v =&gt; v.altAlleles).counter()&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">counter</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">[(AltAllele(C, T), 129L),</span>
<span class="go"> (AltAllele(G, A), 112L),</span>
<span class="go"> (AltAllele(C, A), 60L),</span>
<span class="go"> (AltAllele(A, G), 46L),</span>
<span class="go"> (AltAllele(T, C), 44L)]</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first"><strong>filter(f: T =&gt; Boolean)</strong>: <em>Aggregable[T]</em></p>
<blockquote>
<div><p>Subsets an aggregable by evaluating <code class="docutils literal"><span class="pre">f</span></code> for each element and keeping those elements that evaluate to true.</p>
<p><strong>Examples</strong></p>
<p>Compute Hardy Weinberg Equilibrium for cases only:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="s2">&quot;va.hweCase = gs.filter(g =&gt; sa.isCase).hardyWeinberg()&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; Boolean</em>) &#8211; Boolean lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>flatMap(f: T =&gt; Set[U])</strong>: <em>Aggregable[U]</em></p>
<blockquote>
<div><p>Returns a new aggregable by applying a function <code class="docutils literal"><span class="pre">f</span></code> to each element and concatenating the resulting sets.</p>
<p>Compute a list of genes per sample with loss of function variants (result does not have duplicate entries):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_samples_expr</span><span class="p">(</span><span class="s1">&#39;sa.lof_genes = gs.filter(g =&gt; va.consequence == &quot;LOF&quot; &amp;&amp; g.nNonRefAlleles() &gt; 0).flatMap(g =&gt; va.genes.toSet()).collect()&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; Set[U]</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>flatMap(a: T =&gt; Array[U])</strong>: <em>Aggregable[U]</em></p>
<blockquote>
<div><p>Returns a new aggregable by applying a function <code class="docutils literal"><span class="pre">f</span></code> to each element and concatenating the resulting arrays.</p>
<p><strong>Examples</strong></p>
<p>Compute a list of genes per sample with loss of function variants (result may have duplicate entries):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_samples_expr</span><span class="p">(</span><span class="s1">&#39;sa.lof_genes = gs.filter(g =&gt; va.consequence == &quot;LOF&quot; &amp;&amp; g.nNonRefAlleles() &gt; 0).flatMap(g =&gt; va.genes).collect()&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first"><strong>fraction(a: T =&gt; Boolean)</strong>: <em>Double</em></p>
<blockquote>
<div><p>Computes the ratio of the number of occurrences for which a boolean condition evaluates to true, divided by the number of included elements in the aggregable.</p>
<p><strong>Examples</strong></p>
<p>Filter variants with a call rate less than 95%:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">filter_variants_expr</span><span class="p">(</span><span class="s1">&#39;gs.fraction(g =&gt; g.isCalled()) &gt; 0.90&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute the differential missingness at SNPs and indels:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sa.SNPmissingness = gs.filter(g =&gt; v.altAllele().isSNP()).fraction(g =&gt; g.isNotCalled())&#39;</span><span class="p">,</span>
<span class="gp">... </span>         <span class="s1">&#39;sa.indelmissingness = gs.filter(g =&gt; v.altAllele().isIndel()).fraction(g =&gt; g.isNotCalled())&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_samples_expr</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first"><strong>map(f: T =&gt; U)</strong>: <em>Aggregable[U]</em></p>
<blockquote>
<div><p>Change the type of an aggregable by evaluating <code class="docutils literal"><span class="pre">f</span></code> for each element.</p>
<p><strong>Examples</strong></p>
<p>Convert an aggregable of genotypes (<code class="docutils literal"><span class="pre">gs</span></code>) to an aggregable of genotype quality scores and then compute summary statistics:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="s2">&quot;va.gqStats = gs.map(g =&gt; g.gq).stats()&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; U</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>take(n: Int)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Take the first <code class="docutils literal"><span class="pre">n</span></code> items of an aggregable.</p>
<p><strong>Examples</strong></p>
<p>Collect the first 5 sample IDs with at least one alternate allele per variant:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="s2">&quot;va.nonRefSamples = gs.filter(g =&gt; g.nNonRefAlleles() &gt; 0).map(g =&gt; s).take(5)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>n</strong> (<em>Int</em>) &#8211; Number of items to take.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>takeBy(f: T =&gt; String, n: Int)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Take the first <code class="docutils literal"><span class="pre">n</span></code> items of an aggregable ordered by the result of <code class="docutils literal"><span class="pre">f</span></code>.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; String</em>) &#8211; Lambda expression for mapping an aggregable to an ordered value.</li>
<li><strong>n</strong> (<em>Int</em>) &#8211; Number of items to take.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>takeBy(f: T =&gt; Double, n: Int)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Take the first <code class="docutils literal"><span class="pre">n</span></code> items of an aggregable ordered by the result of <code class="docutils literal"><span class="pre">f</span></code>.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; Double</em>) &#8211; Lambda expression for mapping an aggregable to an ordered value.</li>
<li><strong>n</strong> (<em>Int</em>) &#8211; Number of items to take.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>takeBy(f: T =&gt; Float, n: Int)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Take the first <code class="docutils literal"><span class="pre">n</span></code> items of an aggregable ordered by the result of <code class="docutils literal"><span class="pre">f</span></code>.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; Float</em>) &#8211; Lambda expression for mapping an aggregable to an ordered value.</li>
<li><strong>n</strong> (<em>Int</em>) &#8211; Number of items to take.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>takeBy(f: T =&gt; Long, n: Int)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Take the first <code class="docutils literal"><span class="pre">n</span></code> items of an aggregable ordered by the result of <code class="docutils literal"><span class="pre">f</span></code>.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; Long</em>) &#8211; Lambda expression for mapping an aggregable to an ordered value.</li>
<li><strong>n</strong> (<em>Int</em>) &#8211; Number of items to take.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>takeBy(f: T =&gt; Int, n: Int)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Take the first <code class="docutils literal"><span class="pre">n</span></code> items of an aggregable ordered by the result of <code class="docutils literal"><span class="pre">f</span></code>.</p>
<p><strong>Examples</strong></p>
<p>Returns the 10 samples with the largest number of singletons:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">samplesMostSingletons</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">vds</span>
<span class="gp">... </span>  <span class="o">.</span><span class="n">sample_qc</span><span class="p">()</span>
<span class="gp">... </span>  <span class="o">.</span><span class="n">query_samples</span><span class="p">([</span><span class="s1">&#39;samples.takeBy(s =&gt; sa.qc.nSingleton, 10)&#39;</span><span class="p">]))</span>
</pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; Int</em>) &#8211; Lambda expression for mapping an aggregable to an ordered value.</li>
<li><strong>n</strong> (<em>Int</em>) &#8211; Number of items to take.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="altallele">
<span id="id12"></span><h2>AltAllele<a class="headerlink" href="#altallele" title="Permalink to this headline">¶</a></h2>
<p>An <code class="docutils literal"><span class="pre">AltAllele</span></code> is a Hail data type representing an alternate allele in the Variant Dataset.</p>
<blockquote>
<div><ul class="simple">
<li><strong>alt</strong>: <em>String</em> &#8211; Alternate allele base sequence.</li>
<li><strong>isComplex()</strong>: <em>Boolean</em> &#8211; True if not a SNP, MNP, star, insertion, or deletion.</li>
<li><strong>isDeletion()</strong>: <em>Boolean</em> &#8211; True if <code class="docutils literal"><span class="pre">v.ref</span></code> begins with and is longer than <code class="docutils literal"><span class="pre">v.alt</span></code>.</li>
<li><strong>isIndel()</strong>: <em>Boolean</em> &#8211; True if an insertion or a deletion.</li>
<li><strong>isInsertion()</strong>: <em>Boolean</em> &#8211; True if <code class="docutils literal"><span class="pre">v.alt</span></code> begins with and is longer than <code class="docutils literal"><span class="pre">v.ref</span></code>.</li>
<li><strong>isMNP()</strong>: <em>Boolean</em> &#8211; True if <code class="docutils literal"><span class="pre">v.ref</span></code> and <code class="docutils literal"><span class="pre">v.alt</span></code> are the same length and differ in more than one position.</li>
<li><strong>isSNP()</strong>: <em>Boolean</em> &#8211; True if <code class="docutils literal"><span class="pre">v.ref</span></code> and <code class="docutils literal"><span class="pre">v.alt</span></code> are the same length and differ in one position.</li>
<li><strong>isStar()</strong>: <em>Boolean</em> &#8211; True if <code class="docutils literal"><span class="pre">v.alt</span></code> is <code class="docutils literal"><span class="pre">*</span></code>.</li>
<li><strong>isTransition()</strong>: <em>Boolean</em> &#8211; True if a purine-purine or pyrimidine-pyrimidine SNP.</li>
<li><strong>isTransversion()</strong>: <em>Boolean</em> &#8211; True if a purine-pyrimidine SNP.</li>
<li><strong>ref</strong>: <em>String</em> &#8211; Reference allele base sequence.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="array">
<span id="id13"></span><h2>Array<a class="headerlink" href="#array" title="Permalink to this headline">¶</a></h2>
<p>An <code class="docutils literal"><span class="pre">Array</span></code> is a collection of items that all have the same data type (ex: Int, String) and are indexed. Arrays can be constructed by specifying <code class="docutils literal"><span class="pre">[item1,</span> <span class="pre">item2,</span> <span class="pre">...]</span></code> and they are 0-indexed.</p>
<p>An example of constructing an array and accessing an element is:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let a = [1, 10, 3, 7] in a[1]
<span class="hll">result: 10
</span></pre></div>
</div>
<p>They can also be nested such as Array[Array[Int]]:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let a = [[1, 2, 3], [4, 5], [], [6, 7]] in a[1]
<span class="hll">result: [4, 5]
</span></pre></div>
</div>
<div class="section" id="array-array-t">
<span id="id14"></span><h3>Array[Array[T]]<a class="headerlink" href="#array-array-t" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><p class="first"><strong>flatten()</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Flattens a nested array by concatenating all its rows into a single array.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let a = [[1, 3], [2, 4]] in a.flatten()
<span class="hll">result: [1, 3, 2, 4]
</span></pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="array-boolean">
<span id="id15"></span><h3>Array[Boolean]<a class="headerlink" href="#array-boolean" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><p class="first"><strong>sort(ascending: Boolean)</strong>: <em>Array[Boolean]</em></p>
<blockquote>
<div><p>Sort the collection with the ordering specified by <code class="docutils literal"><span class="pre">ascending</span></code>.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>ascending</strong> (<em>Boolean</em>) &#8211; If true, sort the collection in ascending order. Otherwise, sort in descending order.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>sort()</strong>: <em>Array[Boolean]</em> &#8211; Sort the collection in ascending order.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="array-double">
<span id="id16"></span><h3>Array[Double]<a class="headerlink" href="#array-double" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><p class="first"><strong>max()</strong>: <em>Double</em> &#8211; Largest element in the collection.</p>
</li>
<li><p class="first"><strong>mean()</strong>: <em>Double</em> &#8211; Mean value of the collection.</p>
</li>
<li><p class="first"><strong>median()</strong>: <em>Double</em> &#8211; Median value of the collection.</p>
</li>
<li><p class="first"><strong>min()</strong>: <em>Double</em> &#8211; Smallest element in the collection.</p>
</li>
<li><p class="first"><strong>sort(ascending: Boolean)</strong>: <em>Array[Double]</em></p>
<blockquote>
<div><p>Sort the collection with the ordering specified by <code class="docutils literal"><span class="pre">ascending</span></code>.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>ascending</strong> (<em>Boolean</em>) &#8211; If true, sort the collection in ascending order. Otherwise, sort in descending order.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>sort()</strong>: <em>Array[Double]</em> &#8211; Sort the collection in ascending order.</p>
</li>
<li><p class="first"><strong>sum()</strong>: <em>Double</em> &#8211; Sum of all elements in the collection.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="array-float">
<span id="id17"></span><h3>Array[Float]<a class="headerlink" href="#array-float" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><p class="first"><strong>max()</strong>: <em>Float</em> &#8211; Largest element in the collection.</p>
</li>
<li><p class="first"><strong>mean()</strong>: <em>Double</em> &#8211; Mean value of the collection.</p>
</li>
<li><p class="first"><strong>median()</strong>: <em>Float</em> &#8211; Median value of the collection.</p>
</li>
<li><p class="first"><strong>min()</strong>: <em>Float</em> &#8211; Smallest element in the collection.</p>
</li>
<li><p class="first"><strong>sort(ascending: Boolean)</strong>: <em>Array[Float]</em></p>
<blockquote>
<div><p>Sort the collection with the ordering specified by <code class="docutils literal"><span class="pre">ascending</span></code>.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>ascending</strong> (<em>Boolean</em>) &#8211; If true, sort the collection in ascending order. Otherwise, sort in descending order.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>sort()</strong>: <em>Array[Float]</em> &#8211; Sort the collection in ascending order.</p>
</li>
<li><p class="first"><strong>sum()</strong>: <em>Float</em> &#8211; Sum of all elements in the collection.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="array-int">
<span id="id18"></span><h3>Array[Int]<a class="headerlink" href="#array-int" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><p class="first"><strong>max()</strong>: <em>Int</em> &#8211; Largest element in the collection.</p>
</li>
<li><p class="first"><strong>mean()</strong>: <em>Double</em> &#8211; Mean value of the collection.</p>
</li>
<li><p class="first"><strong>median()</strong>: <em>Int</em> &#8211; Median value of the collection.</p>
</li>
<li><p class="first"><strong>min()</strong>: <em>Int</em> &#8211; Smallest element in the collection.</p>
</li>
<li><p class="first"><strong>sort(ascending: Boolean)</strong>: <em>Array[Int]</em></p>
<blockquote>
<div><p>Sort the collection with the ordering specified by <code class="docutils literal"><span class="pre">ascending</span></code>.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>ascending</strong> (<em>Boolean</em>) &#8211; If true, sort the collection in ascending order. Otherwise, sort in descending order.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>sort()</strong>: <em>Array[Int]</em> &#8211; Sort the collection in ascending order.</p>
</li>
<li><p class="first"><strong>sum()</strong>: <em>Int</em> &#8211; Sum of all elements in the collection.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="array-long">
<span id="id19"></span><h3>Array[Long]<a class="headerlink" href="#array-long" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><p class="first"><strong>max()</strong>: <em>Long</em> &#8211; Largest element in the collection.</p>
</li>
<li><p class="first"><strong>mean()</strong>: <em>Double</em> &#8211; Mean value of the collection.</p>
</li>
<li><p class="first"><strong>median()</strong>: <em>Long</em> &#8211; Median value of the collection.</p>
</li>
<li><p class="first"><strong>min()</strong>: <em>Long</em> &#8211; Smallest element in the collection.</p>
</li>
<li><p class="first"><strong>sort(ascending: Boolean)</strong>: <em>Array[Long]</em></p>
<blockquote>
<div><p>Sort the collection with the ordering specified by <code class="docutils literal"><span class="pre">ascending</span></code>.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>ascending</strong> (<em>Boolean</em>) &#8211; If true, sort the collection in ascending order. Otherwise, sort in descending order.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>sort()</strong>: <em>Array[Long]</em> &#8211; Sort the collection in ascending order.</p>
</li>
<li><p class="first"><strong>sum()</strong>: <em>Long</em> &#8211; Sum of all elements in the collection.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="array-string">
<span id="id20"></span><h3>Array[String]<a class="headerlink" href="#array-string" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><p class="first"><strong>mkString(delimiter: String)</strong>: <em>String</em></p>
<blockquote>
<div><p>Concatenates all elements of this array into a single string where each element is separated by the <code class="docutils literal"><span class="pre">delimiter</span></code>.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] in a.mkString(&quot;::&quot;)
<span class="hll">result: &quot;a::b::c&quot;
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>delimiter</strong> (<em>String</em>) &#8211; String that separates each element.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>sort(ascending: Boolean)</strong>: <em>Array[String]</em></p>
<blockquote>
<div><p>Sort the collection with the ordering specified by <code class="docutils literal"><span class="pre">ascending</span></code>.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>ascending</strong> (<em>Boolean</em>) &#8211; If true, sort the collection in ascending order. Otherwise, sort in descending order.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>sort()</strong>: <em>Array[String]</em> &#8211; Sort the collection in ascending order.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="array-t">
<span id="id21"></span><h3>Array[T]<a class="headerlink" href="#array-t" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><p class="first"><strong>[:j]</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Returns a slice of the array from the first element until the j*th* element (0-indexed).</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let a = [0, 2, 4, 6, 8, 10] in a[:4]
<span class="hll">result: [0, 2, 4, 6]
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>j</strong> (<em>Int</em>) &#8211; End index of the slice (not included in result).</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>[:]</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Returns a copy of the array.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let a = [0, 2, 4, 6] in a[:]
<span class="hll">result: [0, 2, 4, 6]
</span></pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first"><strong>[i:j]</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Returns a slice of the array from the i*th* element until the j*th* element (both 0-indexed).</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let a = [0, 2, 4, 6, 8, 10] in a[2:4]
<span class="hll">result: [4, 6]
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>i</strong> (<em>Int</em>) &#8211; Starting index of the slice.</li>
<li><strong>j</strong> (<em>Int</em>) &#8211; End index of the slice (not included in result).</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>[i:]</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Returns a slice of the array from the i*th* element (0-indexed) to the end.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let a = [0, 2, 4, 6, 8, 10] in a[3:]
<span class="hll">result: [6, 8, 10]
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>i</strong> (<em>Int</em>) &#8211; Starting index of the slice.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>[i]</strong>: <em>T</em></p>
<blockquote>
<div><p>Returns the i*th* element (0-indexed) of the array, or throws an exception if <code class="docutils literal"><span class="pre">i</span></code> is an invalid index.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let a = [0, 2, 4, 6, 8, 10] in a[2]
<span class="hll">result: 4
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>i</strong> (<em>Int</em>) &#8211; Index of the element to return.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>append(a: T)</strong>: <em>Array[T]</em> &#8211;      Returns the result of adding the element <cite>a</cite> to the end of this Array.</p>
</li>
<li><p class="first"><strong>exists(expr: T =&gt; Boolean)</strong>: <em>Boolean</em></p>
<blockquote>
<div><p>Returns a boolean which is true if <strong>any</strong> element in the array satisfies the condition given by <code class="docutils literal"><span class="pre">expr</span></code>. false otherwise.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let a = [1, 2, 3, 4, 5, 6] in a.exists(e =&gt; e &gt; 4)
<span class="hll">result: true
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>expr</strong> (<em>T =&gt; Boolean</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>extend(a: Array[T])</strong>: <em>Array[T]</em> &#8211;       Returns the concatenation of this Array followed by Array <cite>a</cite>.</p>
</li>
<li><p class="first"><strong>filter(expr: T =&gt; Boolean)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Returns a new array subsetted to the elements where <code class="docutils literal"><span class="pre">expr</span></code> evaluates to true.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let a = [1, 4, 5, 6, 10] in a.filter(e =&gt; e % 2 == 0)
<span class="hll">result: [4, 6, 10]
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>expr</strong> (<em>T =&gt; Boolean</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>find(expr: T =&gt; Boolean)</strong>: <em>T</em></p>
<blockquote>
<div><p>Returns the first non-missing element of the array for which expr is true. If no element satisfies the predicate, find returns NA.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let a = [&quot;cat&quot;, &quot;dog&quot;, &quot;rabbit&quot;] in a.find(e =&gt; &#39;bb&#39; ~ e)
<span class="hll">result: &quot;rabbit&quot;
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>expr</strong> (<em>T =&gt; Boolean</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>flatMap(expr: T =&gt; Array[U])</strong>: <em>Array[U]</em></p>
<blockquote>
<div><p>Returns a new array by applying a function to each subarray and concatenating the resulting arrays.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let a = [[1, 2, 3], [4, 5], [6]] in a.flatMap(e =&gt; e + 1)
<span class="hll">result: [2, 3, 4, 5, 6, 7]
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>expr</strong> (<em>T =&gt; Array[U]</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>forall(expr: T =&gt; Boolean)</strong>: <em>Boolean</em></p>
<blockquote>
<div><p>Returns a boolean which is true if <strong>all</strong> elements in the array satisfies the condition given by <code class="docutils literal"><span class="pre">expr</span></code> and false otherwise.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let a = [0, 2, 4, 6, 8, 10] in a.forall(e =&gt; e % 2 == 0)
<span class="hll">result: true
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>expr</strong> (<em>T =&gt; Boolean</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>groupBy(a: T =&gt; U)</strong>: <em>Dict[U, Array[T]]</em></p>
</li>
<li><p class="first"><strong>head()</strong>: <em>T</em> &#8211; Selects the first element.</p>
</li>
<li><p class="first"><strong>isEmpty()</strong>: <em>Boolean</em> &#8211; Returns true if the number of elements is equal to 0. false otherwise.</p>
</li>
<li><p class="first"><strong>length()</strong>: <em>Int</em> &#8211; Number of elements in the collection.</p>
</li>
<li><p class="first"><strong>map(expr: T =&gt; U)</strong>: <em>Array[U]</em></p>
<blockquote>
<div><p>Returns a new array produced by applying <code class="docutils literal"><span class="pre">expr</span></code> to each element.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let a = [0, 1, 2, 3] in a.map(e =&gt; pow(2, e))
<span class="hll">result: [1, 2, 4, 8]
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>expr</strong> (<em>T =&gt; U</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>size()</strong>: <em>Int</em> &#8211; Number of elements in the collection.</p>
</li>
<li><p class="first"><strong>sortBy(f: T =&gt; String, ascending: Boolean)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Sort the collection with the ordering specified by <code class="docutils literal"><span class="pre">ascending</span></code> after evaluating <code class="docutils literal"><span class="pre">f</span></code> for each element.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; String</em>) &#8211; Lambda expression.</li>
<li><strong>ascending</strong> (<em>Boolean</em>) &#8211; If true, sort the collection in ascending order. Otherwise, sort in descending order.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>sortBy(f: T =&gt; String)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Sort the collection in ascending order after evaluating <code class="docutils literal"><span class="pre">f</span></code> for each element.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; String</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>sortBy(f: T =&gt; Double, ascending: Boolean)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Sort the collection with the ordering specified by <code class="docutils literal"><span class="pre">ascending</span></code> after evaluating <code class="docutils literal"><span class="pre">f</span></code> for each element.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; Double</em>) &#8211; Lambda expression.</li>
<li><strong>ascending</strong> (<em>Boolean</em>) &#8211; If true, sort the collection in ascending order. Otherwise, sort in descending order.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>sortBy(f: T =&gt; Double)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Sort the collection in ascending order after evaluating <code class="docutils literal"><span class="pre">f</span></code> for each element.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; Double</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>sortBy(f: T =&gt; Float, ascending: Boolean)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Sort the collection with the ordering specified by <code class="docutils literal"><span class="pre">ascending</span></code> after evaluating <code class="docutils literal"><span class="pre">f</span></code> for each element.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; Float</em>) &#8211; Lambda expression.</li>
<li><strong>ascending</strong> (<em>Boolean</em>) &#8211; If true, sort the collection in ascending order. Otherwise, sort in descending order.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>sortBy(f: T =&gt; Float)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Sort the collection in ascending order after evaluating <code class="docutils literal"><span class="pre">f</span></code> for each element.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; Float</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>sortBy(f: T =&gt; Long, ascending: Boolean)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Sort the collection with the ordering specified by <code class="docutils literal"><span class="pre">ascending</span></code> after evaluating <code class="docutils literal"><span class="pre">f</span></code> for each element.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; Long</em>) &#8211; Lambda expression.</li>
<li><strong>ascending</strong> (<em>Boolean</em>) &#8211; If true, sort the collection in ascending order. Otherwise, sort in descending order.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>sortBy(f: T =&gt; Long)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Sort the collection in ascending order after evaluating <code class="docutils literal"><span class="pre">f</span></code> for each element.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; Long</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>sortBy(f: T =&gt; Int, ascending: Boolean)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Sort the collection with the ordering specified by <code class="docutils literal"><span class="pre">ascending</span></code> after evaluating <code class="docutils literal"><span class="pre">f</span></code> for each element.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; Int</em>) &#8211; Lambda expression.</li>
<li><strong>ascending</strong> (<em>Boolean</em>) &#8211; If true, sort the collection in ascending order. Otherwise, sort in descending order.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>sortBy(f: T =&gt; Int)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Sort the collection in ascending order after evaluating <code class="docutils literal"><span class="pre">f</span></code> for each element.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; Int</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>sortBy(f: T =&gt; Boolean, ascending: Boolean)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Sort the collection with the ordering specified by <code class="docutils literal"><span class="pre">ascending</span></code> after evaluating <code class="docutils literal"><span class="pre">f</span></code> for each element.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; Boolean</em>) &#8211; Lambda expression.</li>
<li><strong>ascending</strong> (<em>Boolean</em>) &#8211; If true, sort the collection in ascending order. Otherwise, sort in descending order.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>sortBy(f: T =&gt; Boolean)</strong>: <em>Array[T]</em></p>
<blockquote>
<div><p>Sort the collection in ascending order after evaluating <code class="docutils literal"><span class="pre">f</span></code> for each element.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>f</strong> (<em>T =&gt; Boolean</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>tail()</strong>: <em>Array[T]</em> &#8211; Selects all elements except the first.</p>
</li>
<li><p class="first"><strong>toArray()</strong>: <em>Array[T]</em> &#8211; Convert collection to an Array.</p>
</li>
<li><p class="first"><strong>toSet()</strong>: <em>Set[T]</em> &#8211; Convert collection to a Set.</p>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="boolean">
<span id="id22"></span><h2>Boolean<a class="headerlink" href="#boolean" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><strong>max(a: Boolean)</strong>: <em>Boolean</em> &#8211;    Returns the maximum value.</li>
<li><strong>min(a: Boolean)</strong>: <em>Boolean</em> &#8211;    Returns the minimum value.</li>
<li><strong>toDouble()</strong>: <em>Double</em> &#8211; Convert value to a Double. Returns 1.0 if true, else 0.0.</li>
<li><strong>toFloat()</strong>: <em>Float</em> &#8211; Convert value to a Float. Returns 1.0 if true, else 0.0.</li>
<li><strong>toInt()</strong>: <em>Int</em> &#8211; Convert value to an Integer. Returns 1 if true, else 0.</li>
<li><strong>toLong()</strong>: <em>Long</em> &#8211; Convert value to a Long. Returns 1L if true, else 0L.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="call">
<span id="id23"></span><h2>Call<a class="headerlink" href="#call" title="Permalink to this headline">¶</a></h2>
<p>A <code class="docutils literal"><span class="pre">Call</span></code> is a Hail data type representing a genotype call (ex: 0/0) in the Variant Dataset.</p>
<blockquote>
<div><ul>
<li><p class="first"><strong>gt</strong>: <em>Int</em> &#8211; the integer <code class="docutils literal"><span class="pre">gt</span> <span class="pre">=</span> <span class="pre">k*(k+1)/2</span> <span class="pre">+</span> <span class="pre">j</span></code> for call <code class="docutils literal"><span class="pre">j/k</span></code> (0 = 0/0, 1 = 0/1, 2 = 1/1, 3 = 0/2, etc.).</p>
</li>
<li><p class="first"><strong>gtj()</strong>: <em>Int</em> &#8211; the index of allele <code class="docutils literal"><span class="pre">j</span></code> for call <code class="docutils literal"><span class="pre">j/k</span></code> (0 = ref, 1 = first alt allele, etc.).</p>
</li>
<li><p class="first"><strong>gtk()</strong>: <em>Int</em> &#8211; the index of allele <code class="docutils literal"><span class="pre">k</span></code> for call <code class="docutils literal"><span class="pre">j/k</span></code> (0 = ref, 1 = first alt allele, etc.).</p>
</li>
<li><p class="first"><strong>isCalled()</strong>: <em>Boolean</em> &#8211; True if the call is not <code class="docutils literal"><span class="pre">./.</span></code>.</p>
</li>
<li><p class="first"><strong>isCalledNonRef()</strong>: <em>Boolean</em> &#8211; True if either <code class="docutils literal"><span class="pre">isHet</span></code> or <code class="docutils literal"><span class="pre">isHomVar</span></code> is true.</p>
</li>
<li><p class="first"><strong>isHet()</strong>: <em>Boolean</em> &#8211; True if this call is heterozygous.</p>
</li>
<li><p class="first"><strong>isHetNonRef()</strong>: <em>Boolean</em> &#8211; True if this call is <code class="docutils literal"><span class="pre">j/k</span></code> with <code class="docutils literal"><span class="pre">j&gt;0</span></code>.</p>
</li>
<li><p class="first"><strong>isHetRef()</strong>: <em>Boolean</em> &#8211; True if this call is <code class="docutils literal"><span class="pre">0/k</span></code> with <code class="docutils literal"><span class="pre">k&gt;0</span></code>.</p>
</li>
<li><p class="first"><strong>isHomRef()</strong>: <em>Boolean</em> &#8211; True if this call is <code class="docutils literal"><span class="pre">0/0</span></code>.</p>
</li>
<li><p class="first"><strong>isHomVar()</strong>: <em>Boolean</em> &#8211; True if this call is <code class="docutils literal"><span class="pre">j/j</span></code> with <code class="docutils literal"><span class="pre">j&gt;0</span></code>.</p>
</li>
<li><p class="first"><strong>isNotCalled()</strong>: <em>Boolean</em> &#8211; True if the call is <code class="docutils literal"><span class="pre">./.</span></code>.</p>
</li>
<li><p class="first"><strong>nNonRefAlleles()</strong>: <em>Int</em> &#8211; the number of called alternate alleles.</p>
</li>
<li><p class="first"><strong>oneHotAlleles(v: Variant)</strong>: <em>Array[Int]</em></p>
<blockquote>
<div><p>Produce an array of called counts for each allele in the variant (including reference). For example, calling this function with a biallelic variant on hom-ref, het, and hom-var calls will produce <code class="docutils literal"><span class="pre">[2,</span> <span class="pre">0]</span></code>, <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">1]</span></code>, and <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">2]</span></code> respectively.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>v</strong> (<em>Variant</em>) &#8211; <a class="reference internal" href="#variant"><span class="std std-ref">Variant</span></a></li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>oneHotGenotype(v: Variant)</strong>: <em>Array[Int]</em></p>
<blockquote>
<div><p>Produces an array with one element for each possible genotype in the variant, where the called genotype is 1 and all else 0. For example, calling this function with a biallelic variant on hom-ref, het, and hom-var calls will produce <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>, <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">0]</span></code>, and <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">1]</span></code> respectively.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>v</strong> (<em>Variant</em>) &#8211; <a class="reference internal" href="#variant"><span class="std std-ref">Variant</span></a></li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>toGenotype()</strong>: <em>Genotype</em> &#8211; Convert this call to a Genotype.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="dict">
<span id="id24"></span><h2>Dict<a class="headerlink" href="#dict" title="Permalink to this headline">¶</a></h2>
<p>A <code class="docutils literal"><span class="pre">Dict</span></code> is an unordered collection of key-value pairs. Each key can only appear once in the collection.</p>
<blockquote>
<div><ul>
<li><p class="first"><strong>[k]</strong>: <em>U</em></p>
<blockquote>
<div><p>Returns the value for <code class="docutils literal"><span class="pre">k</span></code>, or throws an exception if the key is not found.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>k</strong> (<em>T</em>) &#8211; Key in the Dict to query.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>contains(k: T)</strong>: <em>Boolean</em></p>
<blockquote>
<div><p>Returns true if the Dict has a key equal to <code class="docutils literal"><span class="pre">k</span></code>, otherwise false.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>k</strong> (<em>T</em>) &#8211; Key name to query.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>get(a: T)</strong>: <em>U</em> &#8211;        Returns the value of the Dict for key <code class="docutils literal"><span class="pre">k</span></code>, or returns <code class="docutils literal"><span class="pre">NA</span></code> if the key is not found.</p>
</li>
<li><p class="first"><strong>isEmpty()</strong>: <em>Boolean</em> &#8211; Returns true if the number of elements is equal to 0. false otherwise.</p>
</li>
<li><p class="first"><strong>keySet()</strong>: <em>Set[T]</em> &#8211; Returns a Set containing the keys of the Dict.</p>
</li>
<li><p class="first"><strong>keys()</strong>: <em>Array[T]</em> &#8211; Returns an Array containing the keys of the Dict.</p>
</li>
<li><p class="first"><strong>mapValues(expr: U =&gt; V)</strong>: <em>Dict[T, V]</em></p>
<blockquote>
<div><p>Returns a new Dict produced by applying <code class="docutils literal"><span class="pre">expr</span></code> to each value. The keys are unmodified.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>expr</strong> (<em>U =&gt; V</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>size()</strong>: <em>Int</em> &#8211; Number of elements in the collection.</p>
</li>
<li><p class="first"><strong>values()</strong>: <em>Array[U]</em> &#8211; Returns an Array containing the values of the Dict.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="double">
<span id="id25"></span><h2>Double<a class="headerlink" href="#double" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><strong>abs()</strong>: <em>Double</em> &#8211; Returns the absolute value of a number.</li>
<li><strong>max(a: Double)</strong>: <em>Double</em> &#8211;      Returns the maximum value.</li>
<li><strong>min(a: Double)</strong>: <em>Double</em> &#8211;      Returns the minimum value.</li>
<li><strong>signum()</strong>: <em>Int</em> &#8211; Returns the sign of a number (1, 0, or -1).</li>
<li><strong>toDouble()</strong>: <em>Double</em> &#8211; Convert value to a Double.</li>
<li><strong>toFloat()</strong>: <em>Float</em> &#8211; Convert value to a Float.</li>
<li><strong>toInt()</strong>: <em>Int</em> &#8211; Convert value to an Integer.</li>
<li><strong>toLong()</strong>: <em>Long</em> &#8211; Convert value to a Long.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="float">
<span id="id26"></span><h2>Float<a class="headerlink" href="#float" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><strong>abs()</strong>: <em>Float</em> &#8211; Returns the absolute value of a number.</li>
<li><strong>max(a: Float)</strong>: <em>Float</em> &#8211;        Returns the maximum value.</li>
<li><strong>min(a: Float)</strong>: <em>Float</em> &#8211;        Returns the minimum value.</li>
<li><strong>signum()</strong>: <em>Int</em> &#8211; Returns the sign of a number (1, 0, or -1).</li>
<li><strong>toDouble()</strong>: <em>Double</em> &#8211; Convert value to a Double.</li>
<li><strong>toFloat()</strong>: <em>Float</em> &#8211; Convert value to a Float.</li>
<li><strong>toInt()</strong>: <em>Int</em> &#8211; Convert value to an Integer.</li>
<li><strong>toLong()</strong>: <em>Long</em> &#8211; Convert value to a Long.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="genotype">
<span id="id27"></span><h2>Genotype<a class="headerlink" href="#genotype" title="Permalink to this headline">¶</a></h2>
<p>A <code class="docutils literal"><span class="pre">Genotype</span></code> is a Hail data type representing a genotype in the Variant Dataset. It is referred to as <code class="docutils literal"><span class="pre">g</span></code> in the expression language.</p>
<blockquote>
<div><ul>
<li><p class="first"><strong>ad</strong>: <em>Array[Int]</em> &#8211; allelic depth for each allele.</p>
</li>
<li><p class="first"><strong>call()</strong>: <em>Call</em> &#8211; the integer <code class="docutils literal"><span class="pre">gt</span> <span class="pre">=</span> <span class="pre">k*(k+1)/2</span> <span class="pre">+</span> <span class="pre">j</span></code> for call <code class="docutils literal"><span class="pre">j/k</span></code> (0 = 0/0, 1 = 0/1, 2 = 1/1, 3 = 0/2, etc.).</p>
</li>
<li><p class="first"><strong>dosage</strong>: <em>Array[Double]</em> &#8211; the linear-scaled probabilities.</p>
</li>
<li><p class="first"><strong>dp</strong>: <em>Int</em> &#8211; the total number of informative reads.</p>
</li>
<li><p class="first"><strong>fakeRef</strong>: <em>Boolean</em> &#8211; True if this genotype was downcoded in <a class="reference internal" href="hail.VariantDataset.html#hail.VariantDataset.split_multi" title="hail.VariantDataset.split_multi"><code class="xref py py-meth docutils literal"><span class="pre">split_multi()</span></code></a>.  This can happen if a <code class="docutils literal"><span class="pre">1/2</span></code> call is split to <code class="docutils literal"><span class="pre">0/1</span></code>, <code class="docutils literal"><span class="pre">0/1</span></code>.</p>
</li>
<li><p class="first"><strong>fractionReadsRef()</strong>: <em>Double</em> &#8211; the ratio of ref reads to the sum of all <em>informative</em> reads.</p>
</li>
<li><p class="first"><strong>gq</strong>: <em>Int</em> &#8211; the difference between the two smallest PL entries.</p>
</li>
<li><p class="first"><strong>gt</strong>: <em>Int</em> &#8211; the integer <code class="docutils literal"><span class="pre">gt</span> <span class="pre">=</span> <span class="pre">k*(k+1)/2</span> <span class="pre">+</span> <span class="pre">j</span></code> for call <code class="docutils literal"><span class="pre">j/k</span></code> (0 = 0/0, 1 = 0/1, 2 = 1/1, 3 = 0/2, etc.).</p>
</li>
<li><p class="first"><strong>gtj()</strong>: <em>Int</em> &#8211; the index of allele <code class="docutils literal"><span class="pre">j</span></code> for call <code class="docutils literal"><span class="pre">j/k</span></code> (0 = ref, 1 = first alt allele, etc.).</p>
</li>
<li><p class="first"><strong>gtk()</strong>: <em>Int</em> &#8211; the index of allele <code class="docutils literal"><span class="pre">k</span></code> for call <code class="docutils literal"><span class="pre">j/k</span></code> (0 = ref, 1 = first alt allele, etc.).</p>
</li>
<li><p class="first"><strong>isCalled()</strong>: <em>Boolean</em> &#8211; True if the genotype is not <code class="docutils literal"><span class="pre">./.</span></code>.</p>
</li>
<li><p class="first"><strong>isCalledNonRef()</strong>: <em>Boolean</em> &#8211; True if either <code class="docutils literal"><span class="pre">g.isHet</span></code> or <code class="docutils literal"><span class="pre">g.isHomVar</span></code> is true.</p>
</li>
<li><p class="first"><strong>isDosage</strong>: <em>Boolean</em> &#8211; True if the data was imported from <a class="reference internal" href="hail.HailContext.html#hail.HailContext.import_gen" title="hail.HailContext.import_gen"><code class="xref py py-meth docutils literal"><span class="pre">import_gen()</span></code></a> or <a class="reference internal" href="hail.HailContext.html#hail.HailContext.import_bgen" title="hail.HailContext.import_bgen"><code class="xref py py-meth docutils literal"><span class="pre">import_bgen()</span></code></a>.</p>
</li>
<li><p class="first"><strong>isHet()</strong>: <em>Boolean</em> &#8211; True if this call is heterozygous.</p>
</li>
<li><p class="first"><strong>isHetNonRef()</strong>: <em>Boolean</em> &#8211; True if this call is <code class="docutils literal"><span class="pre">j/k</span></code> with <code class="docutils literal"><span class="pre">j&gt;0</span></code>.</p>
</li>
<li><p class="first"><strong>isHetRef()</strong>: <em>Boolean</em> &#8211; True if this call is <code class="docutils literal"><span class="pre">0/k</span></code> with <code class="docutils literal"><span class="pre">k&gt;0</span></code>.</p>
</li>
<li><p class="first"><strong>isHomRef()</strong>: <em>Boolean</em> &#8211; True if this call is <code class="docutils literal"><span class="pre">0/0</span></code>.</p>
</li>
<li><p class="first"><strong>isHomVar()</strong>: <em>Boolean</em> &#8211; True if this call is <code class="docutils literal"><span class="pre">j/j</span></code> with <code class="docutils literal"><span class="pre">j&gt;0</span></code>.</p>
</li>
<li><p class="first"><strong>isNotCalled()</strong>: <em>Boolean</em> &#8211; True if the genotype is <code class="docutils literal"><span class="pre">./.</span></code>.</p>
</li>
<li><p class="first"><strong>nNonRefAlleles()</strong>: <em>Int</em> &#8211; the number of called alternate alleles.</p>
</li>
<li><p class="first"><strong>od()</strong>: <em>Int</em> &#8211; <code class="docutils literal"><span class="pre">od</span> <span class="pre">=</span> <span class="pre">dp</span> <span class="pre">-</span> <span class="pre">ad.sum</span></code>.</p>
</li>
<li><p class="first"><strong>oneHotAlleles(v: Variant)</strong>: <em>Array[Int]</em></p>
<blockquote>
<div><p>Produce an array of called counts for each allele in the variant (including reference). For example, calling this function with a biallelic variant on hom-ref, het, and hom-var genotypes will produce <code class="docutils literal"><span class="pre">[2,</span> <span class="pre">0]</span></code>, <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">1]</span></code>, and <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">2]</span></code> respectively.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>v</strong> (<em>Variant</em>) &#8211; <a class="reference internal" href="#variant"><span class="std std-ref">Variant</span></a></li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>oneHotGenotype(v: Variant)</strong>: <em>Array[Int]</em></p>
<blockquote>
<div><p>Produces an array with one element for each possible genotype in the variant, where the called genotype is 1 and all else 0. For example, calling this function with a biallelic variant on hom-ref, het, and hom-var genotypes will produce <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>, <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">0]</span></code>, and <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">1]</span></code> respectively.</p>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>v</strong> (<em>Variant</em>) &#8211; <a class="reference internal" href="#variant"><span class="std std-ref">Variant</span></a></li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>pAB()</strong>: <em>Double</em> &#8211; p-value for pulling the given allelic depth from a binomial distribution with mean 0.5.  Missing if the call is not heterozygous.</p>
</li>
<li><p class="first"><strong>pl</strong>: <em>Array[Int]</em> &#8211; phred-scaled normalized genotype likelihood values. The conversion between <code class="docutils literal"><span class="pre">g.pl</span></code> (Phred-scaled likelihoods) and <code class="docutils literal"><span class="pre">g.dosage</span></code> (linear-scaled probabilities) assumes a uniform prior.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="int">
<span id="id28"></span><h2>Int<a class="headerlink" href="#int" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><strong>abs()</strong>: <em>Int</em> &#8211; Returns the absolute value of a number.</li>
<li><strong>max(a: Int)</strong>: <em>Int</em> &#8211;    Returns the maximum value.</li>
<li><strong>min(a: Int)</strong>: <em>Int</em> &#8211;    Returns the minimum value.</li>
<li><strong>signum()</strong>: <em>Int</em> &#8211; Returns the sign of a number (1, 0, or -1).</li>
<li><strong>toDouble()</strong>: <em>Double</em> &#8211; Convert value to a Double.</li>
<li><strong>toFloat()</strong>: <em>Float</em> &#8211; Convert value to a Float.</li>
<li><strong>toInt()</strong>: <em>Int</em> &#8211; Convert value to an Integer.</li>
<li><strong>toLong()</strong>: <em>Long</em> &#8211; Convert value to a Long.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="interval">
<span id="id29"></span><h2>Interval<a class="headerlink" href="#interval" title="Permalink to this headline">¶</a></h2>
<p>An <code class="docutils literal"><span class="pre">Interval</span></code> is a Hail data type representing a range of genomic locations in the Variant Dataset.</p>
<blockquote>
<div><ul>
<li><p class="first"><strong>contains(locus: Locus)</strong>: <em>Boolean</em></p>
<blockquote>
<div><p>Returns true if the <code class="docutils literal"><span class="pre">locus</span></code> is in the interval.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let i = Interval(Locus(&quot;1&quot;, 1000), Locus(&quot;1&quot;, 2000)) in i.contains(Locus(&quot;1&quot;, 1500))
<span class="hll">result: true
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>locus</strong> (<em>Locus</em>) &#8211; <a class="reference internal" href="#locus"><span class="std std-ref">Locus</span></a></li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>end</strong>: <em>Locus</em> &#8211; <a class="reference internal" href="#locus"><span class="std std-ref">Locus</span></a> at the end of the interval (exclusive).</p>
</li>
<li><p class="first"><strong>start</strong>: <em>Locus</em> &#8211; <a class="reference internal" href="#locus"><span class="std std-ref">Locus</span></a> at the start of the interval (inclusive).</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="locus">
<span id="id30"></span><h2>Locus<a class="headerlink" href="#locus" title="Permalink to this headline">¶</a></h2>
<p>A <code class="docutils literal"><span class="pre">Locus</span></code> is a Hail data type representing a specific genomic location in the Variant Dataset.</p>
<blockquote>
<div><ul class="simple">
<li><strong>contig</strong>: <em>String</em> &#8211; String representation of contig.</li>
<li><strong>position</strong>: <em>Int</em> &#8211; Chromosomal position.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="long">
<span id="id31"></span><h2>Long<a class="headerlink" href="#long" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><strong>abs()</strong>: <em>Long</em> &#8211; Returns the absolute value of a number.</li>
<li><strong>max(a: Long)</strong>: <em>Long</em> &#8211;  Returns the maximum value.</li>
<li><strong>min(a: Long)</strong>: <em>Long</em> &#8211;  Returns the minimum value.</li>
<li><strong>signum()</strong>: <em>Int</em> &#8211; Returns the sign of a number (1, 0, or -1).</li>
<li><strong>toDouble()</strong>: <em>Double</em> &#8211; Convert value to a Double.</li>
<li><strong>toFloat()</strong>: <em>Float</em> &#8211; Convert value to a Float.</li>
<li><strong>toInt()</strong>: <em>Int</em> &#8211; Convert value to an Integer.</li>
<li><strong>toLong()</strong>: <em>Long</em> &#8211; Convert value to a Long.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="set">
<span id="id32"></span><h2>Set<a class="headerlink" href="#set" title="Permalink to this headline">¶</a></h2>
<p>A <code class="docutils literal"><span class="pre">Set</span></code> is an unordered collection with no repeated values of a given data type (ex: Int, String). Sets can be constructed by specifying <code class="docutils literal"><span class="pre">[item1,</span> <span class="pre">item2,</span> <span class="pre">...].toSet()</span></code>.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let s = [&quot;rabbit&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;dog&quot;].toSet()
<span class="hll">result: Set(&quot;cat&quot;, &quot;dog&quot;, &quot;rabbit&quot;)
</span></pre></div>
</div>
<p>They can also be nested such as Set[Set[Int]]:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let s = [[1, 2, 3].toSet(), [4, 5, 5].toSet()].toSet()
<span class="hll">result: Set(Set(1, 2, 3), Set(4, 5))
</span></pre></div>
</div>
<div class="section" id="set-double">
<span id="id33"></span><h3>Set[Double]<a class="headerlink" href="#set-double" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><strong>max()</strong>: <em>Double</em> &#8211; Largest element in the collection.</li>
<li><strong>mean()</strong>: <em>Double</em> &#8211; Mean value of the collection.</li>
<li><strong>median()</strong>: <em>Double</em> &#8211; Median value of the collection.</li>
<li><strong>min()</strong>: <em>Double</em> &#8211; Smallest element in the collection.</li>
<li><strong>sum()</strong>: <em>Double</em> &#8211; Sum of all elements in the collection.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="set-float">
<span id="id34"></span><h3>Set[Float]<a class="headerlink" href="#set-float" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><strong>max()</strong>: <em>Float</em> &#8211; Largest element in the collection.</li>
<li><strong>mean()</strong>: <em>Double</em> &#8211; Mean value of the collection.</li>
<li><strong>median()</strong>: <em>Float</em> &#8211; Median value of the collection.</li>
<li><strong>min()</strong>: <em>Float</em> &#8211; Smallest element in the collection.</li>
<li><strong>sum()</strong>: <em>Float</em> &#8211; Sum of all elements in the collection.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="set-int">
<span id="id35"></span><h3>Set[Int]<a class="headerlink" href="#set-int" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><strong>max()</strong>: <em>Int</em> &#8211; Largest element in the collection.</li>
<li><strong>mean()</strong>: <em>Double</em> &#8211; Mean value of the collection.</li>
<li><strong>median()</strong>: <em>Int</em> &#8211; Median value of the collection.</li>
<li><strong>min()</strong>: <em>Int</em> &#8211; Smallest element in the collection.</li>
<li><strong>sum()</strong>: <em>Int</em> &#8211; Sum of all elements in the collection.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="set-long">
<span id="id36"></span><h3>Set[Long]<a class="headerlink" href="#set-long" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><strong>max()</strong>: <em>Long</em> &#8211; Largest element in the collection.</li>
<li><strong>mean()</strong>: <em>Double</em> &#8211; Mean value of the collection.</li>
<li><strong>median()</strong>: <em>Long</em> &#8211; Median value of the collection.</li>
<li><strong>min()</strong>: <em>Long</em> &#8211; Smallest element in the collection.</li>
<li><strong>sum()</strong>: <em>Long</em> &#8211; Sum of all elements in the collection.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="set-set-t">
<span id="id37"></span><h3>Set[Set[T]]<a class="headerlink" href="#set-set-t" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><p class="first"><strong>flatten()</strong>: <em>Set[T]</em></p>
<blockquote>
<div><p>Flattens a nested set by concatenating all its elements into a single set.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let s = [[1, 2].toSet(), [3, 4].toSet()].toSet() in s.flatten()
<span class="hll">result: Set(1, 2, 3, 4)
</span></pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="set-string">
<span id="id38"></span><h3>Set[String]<a class="headerlink" href="#set-string" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><p class="first"><strong>mkString(delimiter: String)</strong>: <em>String</em></p>
<blockquote>
<div><p>Concatenates all elements of this set into a single string where each element is separated by the <code class="docutils literal"><span class="pre">delimiter</span></code>.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let s = [1, 2, 3].toSet() in s.mkString(&quot;,&quot;)
<span class="hll">result: &quot;1,2,3&quot;
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>delimiter</strong> (<em>String</em>) &#8211; String that separates each element.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="set-t">
<span id="id39"></span><h3>Set[T]<a class="headerlink" href="#set-t" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><p class="first"><strong>add(a: T)</strong>: <em>Set[T]</em> &#8211;   Returns the result of adding the element <cite>a</cite> to this Set.</p>
</li>
<li><p class="first"><strong>contains(x: T)</strong>: <em>Boolean</em></p>
<blockquote>
<div><p>Returns true if the element <code class="docutils literal"><span class="pre">x</span></code> is contained in the set, otherwise false.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let s = [1, 2, 3].toSet() in s.contains(5)
<span class="hll">result: false
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>x</strong> (<em>T</em>) &#8211; Value to test.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>difference(a: Set[T])</strong>: <em>Set[T]</em> &#8211;       Returns the elements of this Set that are not in Set <cite>a</cite>.</p>
</li>
<li><p class="first"><strong>exists(expr: T =&gt; Boolean)</strong>: <em>Boolean</em></p>
<blockquote>
<div><p>Returns a boolean which is true if <strong>any</strong> element in the set satisfies the condition given by <code class="docutils literal"><span class="pre">expr</span></code> and false otherwise.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let s = [0, 2, 4, 6, 8, 10].toSet() in s.exists(e =&gt; e % 2 == 1)
<span class="hll">result: false
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>expr</strong> (<em>T =&gt; Boolean</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>filter(expr: T =&gt; Boolean)</strong>: <em>Set[T]</em></p>
<blockquote>
<div><p>Returns a new set subsetted to the elements where <code class="docutils literal"><span class="pre">expr</span></code> evaluates to true.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let s = [1, 4, 5, 6, 10].toSet() in s.filter(e =&gt; e &gt;= 5)
<span class="hll">result: Set(5, 6, 10)
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>expr</strong> (<em>T =&gt; Boolean</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>find(expr: T =&gt; Boolean)</strong>: <em>T</em></p>
<blockquote>
<div><p>Returns the first non-missing element of the array for which expr is true. If no element satisfies the predicate, find returns NA.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let s = [1, 2, 3].toSet() in s.find(e =&gt; e % 3 == 0)
<span class="hll">result: 3
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>expr</strong> (<em>T =&gt; Boolean</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>flatMap(expr: T =&gt; Set[U])</strong>: <em>Set[U]</em></p>
<blockquote>
<div><p>Returns a new set by applying a function to each subset and concatenating the resulting sets.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let s = [[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].toSet(), [&quot;d&quot;, &quot;e&quot;].toSet(), [&quot;f&quot;].toSet()].toSet() in s.flatMap(e =&gt; e + &quot;1&quot;)
<span class="hll">result: Set(&quot;a1&quot;, &quot;b1&quot;, &quot;c1&quot;, &quot;d1&quot;, &quot;e1&quot;, &quot;f1&quot;)
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>expr</strong> (<em>T =&gt; Set[U]</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>forall(expr: T =&gt; Boolean)</strong>: <em>Boolean</em></p>
<blockquote>
<div><p>Returns a boolean which is true if <strong>all</strong> elements in the set satisfies the condition given by <code class="docutils literal"><span class="pre">expr</span></code> and false otherwise.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let s = [0.1, 0.5, 0.3, 1.0, 2.5, 3.0].toSet() in s.forall(e =&gt; e &gt; 1.0 == 0)
<span class="hll">result: false
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>expr</strong> (<em>T =&gt; Boolean</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>groupBy(a: T =&gt; U)</strong>: <em>Dict[U, Set[T]]</em></p>
</li>
<li><p class="first"><strong>head()</strong>: <em>T</em> &#8211; Select one element.</p>
</li>
<li><p class="first"><strong>intersection(a: Set[T])</strong>: <em>Set[T]</em> &#8211;     Returns the intersection of this Set and Set <cite>a</cite>.</p>
</li>
<li><p class="first"><strong>isEmpty()</strong>: <em>Boolean</em> &#8211; Returns true if the number of elements is equal to 0. false otherwise.</p>
</li>
<li><p class="first"><strong>issubset(a: Set[T])</strong>: <em>Boolean</em> &#8211;        Returns true if this Set is a subset of Set <cite>a</cite>.</p>
</li>
<li><p class="first"><strong>map(expr: T =&gt; U)</strong>: <em>Set[U]</em></p>
<blockquote>
<div><p>Returns a new set produced by applying <code class="docutils literal"><span class="pre">expr</span></code> to each element.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let s = [1, 2, 3].toSet() in s.map(e =&gt; e * 3)
<span class="hll">result: Set(3, 6, 9)
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>expr</strong> (<em>T =&gt; U</em>) &#8211; Lambda expression.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>size()</strong>: <em>Int</em> &#8211; Number of elements in the collection.</p>
</li>
<li><p class="first"><strong>tail()</strong>: <em>Set[T]</em> &#8211; Select all elements except the element returned by <code class="docutils literal"><span class="pre">head</span></code>.</p>
</li>
<li><p class="first"><strong>toArray()</strong>: <em>Array[T]</em> &#8211; Convert collection to an Array.</p>
</li>
<li><p class="first"><strong>toSet()</strong>: <em>Set[T]</em> &#8211; Convert collection to a Set.</p>
</li>
<li><p class="first"><strong>union(a: Set[T])</strong>: <em>Set[T]</em> &#8211;    Returns the union of this Set and Set <cite>a</cite>.</p>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="string">
<span id="id40"></span><h2>String<a class="headerlink" href="#string" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul>
<li><p class="first"><strong>[i]</strong>: <em>Char</em></p>
<blockquote>
<div><blockquote>
<div><p>Returns the i*th* element (0-indexed) of the string, or throws an exception if <code class="docutils literal"><span class="pre">i</span></code> is an invalid index.</p>
</div></blockquote>
<div class="line-block">
<div class="line">.. code-block:: text
    :emphasize-lines: 2</div>
</div>
<blockquote>
<div><p>let s = &#8220;genetics&#8221; in s[6]
result: &#8220;c&#8221;</p>
</div></blockquote>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>i</strong> (<em>Int</em>) &#8211; Index of the character to return.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>length()</strong>: <em>Int</em> &#8211; Length of the string.</p>
</li>
<li><p class="first"><strong>max(a: String)</strong>: <em>String</em> &#8211;      Returns the maximum value.</p>
</li>
<li><p class="first"><strong>min(a: String)</strong>: <em>String</em> &#8211;      Returns the minimum value.</p>
</li>
<li><p class="first"><strong>replace(pattern1: String, pattern2: String)</strong>: <em>String</em></p>
<blockquote>
<div><p>Replaces each substring of this string that matches the given <a class="reference external" href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">regular expression</a> (<code class="docutils literal"><span class="pre">pattern1</span></code>) with the given replacement (<code class="docutils literal"><span class="pre">pattern2</span></code>).</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let s = &quot;1kg-NA12878&quot; in a.replace(&quot;1kg-&quot;, &quot;&quot;)
<span class="hll">result: &quot;NA12878&quot;
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>pattern1</strong> (<em>String</em>) &#8211; Substring to replace.</li>
<li><strong>pattern2</strong> (<em>String</em>) &#8211; Replacement string.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>split(delim: String, n: Int)</strong>: <em>Array[String]</em></p>
<blockquote>
<div><p>Returns an array of strings, split on the given regular expression delimiter with the pattern applied <code class="docutils literal"><span class="pre">n</span></code> times. See the documentation on <a class="reference external" href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">regular expression syntax</a> delimiter. If you need to split on special characters, escape them with double backslash (\\).</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let s = &quot;1kg-NA12878&quot; in s.split(&quot;-&quot;)
<span class="hll">result: [&quot;1kg&quot;, &quot;NA12878&quot;]
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>delim</strong> (<em>String</em>) &#8211; Regular expression delimiter.</li>
<li><strong>n</strong> (<em>Int</em>) &#8211; Number of times the pattern is applied. See the <a class="reference external" href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-int-">Java documentation</a> for more information.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>split(delim: String)</strong>: <em>Array[String]</em></p>
<blockquote>
<div><p>Returns an array of strings, split on the given regular expression delimiter. See the documentation on <a class="reference external" href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">regular expression syntax</a> delimiter. If you need to split on special characters, escape them with double backslash (\\).</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let s = &quot;1kg-NA12878&quot; in s.split(&quot;-&quot;)
<span class="hll">result: [&quot;1kg&quot;, &quot;NA12878&quot;]
</span></pre></div>
</div>
<p><strong>Arguments</strong></p>
<blockquote>
<div><ul class="simple">
<li><strong>delim</strong> (<em>String</em>) &#8211; Regular expression delimiter.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><strong>toDouble()</strong>: <em>Double</em> &#8211; Convert value to a Double.</p>
</li>
<li><p class="first"><strong>toFloat()</strong>: <em>Float</em> &#8211; Convert value to a Float.</p>
</li>
<li><p class="first"><strong>toInt()</strong>: <em>Int</em> &#8211; Convert value to an Integer.</p>
</li>
<li><p class="first"><strong>toLong()</strong>: <em>Long</em> &#8211; Convert value to a Long.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="struct">
<span id="id42"></span><h2>Struct<a class="headerlink" href="#struct" title="Permalink to this headline">¶</a></h2>
<p>A <code class="docutils literal"><span class="pre">Struct</span></code> is like a Python tuple where the fields are named and the set of fields is fixed.</p>
<p>An example of constructing and accessing the fields in a <code class="docutils literal"><span class="pre">Struct</span></code> is</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>let s = {gene: &quot;ACBD&quot;, function: &quot;LOF&quot;, nHet: 12} in s.gene
<span class="hll">result: &quot;ACBD&quot;
</span></pre></div>
</div>
<p>A field of the <code class="docutils literal"><span class="pre">Struct</span></code> can also be another <code class="docutils literal"><span class="pre">Struct</span></code>. For example, <code class="docutils literal"><span class="pre">va.info.AC</span></code> selects the struct <code class="docutils literal"><span class="pre">info</span></code> from the struct <code class="docutils literal"><span class="pre">va</span></code>, and then selects the array <code class="docutils literal"><span class="pre">AC</span></code> from the struct <code class="docutils literal"><span class="pre">info</span></code>.</p>
</div>
<div class="section" id="variant">
<span id="id43"></span><h2>Variant<a class="headerlink" href="#variant" title="Permalink to this headline">¶</a></h2>
<p>A <code class="docutils literal"><span class="pre">Variant</span></code> is a Hail data type representing a variant in the Variant Dataset. It is referred to as <code class="docutils literal"><span class="pre">v</span></code> in the expression language.</p>
<p>The <a class="reference external" href="https://en.wikipedia.org/wiki/Pseudoautosomal_region">pseudoautosomal region</a> (PAR) is currently defined with respect to reference <a class="reference external" href="http://www.ncbi.nlm.nih.gov/projects/genome/assembly/grc/human/">GRCh37</a>:</p>
<ul class="simple">
<li>X: 60001 - 2699520, 154931044 - 155260560</li>
<li>Y: 10001 - 2649520, 59034050 - 59363566</li>
</ul>
<p>Most callers assign variants in PAR to X.</p>
<blockquote>
<div><ul class="simple">
<li><strong>alt()</strong>: <em>String</em> &#8211; Alternate allele sequence.  <strong>Assumes biallelic.</strong></li>
<li><strong>altAllele()</strong>: <em>AltAllele</em> &#8211; The <a class="reference internal" href="#altallele"><span class="std std-ref">alternate allele</span></a>.  <strong>Assumes biallelic.</strong></li>
<li><strong>altAlleles</strong>: <em>Array[AltAllele]</em> &#8211; The <a class="reference internal" href="#altallele"><span class="std std-ref">alternate alleles</span></a>.</li>
<li><strong>contig</strong>: <em>String</em> &#8211; String representation of contig, exactly as imported. <em>NB: Hail stores contigs as strings. Use double-quotes when checking contig equality.</em></li>
<li><strong>inXNonPar()</strong>: <em>Boolean</em> &#8211; True if chromosome is X and start is not in pseudoautosomal region of X.</li>
<li><strong>inXPar()</strong>: <em>Boolean</em> &#8211; True if chromosome is X and start is in pseudoautosomal region of X.</li>
<li><strong>inYNonPar()</strong>: <em>Boolean</em> &#8211; True if chromosome is Y and start is not in pseudoautosomal region of Y.</li>
<li><strong>inYPar()</strong>: <em>Boolean</em> &#8211; True if chromosome is Y and start is in pseudoautosomal region of Y. <em>NB: most callers assign variants in PAR to X.</em></li>
<li><strong>isAutosomal()</strong>: <em>Boolean</em> &#8211; True if chromosome is not X, not Y, and not MT.</li>
<li><strong>isBiallelic()</strong>: <em>Boolean</em> &#8211; True if <cite>v</cite> has one alternate allele.</li>
<li><strong>locus()</strong>: <em>Locus</em> &#8211; Chromosomal locus (chr, pos) of this variant</li>
<li><strong>nAlleles()</strong>: <em>Int</em> &#8211; Number of alleles.</li>
<li><strong>nAltAlleles()</strong>: <em>Int</em> &#8211; Number of alternate alleles, equal to <code class="docutils literal"><span class="pre">nAlleles</span> <span class="pre">-</span> <span class="pre">1</span></code>.</li>
<li><strong>nGenotypes()</strong>: <em>Int</em> &#8211; Number of genotypes.</li>
<li><strong>ref</strong>: <em>String</em> &#8211; Reference allele sequence.</li>
<li><strong>start</strong>: <em>Int</em> &#8211; SNP position or start of an indel.</li>
</ul>
</div></blockquote>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="functions.html" class="btn btn-neutral float-right" title="Functions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="operators.html" class="btn btn-neutral" title="Operators" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Hail Team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'devel',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script type="text/javascript" src="../bootstrap.min.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
  
   

</body>
</html>