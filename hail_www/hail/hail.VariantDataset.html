

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>VariantDataset &mdash; Hail</title>
  

  
  
    <link rel="shortcut icon" href="hail_logo_sq.png"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="navbar.css" type="text/css" />
  
    <link rel="stylesheet" href="_static/rtd_modifications.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="Hail" href="index.html"/>
        <link rel="up" title="Python API" href="api.html"/>
        <link rel="next" title="KeyTable" href="hail.KeyTable.html"/>
        <link rel="prev" title="HailContext" href="hail.HailContext.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>
  
  

</head>

<body class="wy-body-for-nav" role="document">

  <nav class="navbar navbar-default navbar-static-top" id="hail-navbar">
<div class="container-fluid" id="hail-container-fluid">
    <div class="navbar-header" id="hail-navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#hail-navbar-collapse" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
   
      <a class="navbar-left" id="hail-navbar-brand" href="../index.html"><img alt="Hail" id="logo" src="hail-logo-cropped.png"></a>

    </div>

    <div class="collapse navbar-collapse" id="hail-navbar-collapse">
      <ul class="nav navbar-nav navbar-right">
          <li id="home" class="nav-item"><a href="../index.html">HOME</a></li>
          <li id="docs" class="nav-item"><a href="index.html">DOCS</a></li>
          <li id="forum" class="nav-item"><a href="http://discuss.hail.is">FORUM</a></li>
          <li id="chat" class="nav-item dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">CHAT<span class="caret"></span></a>
          <ul class="dropdown-menu dropdown-menu-left">
            <li><a class="dropdown-item" href="https://gitter.im/hail-is/hail">General</a></li>
            <li><a class="dropdown-item" href="https://gitter.im/hail-is/hail-dev">Developers</a></li>
          </ul>
        </li>
       <li id="code" class="nav-item"><a href="https://github.com/hail-is/hail">CODE</a></li>
      </ul>
    </div>
  </div>
</nav>

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Hail
          

          
          </a>

          
            
            
              <div class="version">
                devel
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="exprlang.html">Expression Language</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="api.html">Python API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="hail.HailContext.html">HailContext</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">VariantDataset</a></li>
<li class="toctree-l2"><a class="reference internal" href="hail.KeyTable.html">KeyTable</a></li>
<li class="toctree-l2"><a class="reference internal" href="hail.TextTableConfig.html">TextTableConfig</a></li>
<li class="toctree-l2"><a class="reference internal" href="hail.KinshipMatrix.html">KinshipMatrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="representation/index.html">representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="expr/index.html">expr</a></li>
<li class="toctree-l2"><a class="reference internal" href="utils/index.html">utils</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="annotationdb.html">Annotation Database</a></li>
<li class="toctree-l1"><a class="reference internal" href="other_resources.html">Other Resources</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Hail</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="api.html">Python API</a> &raquo;</li>
        
      <li>VariantDataset</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/hail.VariantDataset.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

/* nice headers on first paragraph of info/warning boxes */
.admonition .first {
    margin: -12px;
    padding: 6px 12px;
    margin-bottom: 12px;
    color: #fff;
    line-height: 1;
    display: block;
}
.admonition.warning .first {
    background: #f0b37e;
}
.admonition.note .first {
    background: #6ab0de;
}
.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}
</style>
<div class="section" id="variantdataset">
<h1>VariantDataset<a class="headerlink" href="#variantdataset" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="hail.VariantDataset">
<em class="property">class </em><code class="descclassname">hail.</code><code class="descname">VariantDataset</code><span class="sig-paren">(</span><em>hc</em>, <em>jvds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Hail&#8217;s primary representation of genomic data, a matrix keyed by sample and variant.</p>
<p>Variant datasets may be generated from other formats using the <a class="reference internal" href="hail.HailContext.html#hail.HailContext" title="hail.HailContext"><code class="xref py py-class docutils literal"><span class="pre">HailContext</span></code></a> import methods,
constructed from a variant-keyed <a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a> using <a class="reference internal" href="#hail.VariantDataset.from_keytable" title="hail.VariantDataset.from_keytable"><code class="xref py py-meth docutils literal"><span class="pre">VariantDataset.from_keytable()</span></code></a>,
and simulated using <a class="reference internal" href="hail.HailContext.html#hail.HailContext.balding_nichols_model" title="hail.HailContext.balding_nichols_model"><code class="xref py py-meth docutils literal"><span class="pre">balding_nichols_model()</span></code></a>.</p>
<p>Once a variant dataset has been written to disk with <a class="reference internal" href="#hail.VariantDataset.write" title="hail.VariantDataset.write"><code class="xref py py-meth docutils literal"><span class="pre">write()</span></code></a>,
use <a class="reference internal" href="hail.HailContext.html#hail.HailContext.read" title="hail.HailContext.read"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code></a> to load the variant dataset into the environment.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span> <span class="o">=</span> <span class="n">hc</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;data/example.vds&quot;</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>hc</strong> (<a class="reference internal" href="hail.HailContext.html#hail.HailContext" title="hail.HailContext"><code class="xref py py-class docutils literal"><span class="pre">HailContext</span></code></a>) &#8211; Hail Context</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-obj docutils literal"><span class="pre">genotype_schema</span></code></a></td>
<td>Returns the signature of the genotypes contained in this VDS.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.global_schema" title="hail.VariantDataset.global_schema"><code class="xref py py-obj docutils literal"><span class="pre">global_schema</span></code></a></td>
<td>Returns the signature of the global annotations contained in this VDS.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.globals" title="hail.VariantDataset.globals"><code class="xref py py-obj docutils literal"><span class="pre">globals</span></code></a></td>
<td>Return global annotations as a Python object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.num_samples" title="hail.VariantDataset.num_samples"><code class="xref py py-obj docutils literal"><span class="pre">num_samples</span></code></a></td>
<td>Number of samples.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.sample_annotations" title="hail.VariantDataset.sample_annotations"><code class="xref py py-obj docutils literal"><span class="pre">sample_annotations</span></code></a></td>
<td>Return a dict of sample annotations.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.sample_ids" title="hail.VariantDataset.sample_ids"><code class="xref py py-obj docutils literal"><span class="pre">sample_ids</span></code></a></td>
<td>Return sampleIDs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.sample_schema" title="hail.VariantDataset.sample_schema"><code class="xref py py-obj docutils literal"><span class="pre">sample_schema</span></code></a></td>
<td>Returns the signature of the sample annotations contained in this VDS.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.variant_schema" title="hail.VariantDataset.variant_schema"><code class="xref py py-obj docutils literal"><span class="pre">variant_schema</span></code></a></td>
<td>Returns the signature of the variant annotations contained in this VDS.</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">__init__</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.aggregate_by_key" title="hail.VariantDataset.aggregate_by_key"><code class="xref py py-obj docutils literal"><span class="pre">aggregate_by_key</span></code></a></td>
<td>Aggregate by user-defined key and aggregation expressions to produce a KeyTable.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.aggregate_intervals" title="hail.VariantDataset.aggregate_intervals"><code class="xref py py-obj docutils literal"><span class="pre">aggregate_intervals</span></code></a></td>
<td>Aggregate over intervals and export.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.annotate_alleles_expr" title="hail.VariantDataset.annotate_alleles_expr"><code class="xref py py-obj docutils literal"><span class="pre">annotate_alleles_expr</span></code></a></td>
<td>Annotate alleles with expression.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.annotate_genotypes_expr" title="hail.VariantDataset.annotate_genotypes_expr"><code class="xref py py-obj docutils literal"><span class="pre">annotate_genotypes_expr</span></code></a></td>
<td>Annotate genotypes with expression.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.annotate_global_expr" title="hail.VariantDataset.annotate_global_expr"><code class="xref py py-obj docutils literal"><span class="pre">annotate_global_expr</span></code></a></td>
<td>Annotate global with expression.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.annotate_global_list" title="hail.VariantDataset.annotate_global_list"><code class="xref py py-obj docutils literal"><span class="pre">annotate_global_list</span></code></a></td>
<td>Load text file into global annotations as Array[String] or Set[String].</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.annotate_global_py" title="hail.VariantDataset.annotate_global_py"><code class="xref py py-obj docutils literal"><span class="pre">annotate_global_py</span></code></a></td>
<td>Annotate global from Python objects.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.annotate_global_table" title="hail.VariantDataset.annotate_global_table"><code class="xref py py-obj docutils literal"><span class="pre">annotate_global_table</span></code></a></td>
<td>Load delimited text file (text table) into global annotations as Array[Struct].</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.annotate_samples_expr" title="hail.VariantDataset.annotate_samples_expr"><code class="xref py py-obj docutils literal"><span class="pre">annotate_samples_expr</span></code></a></td>
<td>Annotate samples with expression.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.annotate_samples_fam" title="hail.VariantDataset.annotate_samples_fam"><code class="xref py py-obj docutils literal"><span class="pre">annotate_samples_fam</span></code></a></td>
<td>Import PLINK .fam file into sample annotations.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.annotate_samples_keytable" title="hail.VariantDataset.annotate_samples_keytable"><code class="xref py py-obj docutils literal"><span class="pre">annotate_samples_keytable</span></code></a></td>
<td>Annotate samples with a <a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.annotate_samples_list" title="hail.VariantDataset.annotate_samples_list"><code class="xref py py-obj docutils literal"><span class="pre">annotate_samples_list</span></code></a></td>
<td>Annotate samples with a Boolean indicating presence in a list of samples in a text file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.annotate_samples_table" title="hail.VariantDataset.annotate_samples_table"><code class="xref py py-obj docutils literal"><span class="pre">annotate_samples_table</span></code></a></td>
<td>Annotate samples with delimited text file (text table).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.annotate_samples_vds" title="hail.VariantDataset.annotate_samples_vds"><code class="xref py py-obj docutils literal"><span class="pre">annotate_samples_vds</span></code></a></td>
<td>Annotate samples with sample annotations from .vds file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.annotate_variants_bed" title="hail.VariantDataset.annotate_variants_bed"><code class="xref py py-obj docutils literal"><span class="pre">annotate_variants_bed</span></code></a></td>
<td>Annotate variants based on the intervals in a .bed file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.annotate_variants_expr" title="hail.VariantDataset.annotate_variants_expr"><code class="xref py py-obj docutils literal"><span class="pre">annotate_variants_expr</span></code></a></td>
<td>Annotate variants with expression.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.annotate_variants_intervals" title="hail.VariantDataset.annotate_variants_intervals"><code class="xref py py-obj docutils literal"><span class="pre">annotate_variants_intervals</span></code></a></td>
<td>Annotate variants from an interval list file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.annotate_variants_keytable" title="hail.VariantDataset.annotate_variants_keytable"><code class="xref py py-obj docutils literal"><span class="pre">annotate_variants_keytable</span></code></a></td>
<td>Annotate variants with an expression that may depend on a <a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.annotate_variants_loci" title="hail.VariantDataset.annotate_variants_loci"><code class="xref py py-obj docutils literal"><span class="pre">annotate_variants_loci</span></code></a></td>
<td>Annotate variants from an delimited text file (text table) indexed by loci.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.annotate_variants_table" title="hail.VariantDataset.annotate_variants_table"><code class="xref py py-obj docutils literal"><span class="pre">annotate_variants_table</span></code></a></td>
<td>Annotate variant with delimited text file (text table).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.annotate_variants_vds" title="hail.VariantDataset.annotate_variants_vds"><code class="xref py py-obj docutils literal"><span class="pre">annotate_variants_vds</span></code></a></td>
<td>Annotate variants with variant annotations from .vds file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.cache" title="hail.VariantDataset.cache"><code class="xref py py-obj docutils literal"><span class="pre">cache</span></code></a></td>
<td>Mark this variant dataset to be cached in memory.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.concordance" title="hail.VariantDataset.concordance"><code class="xref py py-obj docutils literal"><span class="pre">concordance</span></code></a></td>
<td>Calculate call concordance with another variant dataset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.count" title="hail.VariantDataset.count"><code class="xref py py-obj docutils literal"><span class="pre">count</span></code></a></td>
<td>Returns number of samples and variants in the dataset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.count_variants" title="hail.VariantDataset.count_variants"><code class="xref py py-obj docutils literal"><span class="pre">count_variants</span></code></a></td>
<td>Count number of variants in variant dataset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.deduplicate" title="hail.VariantDataset.deduplicate"><code class="xref py py-obj docutils literal"><span class="pre">deduplicate</span></code></a></td>
<td>Remove duplicate variants.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.delete_va_attribute" title="hail.VariantDataset.delete_va_attribute"><code class="xref py py-obj docutils literal"><span class="pre">delete_va_attribute</span></code></a></td>
<td>Removes an attribute from a variant annotation field.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.drop_samples" title="hail.VariantDataset.drop_samples"><code class="xref py py-obj docutils literal"><span class="pre">drop_samples</span></code></a></td>
<td>Removes all samples from variant dataset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.drop_variants" title="hail.VariantDataset.drop_variants"><code class="xref py py-obj docutils literal"><span class="pre">drop_variants</span></code></a></td>
<td>Discard all variants, variant annotations and genotypes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.export_gen" title="hail.VariantDataset.export_gen"><code class="xref py py-obj docutils literal"><span class="pre">export_gen</span></code></a></td>
<td>Export variant dataset as GEN and SAMPLE file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.export_genotypes" title="hail.VariantDataset.export_genotypes"><code class="xref py py-obj docutils literal"><span class="pre">export_genotypes</span></code></a></td>
<td>Export genotype-level information to delimited text file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.export_plink" title="hail.VariantDataset.export_plink"><code class="xref py py-obj docutils literal"><span class="pre">export_plink</span></code></a></td>
<td>Export variant dataset as <a class="reference external" href="https://www.cog-genomics.org/plink2/formats">PLINK2</a> BED, BIM and FAM.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.export_samples" title="hail.VariantDataset.export_samples"><code class="xref py py-obj docutils literal"><span class="pre">export_samples</span></code></a></td>
<td>Export sample information to delimited text file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.export_variants" title="hail.VariantDataset.export_variants"><code class="xref py py-obj docutils literal"><span class="pre">export_variants</span></code></a></td>
<td>Export variant information to delimited text file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.export_vcf" title="hail.VariantDataset.export_vcf"><code class="xref py py-obj docutils literal"><span class="pre">export_vcf</span></code></a></td>
<td>Export variant dataset as a .vcf or .vcf.bgz file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.file_version" title="hail.VariantDataset.file_version"><code class="xref py py-obj docutils literal"><span class="pre">file_version</span></code></a></td>
<td>File version of variant dataset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.filter_alleles" title="hail.VariantDataset.filter_alleles"><code class="xref py py-obj docutils literal"><span class="pre">filter_alleles</span></code></a></td>
<td>Filter a user-defined set of alternate alleles for each variant.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.filter_genotypes" title="hail.VariantDataset.filter_genotypes"><code class="xref py py-obj docutils literal"><span class="pre">filter_genotypes</span></code></a></td>
<td>Filter genotypes based on expression.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.filter_multi" title="hail.VariantDataset.filter_multi"><code class="xref py py-obj docutils literal"><span class="pre">filter_multi</span></code></a></td>
<td>Filter out multi-allelic sites.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.filter_samples_expr" title="hail.VariantDataset.filter_samples_expr"><code class="xref py py-obj docutils literal"><span class="pre">filter_samples_expr</span></code></a></td>
<td>Filter samples based on expression.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.filter_samples_list" title="hail.VariantDataset.filter_samples_list"><code class="xref py py-obj docutils literal"><span class="pre">filter_samples_list</span></code></a></td>
<td>Filter samples with a list of samples.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.filter_variants_expr" title="hail.VariantDataset.filter_variants_expr"><code class="xref py py-obj docutils literal"><span class="pre">filter_variants_expr</span></code></a></td>
<td>Filter variants based on expression.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.filter_variants_intervals" title="hail.VariantDataset.filter_variants_intervals"><code class="xref py py-obj docutils literal"><span class="pre">filter_variants_intervals</span></code></a></td>
<td>Filter variants with an interval or interval tree.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.filter_variants_kt" title="hail.VariantDataset.filter_variants_kt"><code class="xref py py-obj docutils literal"><span class="pre">filter_variants_kt</span></code></a></td>
<td>Filter variants with a Variant keyed key table.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.filter_variants_list" title="hail.VariantDataset.filter_variants_list"><code class="xref py py-obj docutils literal"><span class="pre">filter_variants_list</span></code></a></td>
<td>Filter variants with a list of variants.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.from_keytable" title="hail.VariantDataset.from_keytable"><code class="xref py py-obj docutils literal"><span class="pre">from_keytable</span></code></a></td>
<td>Construct a sites-only variant dataset from a key table.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.grm" title="hail.VariantDataset.grm"><code class="xref py py-obj docutils literal"><span class="pre">grm</span></code></a></td>
<td>Compute the Genetic Relatedness Matrix (GRM).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.hardcalls" title="hail.VariantDataset.hardcalls"><code class="xref py py-obj docutils literal"><span class="pre">hardcalls</span></code></a></td>
<td>Drop all genotype fields except the GT field.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.ibd" title="hail.VariantDataset.ibd"><code class="xref py py-obj docutils literal"><span class="pre">ibd</span></code></a></td>
<td>Compute matrix of identity-by-descent estimations.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.ibd_prune" title="hail.VariantDataset.ibd_prune"><code class="xref py py-obj docutils literal"><span class="pre">ibd_prune</span></code></a></td>
<td>Prune samples from the <a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a> based on <a class="reference internal" href="#hail.VariantDataset.ibd" title="hail.VariantDataset.ibd"><code class="xref py py-meth docutils literal"><span class="pre">ibd()</span></code></a> PI_HAT measures of relatedness.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.impute_sex" title="hail.VariantDataset.impute_sex"><code class="xref py py-obj docutils literal"><span class="pre">impute_sex</span></code></a></td>
<td>Impute sex of samples by calculating inbreeding coefficient on the X chromosome.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.is_dosage" title="hail.VariantDataset.is_dosage"><code class="xref py py-obj docutils literal"><span class="pre">is_dosage</span></code></a></td>
<td>True if genotype probabilities are dosages.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.join" title="hail.VariantDataset.join"><code class="xref py py-obj docutils literal"><span class="pre">join</span></code></a></td>
<td>Join two variant datasets.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.ld_prune" title="hail.VariantDataset.ld_prune"><code class="xref py py-obj docutils literal"><span class="pre">ld_prune</span></code></a></td>
<td>Prune variants in linkage disequilibrium (LD).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.linreg" title="hail.VariantDataset.linreg"><code class="xref py py-obj docutils literal"><span class="pre">linreg</span></code></a></td>
<td>Test each variant for association using linear regression.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.linreg_multi_pheno" title="hail.VariantDataset.linreg_multi_pheno"><code class="xref py py-obj docutils literal"><span class="pre">linreg_multi_pheno</span></code></a></td>
<td>Test each variant for association with multiple phenotypes using linear regression.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.lmmreg" title="hail.VariantDataset.lmmreg"><code class="xref py py-obj docutils literal"><span class="pre">lmmreg</span></code></a></td>
<td>Use a kinship-based linear mixed model to estimate the genetic component of phenotypic variance (narrow-sense heritability) and optionally test each variant for association.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.logreg" title="hail.VariantDataset.logreg"><code class="xref py py-obj docutils literal"><span class="pre">logreg</span></code></a></td>
<td>Test each variant for association using logistic regression.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.make_keytable" title="hail.VariantDataset.make_keytable"><code class="xref py py-obj docutils literal"><span class="pre">make_keytable</span></code></a></td>
<td>Make a KeyTable with one row per variant.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.mendel_errors" title="hail.VariantDataset.mendel_errors"><code class="xref py py-obj docutils literal"><span class="pre">mendel_errors</span></code></a></td>
<td>Find Mendel errors; count per variant, individual and nuclear family.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.min_rep" title="hail.VariantDataset.min_rep"><code class="xref py py-obj docutils literal"><span class="pre">min_rep</span></code></a></td>
<td>Gives minimal, left-aligned representation of alleles.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.num_partitions" title="hail.VariantDataset.num_partitions"><code class="xref py py-obj docutils literal"><span class="pre">num_partitions</span></code></a></td>
<td>Number of partitions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.pca" title="hail.VariantDataset.pca"><code class="xref py py-obj docutils literal"><span class="pre">pca</span></code></a></td>
<td>Run Principal Component Analysis (PCA) on the matrix of genotypes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.persist" title="hail.VariantDataset.persist"><code class="xref py py-obj docutils literal"><span class="pre">persist</span></code></a></td>
<td>Persist this variant dataset to memory and/or disk.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.query_genotypes" title="hail.VariantDataset.query_genotypes"><code class="xref py py-obj docutils literal"><span class="pre">query_genotypes</span></code></a></td>
<td>Performs aggregation queries over genotypes, and returns Python object(s).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.query_genotypes_typed" title="hail.VariantDataset.query_genotypes_typed"><code class="xref py py-obj docutils literal"><span class="pre">query_genotypes_typed</span></code></a></td>
<td>Performs aggregation queries over genotypes, and returns Python object(s) and type(s).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.query_samples" title="hail.VariantDataset.query_samples"><code class="xref py py-obj docutils literal"><span class="pre">query_samples</span></code></a></td>
<td>Performs aggregation queries over samples and sample annotations, and returns Python object(s).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.query_samples_typed" title="hail.VariantDataset.query_samples_typed"><code class="xref py py-obj docutils literal"><span class="pre">query_samples_typed</span></code></a></td>
<td>Performs aggregation queries over samples and sample annotations, and returns Python object(s) and type(s).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.query_variants" title="hail.VariantDataset.query_variants"><code class="xref py py-obj docutils literal"><span class="pre">query_variants</span></code></a></td>
<td>Performs aggregation queries over variants and variant annotations, and returns Python object(s).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.query_variants_typed" title="hail.VariantDataset.query_variants_typed"><code class="xref py py-obj docutils literal"><span class="pre">query_variants_typed</span></code></a></td>
<td>Performs aggregation queries over variants and variant annotations, and returns Python object(s) and type(s).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.rename_samples" title="hail.VariantDataset.rename_samples"><code class="xref py py-obj docutils literal"><span class="pre">rename_samples</span></code></a></td>
<td>Rename samples.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.repartition" title="hail.VariantDataset.repartition"><code class="xref py py-obj docutils literal"><span class="pre">repartition</span></code></a></td>
<td>Increase or decrease the number of variant dataset partitions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.rrm" title="hail.VariantDataset.rrm"><code class="xref py py-obj docutils literal"><span class="pre">rrm</span></code></a></td>
<td>Computes the Realized Relationship Matrix (RRM).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.same" title="hail.VariantDataset.same"><code class="xref py py-obj docutils literal"><span class="pre">same</span></code></a></td>
<td>True if the two variant datasets have the same variants, samples, genotypes, and annotation schemata and values.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.sample_qc" title="hail.VariantDataset.sample_qc"><code class="xref py py-obj docutils literal"><span class="pre">sample_qc</span></code></a></td>
<td>Compute per-sample QC metrics.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.sample_variants" title="hail.VariantDataset.sample_variants"><code class="xref py py-obj docutils literal"><span class="pre">sample_variants</span></code></a></td>
<td>Downsample variants to a given fraction of the dataset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.samples_keytable" title="hail.VariantDataset.samples_keytable"><code class="xref py py-obj docutils literal"><span class="pre">samples_keytable</span></code></a></td>
<td>Convert samples and sample annotations to KeyTable.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.set_va_attributes" title="hail.VariantDataset.set_va_attributes"><code class="xref py py-obj docutils literal"><span class="pre">set_va_attributes</span></code></a></td>
<td>Sets attributes for a variant annotation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.split_multi" title="hail.VariantDataset.split_multi"><code class="xref py py-obj docutils literal"><span class="pre">split_multi</span></code></a></td>
<td>Split multiallelic variants.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.storage_level" title="hail.VariantDataset.storage_level"><code class="xref py py-obj docutils literal"><span class="pre">storage_level</span></code></a></td>
<td>Returns the storage (persistence) level of the variant dataset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.summarize" title="hail.VariantDataset.summarize"><code class="xref py py-obj docutils literal"><span class="pre">summarize</span></code></a></td>
<td>Returns a summary of useful information about the dataset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.tdt" title="hail.VariantDataset.tdt"><code class="xref py py-obj docutils literal"><span class="pre">tdt</span></code></a></td>
<td>Find transmitted and untransmitted variants; count per variant and nuclear family.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.variant_qc" title="hail.VariantDataset.variant_qc"><code class="xref py py-obj docutils literal"><span class="pre">variant_qc</span></code></a></td>
<td>Compute common variant statistics (quality control metrics).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.variants_keytable" title="hail.VariantDataset.variants_keytable"><code class="xref py py-obj docutils literal"><span class="pre">variants_keytable</span></code></a></td>
<td>Convert variants and variant annotations to a KeyTable.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.vep" title="hail.VariantDataset.vep"><code class="xref py py-obj docutils literal"><span class="pre">vep</span></code></a></td>
<td>Annotate variants with VEP.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hail.VariantDataset.was_split" title="hail.VariantDataset.was_split"><code class="xref py py-obj docutils literal"><span class="pre">was_split</span></code></a></td>
<td>True if multiallelic variants have been split into multiple biallelic variants.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hail.VariantDataset.write" title="hail.VariantDataset.write"><code class="xref py py-obj docutils literal"><span class="pre">write</span></code></a></td>
<td>Write variant dataset as VDS file.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="hail.VariantDataset.aggregate_by_key">
<code class="descname">aggregate_by_key</code><span class="sig-paren">(</span><em>key_code</em>, <em>agg_code</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.aggregate_by_key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.aggregate_by_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregate by user-defined key and aggregation expressions to produce a KeyTable.
Equivalent to a group-by operation in SQL.</p>
<p><strong>Examples</strong></p>
<p>Compute the number of LOF heterozygote calls per gene per sample:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kt_result</span> <span class="o">=</span> <span class="p">(</span><span class="n">vds</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">aggregate_by_key</span><span class="p">([</span><span class="s1">&#39;Sample = s&#39;</span><span class="p">,</span> <span class="s1">&#39;Gene = va.gene&#39;</span><span class="p">],</span>
<span class="gp">... </span>                       <span class="s1">&#39;nHet = g.filter(g =&gt; g.isHet() &amp;&amp; va.consequence == &quot;LOF&quot;).count()&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="s2">&quot;test.tsv&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>This will produce a <a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a> with 3 columns (<cite>Sample</cite>, <cite>Gene</cite>, <cite>nHet</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>key_code</strong> (<em>str</em><em> or </em><em>list of str</em>) &#8211; Named expression(s) for which fields are keys.</li>
<li><strong>agg_code</strong> (<em>str</em><em> or </em><em>list of str</em>) &#8211; Named aggregation expression(s).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.aggregate_intervals">
<code class="descname">aggregate_intervals</code><span class="sig-paren">(</span><em>input</em>, <em>expr</em>, <em>output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.aggregate_intervals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.aggregate_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregate over intervals and export.</p>
<p><strong>Examples</strong></p>
<p>Calculate the total number of SNPs, indels, and variants contained in
the intervals specified by <em>data/capture_intervals.txt</em>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">aggregate_intervals</span><span class="p">(</span><span class="s1">&#39;data/capture_intervals.txt&#39;</span><span class="p">,</span>
<span class="gp">... </span>  <span class="s1">&#39;n_SNP = variants.filter(v =&gt; v.altAllele().isSNP()).count(), &#39;</span> <span class="o">+</span>
<span class="gp">... </span>  <span class="s1">&#39;n_indel = variants.filter(v =&gt; v.altAllele().isIndel()).count(), &#39;</span> <span class="o">+</span>
<span class="gp">... </span>  <span class="s1">&#39;n_total = variants.count()&#39;</span><span class="p">,</span>
<span class="gp">... </span>  <span class="s1">&#39;output/out.txt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If <em>data/capture_intervals.txt</em> contains:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>4:1500-123123
5:1-1000000
16:29500000-30200000
</pre></div>
</div>
<p>then the previous expression writes something like the following to
<em>out.txt</em>:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Contig    Start       End         n_SNP   n_indel     n_total
4         1500        123123      502     51          553
5         1           1000000     25024   4500        29524
16        29500000    30200000    17222   2021        19043
</pre></div>
</div>
<p>The parameter <code class="docutils literal"><span class="pre">expr</span></code> defines the names of the column headers (in
the previous case: <code class="docutils literal"><span class="pre">n_SNP</span></code>, <code class="docutils literal"><span class="pre">n_indel</span></code>, <code class="docutils literal"><span class="pre">n_total</span></code>) and how to
calculate the value of that column for each interval.</p>
<p>Count the number of LOF, missense, and synonymous non-reference calls
per interval:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="s1">&#39;va.n_calls = gs.filter(g =&gt; g.isCalledNonRef()).count()&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">aggregate_intervals</span><span class="p">(</span><span class="s1">&#39;data/intervals.txt&#39;</span><span class="p">,</span>
<span class="gp">... </span>           <span class="s1">&#39;LOF_CALLS = variants.filter(v =&gt; va.consequence == &quot;LOF&quot;).map(v =&gt; va.n_calls).sum(), &#39;</span> <span class="o">+</span>
<span class="gp">... </span>           <span class="s1">&#39;MISSENSE_CALLS = variants.filter(v =&gt; va.consequence == &quot;missense&quot;).map(v =&gt; va.n_calls).sum(), &#39;</span> <span class="o">+</span>
<span class="gp">... </span>           <span class="s1">&#39;SYN_CALLS = variants.filter(v =&gt; va.consequence == &quot;synonymous&quot;).map(v =&gt; va.n_calls).sum()&#39;</span><span class="p">,</span>
<span class="gp">... </span>           <span class="s1">&#39;output/out.txt&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>If <em>data/intervals.txt</em> contains:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>4:1500-123123
5:1-1000000
16:29500000-30200000
</pre></div>
</div>
<p>then the previous expression writes something like the following to
<em>out.txt</em>:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Contig    Start       End         LOF_CALLS   MISSENSE_CALLS   SYN_CALLS
4         1500        123123      42          122              553
5         1           1000000     3           12               66
16        29500000    30200000    17          22               202
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>Intervals are <strong>left inclusive, right exclusive</strong>.  This means that
[chr1:1, chr1:3) contains chr1:1 and chr1:2.</p>
<p><strong>Designating output with an expression</strong></p>
<p>An export expression designates a list of computations to perform, and
what these columns are named.  These expressions should take the form
<code class="docutils literal"><span class="pre">COL_NAME_1</span> <span class="pre">=</span> <span class="pre">&lt;expression&gt;,</span> <span class="pre">COL_NAME_2</span> <span class="pre">=</span> <span class="pre">&lt;expression&gt;,</span> <span class="pre">...</span></code>.</p>
<p><code class="docutils literal"><span class="pre">expr</span></code> has the following symbols in scope:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">interval</span></code> (<em>Interval</em>): genomic interval</li>
<li><code class="docutils literal"><span class="pre">global</span></code>: global annotations</li>
<li><code class="docutils literal"><span class="pre">variants</span></code> (<em>Aggregable[Variant]</em>): aggregable of <a class="reference internal" href="representation/hail.representation.Variant.html#hail.representation.Variant" title="hail.representation.Variant"><code class="xref py py-class docutils literal"><span class="pre">Variant</span></code></a> s Aggregator namespace below.</li>
</ul>
<p>The <code class="docutils literal"><span class="pre">variants</span></code> aggregator has the following namespace:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">v</span></code> (<em>Variant</em>): <a class="reference internal" href="types.html#variant"><span class="std std-ref">Variant</span></a></li>
<li><code class="docutils literal"><span class="pre">va</span></code>: variant annotations</li>
<li><code class="docutils literal"><span class="pre">global</span></code>: Global annotations</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input</strong> (<em>str</em>) &#8211; Input interval list file.</li>
<li><strong>expr</strong> (<em>str</em>) &#8211; Export expression.</li>
<li><strong>output</strong> (<em>str</em>) &#8211; Output file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_alleles_expr">
<code class="descname">annotate_alleles_expr</code><span class="sig-paren">(</span><em>expr</em>, <em>propagate_gq=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_alleles_expr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_alleles_expr" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate alleles with expression.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Examples</strong></p>
<p>To create a variant annotation <code class="docutils literal"><span class="pre">va.nNonRefSamples:</span> <span class="pre">Array[Int]</span></code> where the ith entry of
the array is the number of samples carrying the ith alternate allele:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_alleles_expr</span><span class="p">(</span><span class="s1">&#39;va.nNonRefSamples = gs.filter(g =&gt; g.isCalledNonRef()).count()&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>This command is similar to <a class="reference internal" href="#hail.VariantDataset.annotate_variants_expr" title="hail.VariantDataset.annotate_variants_expr"><code class="xref py py-meth docutils literal"><span class="pre">annotate_variants_expr()</span></code></a>. <a class="reference internal" href="#hail.VariantDataset.annotate_alleles_expr" title="hail.VariantDataset.annotate_alleles_expr"><code class="xref py py-meth docutils literal"><span class="pre">annotate_alleles_expr()</span></code></a> dynamically splits multi-allelic sites,
evaluates each expression on each split allele separately, and for each expression annotates with an array with one element per alternate allele. In the splitting, genotypes are downcoded and each alternate allele is represented
using its minimal representation (see <a class="reference internal" href="#hail.VariantDataset.split_multi" title="hail.VariantDataset.split_multi"><code class="xref py py-meth docutils literal"><span class="pre">split_multi()</span></code></a> for more details).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>expr</strong> (<em>str</em><em> or </em><em>list of str</em>) &#8211; Annotation expression.</li>
<li><strong>propagate_gq</strong> (<em>bool</em>) &#8211; Propagate GQ instead of computing from (split) PL.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Annotated variant dataset.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_genotypes_expr">
<code class="descname">annotate_genotypes_expr</code><span class="sig-paren">(</span><em>expr</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_genotypes_expr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_genotypes_expr" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate genotypes with expression.</p>
<p><strong>Examples</strong></p>
<p>Convert the genotype schema to a <a class="reference internal" href="expr/hail.expr.TStruct.html#hail.expr.TStruct" title="hail.expr.TStruct"><code class="xref py py-class docutils literal"><span class="pre">TStruct</span></code></a> with two fields <code class="docutils literal"><span class="pre">GT</span></code> and <code class="docutils literal"><span class="pre">CASE_HET</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_genotypes_expr</span><span class="p">(</span><span class="s1">&#39;g = {GT: g.gt, CASE_HET: sa.pheno.isCase &amp;&amp; g.isHet()}&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Assume a VCF is imported with <code class="docutils literal"><span class="pre">generic=True</span></code> and the resulting genotype schema
is a <code class="docutils literal"><span class="pre">Struct</span></code> and the field <code class="docutils literal"><span class="pre">GTA</span></code> is a <code class="docutils literal"><span class="pre">Call</span></code> type. Use the <code class="docutils literal"><span class="pre">.toGenotype()</span></code> method in the
expression language to convert a <code class="docutils literal"><span class="pre">Call</span></code> to a <code class="docutils literal"><span class="pre">Genotype</span></code>. <code class="docutils literal"><span class="pre">vds_gta</span></code> will have a genotype schema equal to
<a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_gta</span> <span class="o">=</span> <span class="p">(</span><span class="n">hc</span><span class="o">.</span><span class="n">import_vcf</span><span class="p">(</span><span class="s1">&#39;data/example3.vcf.bgz&#39;</span><span class="p">,</span> <span class="n">generic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">call_fields</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;GTA&#39;</span><span class="p">])</span>
<span class="gp">... </span>                <span class="o">.</span><span class="n">annotate_genotypes_expr</span><span class="p">(</span><span class="s1">&#39;g = g.GTA.toGenotype()&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p><a class="reference internal" href="#hail.VariantDataset.annotate_genotypes_expr" title="hail.VariantDataset.annotate_genotypes_expr"><code class="xref py py-meth docutils literal"><span class="pre">annotate_genotypes_expr()</span></code></a> evaluates the expression given by <code class="docutils literal"><span class="pre">expr</span></code> and assigns
the result of the right hand side to the annotation path specified by the left-hand side (must
begin with <code class="docutils literal"><span class="pre">g</span></code>). This is analogous to <a class="reference internal" href="#hail.VariantDataset.annotate_variants_expr" title="hail.VariantDataset.annotate_variants_expr"><code class="xref py py-meth docutils literal"><span class="pre">annotate_variants_expr()</span></code></a> and
<a class="reference internal" href="#hail.VariantDataset.annotate_samples_expr" title="hail.VariantDataset.annotate_samples_expr"><code class="xref py py-meth docutils literal"><span class="pre">annotate_samples_expr()</span></code></a> where the annotation paths are <code class="docutils literal"><span class="pre">va</span></code> and <code class="docutils literal"><span class="pre">sa</span></code> respectively.</p>
<p><code class="docutils literal"><span class="pre">expr</span></code> is in genotype context so the following symbols are in scope:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">g</span></code>: genotype annotation</li>
<li><code class="docutils literal"><span class="pre">v</span></code> (<em>Variant</em>): <a class="reference internal" href="types.html#variant"><span class="std std-ref">Variant</span></a></li>
<li><code class="docutils literal"><span class="pre">va</span></code>: variant annotations</li>
<li><code class="docutils literal"><span class="pre">s</span></code> (<em>Sample</em>): <span class="xref std std-ref">sample</span></li>
<li><code class="docutils literal"><span class="pre">sa</span></code>: sample annotations</li>
<li><code class="docutils literal"><span class="pre">global</span></code>: global annotations</li>
</ul>
</div></blockquote>
<p>For more information, see the documentation on writing <a class="reference external" href="overview.html#expressions">expressions</a>
and using the <a class="reference external" href="exprlang.html">Hail Expression Language</a>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<ul class="last simple">
<li>If the resulting genotype schema is not <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a>,
subsequent function calls on the annotated variant dataset may not work such as
<a class="reference internal" href="#hail.VariantDataset.pca" title="hail.VariantDataset.pca"><code class="xref py py-meth docutils literal"><span class="pre">pca()</span></code></a> and <a class="reference internal" href="#hail.VariantDataset.linreg" title="hail.VariantDataset.linreg"><code class="xref py py-meth docutils literal"><span class="pre">linreg()</span></code></a>.</li>
<li>Hail performance may be significantly slower if the annotated variant dataset does not have a
genotype schema equal to <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a>.</li>
<li>Genotypes are immutable. For example, if <code class="docutils literal"><span class="pre">g</span></code> is initially of type <code class="docutils literal"><span class="pre">Genotype</span></code>, the expression
<code class="docutils literal"><span class="pre">g.gt</span> <span class="pre">=</span> <span class="pre">g.gt</span> <span class="pre">+</span> <span class="pre">1</span></code> will return a <code class="docutils literal"><span class="pre">Struct</span></code> with one field <code class="docutils literal"><span class="pre">gt</span></code> of type <code class="docutils literal"><span class="pre">Int</span></code> and <strong>NOT</strong> a <code class="docutils literal"><span class="pre">Genotype</span></code>
with the <code class="docutils literal"><span class="pre">gt</span></code> incremented by 1.</li>
</ul>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>expr</strong> (<em>str</em><em> or </em><em>list of str</em>) &#8211; Annotation expression.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Annotated variant dataset.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_global_expr">
<code class="descname">annotate_global_expr</code><span class="sig-paren">(</span><em>expr</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_global_expr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_global_expr" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate global with expression.</p>
<p><strong>Example</strong></p>
<p>Annotate global with an array of populations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_global_expr</span><span class="p">(</span><span class="s1">&#39;global.pops = [&quot;FIN&quot;, &quot;AFR&quot;, &quot;EAS&quot;, &quot;NFE&quot;]&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Create, then overwrite, then drop a global annotation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_global_expr</span><span class="p">(</span><span class="s1">&#39;global.pops = [&quot;FIN&quot;, &quot;AFR&quot;, &quot;EAS&quot;]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_global_expr</span><span class="p">(</span><span class="s1">&#39;global.pops = [&quot;FIN&quot;, &quot;AFR&quot;, &quot;EAS&quot;, &quot;NFE&quot;]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_global_expr</span><span class="p">(</span><span class="s1">&#39;global.pops = drop(global, pops)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The expression namespace contains only one variable:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">global</span></code>: global annotations</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>expr</strong> (<em>str</em><em> or </em><em>list of str</em>) &#8211; Annotation expression</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Annotated variant dataset.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_global_list">
<code class="descname">annotate_global_list</code><span class="sig-paren">(</span><em>input</em>, <em>root</em>, <em>as_set=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_global_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_global_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Load text file into global annotations as Array[String] or
Set[String].</p>
<p><strong>Examples</strong></p>
<p>Add a list of genes in a file to global annotations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_global_list</span><span class="p">(</span><span class="s1">&#39;data/genes.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;global.genes&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>For the gene list</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>$ cat data/genes.txt
SCN2A
SONIC-HEDGEHOG
PRNP
</pre></div>
</div>
<p>this adds <code class="docutils literal"><span class="pre">global.genes:</span> <span class="pre">Array[String]</span></code> with value <code class="docutils literal"><span class="pre">[&quot;SCN2A&quot;,</span> <span class="pre">&quot;SONIC-HEDGEHOG&quot;,</span> <span class="pre">&quot;PRNP&quot;]</span></code>.</p>
<p>To filter to those variants in genes listed in <em>genes.txt</em> given a variant annotation <code class="docutils literal"><span class="pre">va.gene:</span> <span class="pre">String</span></code>, annotate as type <code class="docutils literal"><span class="pre">Set[String]</span></code> instead:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">annotate_global_list</span><span class="p">(</span><span class="s1">&#39;data/genes.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;global.genes&#39;</span><span class="p">,</span> <span class="n">as_set</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">filter_variants_expr</span><span class="p">(</span><span class="s1">&#39;global.genes.contains(va.gene)&#39;</span><span class="p">))</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>str</em>) &#8211; Input text file.</li>
<li><strong>root</strong> (<em>str</em>) &#8211; Global annotation path to store text file.</li>
<li><strong>as_set</strong> (<em>bool</em>) &#8211; If True, load text file as Set[String],
otherwise, load as Array[String].</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Annotated variant dataset with new global annotation given by the list.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_global_py">
<code class="descname">annotate_global_py</code><span class="sig-paren">(</span><em>path</em>, <em>annotation</em>, <em>annotation_type</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_global_py"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_global_py" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate global from Python objects.</p>
<p><strong>Example</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_global_py</span><span class="p">(</span><span class="s1">&#39;global.populations&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="p">[</span><span class="s1">&#39;EAS&#39;</span><span class="p">,</span> <span class="s1">&#39;AFR&#39;</span><span class="p">,</span> <span class="s1">&#39;EUR&#39;</span><span class="p">,</span> <span class="s1">&#39;SAS&#39;</span><span class="p">,</span> <span class="s1">&#39;AMR&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                    <span class="n">TArray</span><span class="p">(</span><span class="n">TString</span><span class="p">()))</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>This method registers new global annotations in a VDS. These annotations
can then be accessed through expressions in downstream operations. The
Hail data type must be provided and must match the given <code class="docutils literal"><span class="pre">annotation</span></code>
parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> (<em>str</em>) &#8211; annotation path starting in &#8216;global&#8217;</li>
<li><strong>annotation</strong> &#8211; annotation to add to global</li>
<li><strong>annotation_type</strong> (<a class="reference internal" href="expr/hail.expr.Type.html#hail.expr.Type" title="hail.expr.Type"><code class="xref py py-class docutils literal"><span class="pre">Type</span></code></a>) &#8211; Hail type of annotation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Annotated variant dataset.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_global_table">
<code class="descname">annotate_global_table</code><span class="sig-paren">(</span><em>input</em>, <em>root</em>, <em>config=&lt;hail.utils.TextTableConfig object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_global_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_global_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Load delimited text file (text table) into global annotations as
Array[Struct].</p>
<p><strong>Examples</strong></p>
<p>Load a file as a global annotation.  Consider the file <em>data/genes_pli_exac.txt</em> with contents:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>GENE    PLI     EXAC_LOF_COUNT
Gene1   0.12312 2
...
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_global_table</span><span class="p">(</span><span class="s1">&#39;data/genes_pli_exac.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;global.genes&#39;</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">config</span><span class="o">=</span><span class="n">TextTableConfig</span><span class="p">(</span><span class="n">types</span><span class="o">=</span><span class="s1">&#39;PLI: Double, EXAC_LOF_COUNT: Int&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>creates a new global annotation <code class="docutils literal"><span class="pre">global.genes</span></code> with type:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>global.genes: Array[Struct {
    GENE: String,
    PLI: Double,
    EXAC_LOF_COUNT: Int
}]
</pre></div>
</div>
<p>where each line is stored as an element of the array.</p>
<p><strong>Notes</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>str</em>) &#8211; Input text file.</li>
<li><strong>root</strong> (<em>str</em>) &#8211; Global annotation path to store text table.</li>
<li><strong>config</strong> (<a class="reference internal" href="hail.TextTableConfig.html#hail.TextTableConfig" title="hail.TextTableConfig"><code class="xref py py-class docutils literal"><span class="pre">TextTableConfig</span></code></a>) &#8211; Configuration options for importing text files</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Annotated variant dataset.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_samples_expr">
<code class="descname">annotate_samples_expr</code><span class="sig-paren">(</span><em>expr</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_samples_expr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_samples_expr" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate samples with expression.</p>
<p><strong>Examples</strong></p>
<p>Compute per-sample GQ statistics for hets:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">annotate_samples_expr</span><span class="p">(</span><span class="s1">&#39;sa.gqHetStats = gs.filter(g =&gt; g.isHet()).map(g =&gt; g.gq).stats()&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">export_samples</span><span class="p">(</span><span class="s1">&#39;output/samples.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;sample = s, het_gq_mean = sa.gqHetStats.mean&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Compute the list of genes with a singleton LOF per sample:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_table</span><span class="p">(</span><span class="s1">&#39;data/consequence.tsv&#39;</span><span class="p">,</span> <span class="s1">&#39;Variant&#39;</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="s1">&#39;va.consequence = table.Consequence&#39;</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">TextTableConfig</span><span class="p">(</span><span class="n">impute</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="s1">&#39;va.isSingleton = gs.map(g =&gt; g.nNonRefAlleles()).sum() == 1&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">annotate_samples_expr</span><span class="p">(</span><span class="s1">&#39;sa.LOF_genes = gs.filter(g =&gt; va.isSingleton &amp;&amp; g.isHet() &amp;&amp; va.consequence == &quot;LOF&quot;).map(g =&gt; va.gene).collect()&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>To create an annotation for only a subset of samples based on an existing annotation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_samples_expr</span><span class="p">(</span><span class="s1">&#39;sa.newpheno = if (sa.pheno.cohortName == &quot;cohort1&quot;) sa.pheno.bloodPressure else NA: Double&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For optimal performance, be sure to explicitly give the alternative (<code class="docutils literal"><span class="pre">NA</span></code>) the same type as the consequent (<code class="docutils literal"><span class="pre">sa.pheno.bloodPressure</span></code>).</p>
</div>
<p><strong>Notes</strong></p>
<p><code class="docutils literal"><span class="pre">expr</span></code> is in sample context so the following symbols are in scope:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">s</span></code> (<em>Sample</em>): <span class="xref std std-ref">sample</span></li>
<li><code class="docutils literal"><span class="pre">sa</span></code>: sample annotations</li>
<li><code class="docutils literal"><span class="pre">global</span></code>: global annotations</li>
<li><code class="docutils literal"><span class="pre">gs</span></code> (<em>Aggregable[Genotype]</em>): aggregable of <a class="reference internal" href="types.html#genotype"><span class="std std-ref">Genotype</span></a> for sample <code class="docutils literal"><span class="pre">s</span></code></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>expr</strong> (<em>str</em><em> or </em><em>list of str</em>) &#8211; Annotation expression.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Annotated variant dataset.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_samples_fam">
<code class="descname">annotate_samples_fam</code><span class="sig-paren">(</span><em>input</em>, <em>quantpheno=False</em>, <em>delimiter='\\\\s+'</em>, <em>root='sa.fam'</em>, <em>missing='NA'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_samples_fam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_samples_fam" title="Permalink to this definition">¶</a></dt>
<dd><p>Import PLINK .fam file into sample annotations.</p>
<p><strong>Examples</strong></p>
<p>Import case-control phenotype data from a tab-separated <a class="reference external" href="https://www.cog-genomics.org/plink2/formats#fam">PLINK .fam</a> file into sample
annotations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_samples_fam</span><span class="p">(</span><span class="s2">&quot;data/myStudy.fam&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>In Hail, unlike PLINK, the user must <em>explicitly</em> distinguish between
case-control and quantitative phenotypes. Importing a quantitative
phenotype without <code class="docutils literal"><span class="pre">quantpheno=True</span></code> will return an error
(unless all values happen to be <code class="docutils literal"><span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">1</span></code>, <code class="docutils literal"><span class="pre">2</span></code>, and <code class="docutils literal"><span class="pre">-9</span></code>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_samples_fam</span><span class="p">(</span><span class="s2">&quot;data/myStudy.fam&quot;</span><span class="p">,</span> <span class="n">quantpheno</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Annotations</strong></p>
<p>The annotation names, types, and missing values are shown below,
assuming the default root <code class="docutils literal"><span class="pre">sa.fam</span></code>.</p>
<ul class="simple">
<li><strong>sa.fam.famID</strong> (<em>String</em>) &#8211; Family ID (missing = &#8220;0&#8221;)</li>
<li><strong>s</strong> (<em>String</em>) &#8211; Sample ID</li>
<li><strong>sa.fam.patID</strong> (<em>String</em>) &#8211; Paternal ID (missing = &#8220;0&#8221;)</li>
<li><strong>sa.fam.matID</strong> (<em>String</em>) &#8211; Maternal ID (missing = &#8220;0&#8221;)</li>
<li><strong>sa.fam.isFemale</strong> (<em>Boolean</em>) &#8211; Sex (missing = &#8220;NA&#8221;, &#8220;-9&#8221;, &#8220;0&#8221;)</li>
<li><strong>sa.fam.isCase</strong> (<em>Boolean</em>) &#8211; Case-control phenotype (missing = &#8220;0&#8221;, &#8220;-9&#8221;, non-numeric or the <code class="docutils literal"><span class="pre">missing</span></code> argument, if given.</li>
<li><strong>sa.fam.qPheno</strong> (<em>Double</em>) &#8211; Quantitative phenotype (missing = &#8220;NA&#8221; or the <code class="docutils literal"><span class="pre">missing</span></code> argument, if given.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>str</em>) &#8211; Path to .fam file.</li>
<li><strong>root</strong> (<em>str</em>) &#8211; Sample annotation path to store .fam file.</li>
<li><strong>quantpheno</strong> (<em>bool</em>) &#8211; If True, .fam phenotype is interpreted as quantitative.</li>
<li><strong>delimiter</strong> (<em>str</em>) &#8211; .fam file field delimiter regex.</li>
<li><strong>missing</strong> (<em>str</em>) &#8211; The string used to denote missing values.
For case-control, 0, -9, and non-numeric are also treated
as missing.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Annotated variant dataset with sample annotations from fam file.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_samples_keytable">
<code class="descname">annotate_samples_keytable</code><span class="sig-paren">(</span><em>keytable</em>, <em>expr</em>, <em>vds_key=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_samples_keytable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_samples_keytable" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate samples with a <a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a>.</p>
<p>If <cite>vds_key</cite> is None, the key table must have exactly one key of
type <em>String</em>.</p>
<p>If <cite>vds_key</cite> is not None, it must be a list of Hail expressions whose types
match, in order, the <cite>keytable</cite>&#8216;s key types.</p>
<p><strong>Examples</strong></p>
<p>Add annotations from a sample-keyed TSV:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kt</span> <span class="o">=</span> <span class="n">hc</span><span class="o">.</span><span class="n">import_keytable</span><span class="p">(</span><span class="s1">&#39;data/samples2.tsv&#39;</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="n">config</span><span class="o">=</span><span class="n">TextTableConfig</span><span class="p">(</span><span class="n">impute</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s1">&#39;PT-ID&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="n">annotate_vds</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_samples_keytable</span><span class="p">(</span><span class="n">kt</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="s1">&#39;sa.batch = table.Batch&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p><code class="docutils literal"><span class="pre">expr</span></code> has the following symbols in scope:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">sa</span></code>: sample annotations</li>
<li><code class="docutils literal"><span class="pre">table</span></code>: <a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a> value</li>
</ul>
</div></blockquote>
<p>each expression in the list <code class="docutils literal"><span class="pre">vds_key</span></code> has the following symbols in
scope:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">s</span></code> (<em>Sample</em>): <span class="xref std std-ref">sample</span></li>
<li><code class="docutils literal"><span class="pre">sa</span></code>: sample annotations</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>keytable</strong> (<a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a>) &#8211; Key table with which to annotate samples.</li>
<li><strong>expr</strong> (<em>str</em>) &#8211; Annotation expression.</li>
<li><strong>vds_key</strong> (<em>list of str</em><em>, </em><em>str</em><em>, or </em><em>None</em>) &#8211; Join key(s) in the dataset. Sample ID is used if this parameter is None.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_samples_list">
<code class="descname">annotate_samples_list</code><span class="sig-paren">(</span><em>input</em>, <em>root</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_samples_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_samples_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate samples with a Boolean indicating presence in a list of samples in a text file.</p>
<p><strong>Examples</strong></p>
<p>Add the sample annotation <code class="docutils literal"><span class="pre">sa.inBatch1:</span> <span class="pre">Boolean</span></code> with value true if the sample is in <em>batch1.txt</em>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_samples_list</span><span class="p">(</span><span class="s1">&#39;data/batch1.txt&#39;</span><span class="p">,</span><span class="s1">&#39;sa.inBatch1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The file must have no header and one sample per line</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>$ cat data/batch1.txt
SampleA
SampleB
...
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>str</em>) &#8211; Sample list file.</li>
<li><strong>root</strong> (<em>str</em>) &#8211; Sample annotation path to store Boolean.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Annotated variant dataset with a new boolean sample annotation</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_samples_table">
<code class="descname">annotate_samples_table</code><span class="sig-paren">(</span><em>input</em>, <em>sample_expr</em>, <em>root=None</em>, <em>code=None</em>, <em>config=&lt;hail.utils.TextTableConfig object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_samples_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_samples_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate samples with delimited text file (text table).</p>
<p><strong>Examples</strong></p>
<p>To annotates samples using <cite>samples1.tsv</cite> with type imputation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conf</span> <span class="o">=</span> <span class="n">TextTableConfig</span><span class="p">(</span><span class="n">impute</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_samples_table</span><span class="p">(</span><span class="s1">&#39;data/samples1.tsv&#39;</span><span class="p">,</span> <span class="s1">&#39;Sample&#39;</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="s1">&#39;sa.pheno&#39;</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">conf</span><span class="p">)</span>
</pre></div>
</div>
<p>Given this file</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>$ cat data/samples1.tsv
Sample      Height  Status  Age
PT-1234     154.1   ADHD    24
PT-1236     160.9   Control 19
PT-1238     NA      ADHD    89
PT-1239     170.3   Control 55
</pre></div>
</div>
<p>the three new sample annotations are <code class="docutils literal"><span class="pre">sa.pheno.Height:</span> <span class="pre">Double</span></code>, <code class="docutils literal"><span class="pre">sa.pheno.Status:</span> <span class="pre">String</span></code>, and <code class="docutils literal"><span class="pre">sa.pheno.Age:</span> <span class="pre">Int</span></code>.</p>
<p>To annotate without type imputation, resulting in all String types:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_samples_table</span><span class="p">(</span><span class="s1">&#39;data/samples1.tsv&#39;</span><span class="p">,</span> <span class="s1">&#39;Sample&#39;</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="s1">&#39;sa.phenotypes&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Detailed examples</strong></p>
<p>Let&#8217;s import annotations from a CSV file with missing data and special characters</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>$ cat data/samples2.tsv
Batch,PT-ID
1kg,PT-0001
1kg,PT-0002
study1,PT-0003
study3,PT-0003
.,PT-0004
1kg,PT-0005
.,PT-0006
1kg,PT-0007
</pre></div>
</div>
<p>In this case, we should:</p>
<ul class="simple">
<li>Escape the <code class="docutils literal"><span class="pre">PT-ID</span></code> column with backticks in the <code class="docutils literal"><span class="pre">sample_expr</span></code> argument because it contains a dash</li>
<li>Pass the non-default delimiter <code class="docutils literal"><span class="pre">,</span></code></li>
<li>Pass the non-default missing value <code class="docutils literal"><span class="pre">.</span></code></li>
<li>Add the only useful column using <code class="docutils literal"><span class="pre">code</span></code> rather than the <code class="docutils literal"><span class="pre">root</span></code> parameter.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conf</span> <span class="o">=</span> <span class="n">TextTableConfig</span><span class="p">(</span><span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_samples_table</span><span class="p">(</span><span class="s1">&#39;data/samples2.tsv&#39;</span><span class="p">,</span> <span class="s1">&#39;`PT-ID`&#39;</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="s1">&#39;sa.batch = table.Batch&#39;</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">conf</span><span class="p">)</span>
</pre></div>
</div>
<p>Let&#8217;s import annotations from a file with no header and sample IDs that need to be transformed. Suppose the vds sample IDs are of the form <code class="docutils literal"><span class="pre">NA#####</span></code>. This file has no header line, and the sample ID is hidden in a field with other information</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>$ cat data/samples3.tsv
1kg_NA12345   female
1kg_NA12346   male
1kg_NA12348   female
pgc_NA23415   male
pgc_NA23418   male
</pre></div>
</div>
<p>To import it:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conf</span> <span class="o">=</span> <span class="n">TextTableConfig</span><span class="p">(</span><span class="n">noheader</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_samples_table</span><span class="p">(</span><span class="s1">&#39;data/samples3.tsv&#39;</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="s1">&#39;_0.split(&quot;_&quot;)[1]&#39;</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">code</span><span class="o">=</span><span class="s1">&#39;sa.sex = table._1, sa.batch = table._0.split(&quot;_&quot;)[0]&#39;</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">config</span><span class="o">=</span><span class="n">conf</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Using the</strong> <code class="docutils literal"><span class="pre">sample_expr</span></code> <strong>argument</strong></p>
<p>This argument tells Hail how to get a sample ID out of your table. Each column in the table is exposed to the Hail expr language. Possibilities include <code class="docutils literal"><span class="pre">Sample</span></code> (if your sample id is in a column called &#8216;Sample&#8217;), <code class="docutils literal"><span class="pre">_2</span></code> (if your sample ID is the 3rd column of a table with no header), or something more complicated like <code class="docutils literal"><span class="pre">'if</span> <span class="pre">(&quot;PGC&quot;</span> <span class="pre">~</span> <span class="pre">ID1)</span> <span class="pre">ID1</span> <span class="pre">else</span> <span class="pre">ID2'</span></code>.  All that matters is that this expr results in a string.  If the expr evaluates to missing, it will not be mapped to any VDS samples.</p>
<p><strong>Using the</strong> <code class="docutils literal"><span class="pre">root</span></code> <strong>and</strong> <code class="docutils literal"><span class="pre">code</span></code> <strong>arguments</strong></p>
<p>This module requires exactly one of these two arguments to tell Hail how to insert the table into the sample annotation schema.</p>
<p>The <code class="docutils literal"><span class="pre">root</span></code> argument is the simpler of these two, and simply packages up all table annotations as a <code class="docutils literal"><span class="pre">Struct</span></code> and drops it at the given <code class="docutils literal"><span class="pre">root</span></code> location.  If your table has columns <code class="docutils literal"><span class="pre">Sample</span></code>, <code class="docutils literal"><span class="pre">Sex</span></code>, and <code class="docutils literal"><span class="pre">Batch</span></code>, then <code class="docutils literal"><span class="pre">root='sa.metadata'</span></code> creates the struct <code class="docutils literal"><span class="pre">{Sample,</span> <span class="pre">Sex,</span> <span class="pre">Batch}</span></code> at <code class="docutils literal"><span class="pre">sa.metadata</span></code>, which gives you access to the paths <code class="docutils literal"><span class="pre">sa.metadata.Sample</span></code>, <code class="docutils literal"><span class="pre">sa.metadata.Sex</span></code>, and <code class="docutils literal"><span class="pre">sa.metadata.Batch</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">code</span></code> argument expects an annotation expression and has access to <code class="docutils literal"><span class="pre">sa</span></code> (the sample annotations in the VDS) and <code class="docutils literal"><span class="pre">table</span></code> (a struct with all the columns in the table).  <code class="docutils literal"><span class="pre">root='sa.anno'</span></code> is equivalent to <code class="docutils literal"><span class="pre">code='sa.anno</span> <span class="pre">=</span> <span class="pre">table'</span></code>.</p>
<p><strong>Common uses for the</strong> <code class="docutils literal"><span class="pre">code</span></code> <strong>argument</strong></p>
<p>Don&#8217;t generate a full struct in a table with only one annotation column</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>code=&#39;sa.annot = table._1&#39;
</pre></div>
</div>
<p>Put annotations on the top level under <cite>sa</cite></p>
<div class="highlight-text"><div class="highlight"><pre><span></span>code=&#39;sa = merge(sa, table)&#39;
</pre></div>
</div>
<p>Load only specific annotations from the table</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>code=&#39;sa.annotations = select(table, toKeep1, toKeep2, toKeep3)&#39;
</pre></div>
</div>
<p>The above is equivalent to</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>code=&#39;sa.annotations.toKeep1 = table.toKeep1,
    sa.annotations.toKeep2 = table.toKeep2,
    sa.annotations.toKeep3 = table.toKeep3&#39;
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>str</em>) &#8211; Path to delimited text file.</li>
<li><strong>sample_expr</strong> (<em>str</em>) &#8211; Expression for sample id (key).</li>
<li><strong>root</strong> (<em>str</em>) &#8211; Sample annotation path to store text table.</li>
<li><strong>code</strong> (<em>str</em>) &#8211; Annotation expression.</li>
<li><strong>config</strong> (<a class="reference internal" href="hail.TextTableConfig.html#hail.TextTableConfig" title="hail.TextTableConfig"><code class="xref py py-class docutils literal"><span class="pre">TextTableConfig</span></code></a>) &#8211; Configuration options for importing text files</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Annotated variant dataset with new samples annotations imported from a text file</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_samples_vds">
<code class="descname">annotate_samples_vds</code><span class="sig-paren">(</span><em>right</em>, <em>root=None</em>, <em>code=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_samples_vds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_samples_vds" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate samples with sample annotations from .vds file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>right</strong> (<a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a>) &#8211; Dataset to annotate with.</li>
<li><strong>root</strong> (<em>str</em>) &#8211; Sample annotation path to add sample annotations.</li>
<li><strong>code</strong> (<em>str</em>) &#8211; Annotation expression.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Annotated variant dataset.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_variants_bed">
<code class="descname">annotate_variants_bed</code><span class="sig-paren">(</span><em>input</em>, <em>root</em>, <em>all=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_variants_bed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_variants_bed" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate variants based on the intervals in a .bed file.</p>
<p><strong>Examples</strong></p>
<p>Add the variant annotation <code class="docutils literal"><span class="pre">va.cnvRegion:</span> <span class="pre">Boolean</span></code> indicating inclusion in at least one interval of the three-column BED file <cite>file1.bed</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_bed</span><span class="p">(</span><span class="s1">&#39;data/file1.bed&#39;</span><span class="p">,</span> <span class="s1">&#39;va.cnvRegion&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Add a variant annotation <code class="docutils literal"><span class="pre">va.cnvRegion:</span> <span class="pre">String</span></code> with value given by the fourth column of <cite>file2.bed</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_bed</span><span class="p">(</span><span class="s1">&#39;data/file2.bed&#39;</span><span class="p">,</span> <span class="s1">&#39;va.cnvRegion&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The file formats are</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>$ cat data/file1.bed
track name=&quot;BedTest&quot;
20    1          14000000
20    17000000   18000000
...

$ cat file2.bed
track name=&quot;BedTest&quot;
20    1          14000000  cnv1
20    17000000   18000000  cnv2
...
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p><a class="reference external" href="https://genome.ucsc.edu/FAQ/FAQformat.html#format1">UCSC bed files</a> can have up to 12 fields, but Hail will only ever look at the first four.  The first three fields are required (<code class="docutils literal"><span class="pre">chrom</span></code>, <code class="docutils literal"><span class="pre">chromStart</span></code>, and <code class="docutils literal"><span class="pre">chromEnd</span></code>).  If a fourth column is found, Hail will parse this field as a string and load it into the specified annotation path.  If the bed file has only three columns, Hail will assign each variant a Boolean annotation, true if and only if the variant lies in the union of the intervals. Hail ignores header lines in BED files.</p>
<p>If the <code class="docutils literal"><span class="pre">all</span></code> parameter is set to <code class="docutils literal"><span class="pre">True</span></code> and a fourth column is present, the annotation will be the set (possibly empty) of fourth column strings as a <code class="docutils literal"><span class="pre">Set[String]</span></code> for all intervals that overlap the given variant.</p>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">UCSC BED files are end-exclusive but 0-indexed, so the line &#8220;5  100  105&#8221; is interpreted in Hail as loci <cite>5:101, 5:102, 5:103, 5:104. 5:105</cite>. Details <a class="reference external" href="http://genome.ucsc.edu/blog/the-ucsc-genome-browser-coordinate-counting-systems/">here</a>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>str</em>) &#8211; Path to .bed file.</li>
<li><strong>root</strong> (<em>str</em>) &#8211; Variant annotation path to store annotation.</li>
<li><strong>all</strong> (<em>bool</em>) &#8211; Store values from all overlapping intervals as a set.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Annotated variant dataset with new variant annotations imported from a .bed file.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_variants_expr">
<code class="descname">annotate_variants_expr</code><span class="sig-paren">(</span><em>expr</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_variants_expr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_variants_expr" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate variants with expression.</p>
<p><strong>Examples</strong></p>
<p>Compute GQ statistics about heterozygotes per variant:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="s1">&#39;va.gqHetStats = gs.filter(g =&gt; g.isHet()).map(g =&gt; g.gq).stats()&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Collect a list of sample IDs with non-ref calls in LOF variants:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="s1">&#39;va.nonRefSamples = gs.filter(g =&gt; g.isCalledNonRef()).map(g =&gt; s).collect()&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Substitute a custom string for the rsID field:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="s1">&#39;va.rsid = str(v)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p><code class="docutils literal"><span class="pre">expr</span></code> is in variant context so the following symbols are in scope:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">v</span></code> (<em>Variant</em>): <a class="reference internal" href="types.html#variant"><span class="std std-ref">Variant</span></a></li>
<li><code class="docutils literal"><span class="pre">va</span></code>: variant annotations</li>
<li><code class="docutils literal"><span class="pre">global</span></code>: global annotations</li>
<li><code class="docutils literal"><span class="pre">gs</span></code> (<em>Aggregable[Genotype]</em>): aggregable of <a class="reference internal" href="types.html#genotype"><span class="std std-ref">Genotype</span></a> for variant <code class="docutils literal"><span class="pre">v</span></code></li>
</ul>
</div></blockquote>
<p>For more information, see the documentation on writing <a class="reference external" href="overview.html#expressions">expressions</a>
and using the <a class="reference external" href="exprlang.html">Hail Expression Language</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>expr</strong> (<em>str</em><em> or </em><em>list of str</em>) &#8211; Annotation expression or list of annotation expressions.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Annotated variant dataset.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_variants_intervals">
<code class="descname">annotate_variants_intervals</code><span class="sig-paren">(</span><em>input</em>, <em>root</em>, <em>all=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_variants_intervals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_variants_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate variants from an interval list file.</p>
<p><strong>Examples</strong></p>
<p>Consider the file, <em>data/exons.interval_list</em>, in
<code class="docutils literal"><span class="pre">chromosome:start-end</span></code> format:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>$ cat data/exons.interval_list
1:5122980-5123054
1:5531412-5531715
1:5600022-5601025
1:5610246-5610349
</pre></div>
</div>
<p>The following invocation produces a vds with a new variant annotation,
<code class="docutils literal"><span class="pre">va.inExon</span></code>. The annotation <code class="docutils literal"><span class="pre">va.inExon</span></code> is <code class="docutils literal"><span class="pre">true</span></code> for every
variant included by <code class="docutils literal"><span class="pre">exons.interval_list</span></code> and false otherwise.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_intervals</span><span class="p">(</span><span class="s1">&#39;data/exons.interval_list&#39;</span><span class="p">,</span> <span class="s1">&#39;va.inExon&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Consider the tab-separated, five-column file <em>data/exons2.interval_list</em>:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>$ cat data/exons2.interval_list
1   5122980 5123054 + gene1
1   5531412 5531715 + gene1
1   5600022 5601025 - gene2
1   5610246 5610349 - gene2
</pre></div>
</div>
<p>This file maps from variant intervals to gene names. The following
invocation produces a vds with a new variant annotation <code class="docutils literal"><span class="pre">va.gene</span></code>. The
annotation <code class="docutils literal"><span class="pre">va.gene</span></code> is set to the gene name occurring in the fifth
column and <code class="docutils literal"><span class="pre">NA</span></code> otherwise.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_intervals</span><span class="p">(</span><span class="s1">&#39;data/exons2.interval_list&#39;</span><span class="p">,</span> <span class="s1">&#39;va.gene&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>There are two formats for interval list files.  The first appears as
<code class="docutils literal"><span class="pre">chromosome:start-end</span></code> as in the first example.  This format will
annotate variants with a <em>Boolean</em>, which is <code class="docutils literal"><span class="pre">true</span></code> if that variant is
found in any interval specified in the file and <cite>false</cite> otherwise.</p>
<p>The second interval list format is a TSV with fields chromosome, start,
end, strand, target.  <strong>There should not be a header.</strong> This file will
annotate variants with the <em>String</em> in the fifth column (target). If
<code class="docutils literal"><span class="pre">all=True</span></code>, the annotation will be the, possibly empty,
<code class="docutils literal"><span class="pre">Set[String]</span></code> of fifth column strings (targets) for all intervals that
overlap the given variant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>str</em>) &#8211; Path to .interval_list.</li>
<li><strong>root</strong> (<em>str</em>) &#8211; Variant annotation path to store annotation.</li>
<li><strong>all</strong> (<em>bool</em>) &#8211; If true, store values from all overlapping
intervals as a set.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Annotated variant dataset.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_variants_keytable">
<code class="descname">annotate_variants_keytable</code><span class="sig-paren">(</span><em>keytable</em>, <em>expr</em>, <em>vds_key=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_variants_keytable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_variants_keytable" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate variants with an expression that may depend on a <a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a>.</p>
<p>If <cite>vds_key</cite> is None, the keytable&#8217;s key must be exactly one column and
that column must have type <em>Variant</em>.</p>
<p>If <cite>vds_key</cite> is not None, it must be a list of Hail expressions whose types
match, in order, the <cite>keytable</cite>&#8216;s key type.</p>
<p><strong>Examples</strong></p>
<p>Add annotations from a variant-keyed TSV:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kt</span> <span class="o">=</span> <span class="n">hc</span><span class="o">.</span><span class="n">import_keytable</span><span class="p">(</span><span class="s1">&#39;data/variant-lof.tsv&#39;</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">TextTableConfig</span><span class="p">(</span><span class="n">impute</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_keytable</span><span class="p">(</span><span class="n">kt</span><span class="p">,</span> <span class="s1">&#39;va.lof = table.lof&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Add annotations from a gene-and-type-keyed TSV:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kt</span> <span class="o">=</span> <span class="n">hc</span><span class="o">.</span><span class="n">import_keytable</span><span class="p">(</span><span class="s1">&#39;data/locus-metadata.tsv&#39;</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="n">config</span><span class="o">=</span><span class="n">TextTableConfig</span><span class="p">(</span><span class="n">impute</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">key_by</span><span class="p">([</span><span class="s1">&#39;gene&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_keytable</span><span class="p">(</span><span class="n">kt</span><span class="p">,</span>
<span class="gp">... </span>      <span class="s1">&#39;va.foo = table.foo&#39;</span><span class="p">,</span>
<span class="gp">... </span>      <span class="p">[</span><span class="s1">&#39;va.gene&#39;</span><span class="p">,</span> <span class="s1">&#39;if (va.score &gt; 10) &quot;Type1&quot; else &quot;Type2&quot;&#39;</span><span class="p">]))</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p><code class="docutils literal"><span class="pre">expr</span></code> has the following symbols in scope:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">va</span></code>: variant annotations</li>
<li><code class="docutils literal"><span class="pre">table</span></code>: <a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a> value</li>
</ul>
</div></blockquote>
<p>each expression in the list <code class="docutils literal"><span class="pre">vds_key</span></code> has the following symbols in
scope:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">v</span></code> (<em>Variant</em>): <a class="reference internal" href="types.html#variant"><span class="std std-ref">Variant</span></a></li>
<li><code class="docutils literal"><span class="pre">va</span></code>: variant annotations</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>expr</strong> (<em>str</em><em> or </em><em>list of str</em>) &#8211; Annotation expression or list of annotation expressions</li>
<li><strong>vds_key</strong> (<em>None</em><em> or </em><em>list of str</em>) &#8211; A list of annotation expressions to be used as the VDS&#8217;s join key</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A <a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a> with new variant annotations specified by <code class="docutils literal"><span class="pre">expr</span></code></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_variants_loci">
<code class="descname">annotate_variants_loci</code><span class="sig-paren">(</span><em>path</em>, <em>locus_expr</em>, <em>root=None</em>, <em>code=None</em>, <em>config=&lt;hail.utils.TextTableConfig object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_variants_loci"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_variants_loci" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate variants from an delimited text file (text table) indexed
by loci.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> (<em>str</em>) &#8211; Path to delimited text file.</li>
<li><strong>locus_expr</strong> (<em>str</em>) &#8211; Expression for locus (key).</li>
<li><strong>root</strong> (<em>str</em>) &#8211; Variant annotation path to store annotation.</li>
<li><strong>code</strong> (<em>str</em>) &#8211; Annotation expression.</li>
<li><strong>config</strong> (<a class="reference internal" href="hail.TextTableConfig.html#hail.TextTableConfig" title="hail.TextTableConfig"><code class="xref py py-class docutils literal"><span class="pre">TextTableConfig</span></code></a>) &#8211; Configuration options for importing text files</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Annotated variant dataset.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_variants_table">
<code class="descname">annotate_variants_table</code><span class="sig-paren">(</span><em>path</em>, <em>variant_expr</em>, <em>root=None</em>, <em>code=None</em>, <em>config=&lt;hail.utils.TextTableConfig object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_variants_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_variants_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate variant with delimited text file (text table).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> (<em>str</em><em> or </em><em>list of str</em>) &#8211; Path to delimited text files.</li>
<li><strong>variant_expr</strong> (<em>str</em>) &#8211; Expression for Variant (key).</li>
<li><strong>root</strong> (<em>str</em>) &#8211; Variant annotation path to store text table.</li>
<li><strong>code</strong> (<em>str</em>) &#8211; Annotation expression.</li>
<li><strong>config</strong> (<a class="reference internal" href="hail.TextTableConfig.html#hail.TextTableConfig" title="hail.TextTableConfig"><code class="xref py py-class docutils literal"><span class="pre">TextTableConfig</span></code></a>) &#8211; Configuration options for importing text files</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Annotated variant dataset.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.annotate_variants_vds">
<code class="descname">annotate_variants_vds</code><span class="sig-paren">(</span><em>other</em>, <em>code=None</em>, <em>root=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.annotate_variants_vds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.annotate_variants_vds" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate variants with variant annotations from .vds file.</p>
<p><strong>Examples</strong></p>
<p>Import a second variant dataset with annotations to merge into <code class="docutils literal"><span class="pre">vds</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds1</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="s1">&#39;va = drop(va, anno1)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds2</span> <span class="o">=</span> <span class="p">(</span><span class="n">hc</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;data/example2.vds&quot;</span><span class="p">)</span>
<span class="gp">... </span>          <span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="s1">&#39;va = select(va, anno1, toKeep1, toKeep2, toKeep3)&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Copy the <code class="docutils literal"><span class="pre">anno1</span></code> annotation from <code class="docutils literal"><span class="pre">other</span></code> to <code class="docutils literal"><span class="pre">va.annot</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds1</span><span class="o">.</span><span class="n">annotate_variants_vds</span><span class="p">(</span><span class="n">vds2</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="s1">&#39;va.annot = vds.anno1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Merge the variant annotations from the two vds together and places them
at <code class="docutils literal"><span class="pre">va</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds1</span><span class="o">.</span><span class="n">annotate_variants_vds</span><span class="p">(</span><span class="n">vds2</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="s1">&#39;va = merge(va, vds)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Select a subset of the annotations from <code class="docutils literal"><span class="pre">other</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds1</span><span class="o">.</span><span class="n">annotate_variants_vds</span><span class="p">(</span><span class="n">vds2</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="s1">&#39;va.annotations = select(vds, toKeep1, toKeep2, toKeep3)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The previous expression is equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds1</span><span class="o">.</span><span class="n">annotate_variants_vds</span><span class="p">(</span><span class="n">vds2</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="s1">&#39;va.annotations.toKeep1 = vds.toKeep1, &#39;</span> <span class="o">+</span>
<span class="gp">... </span>                                      <span class="s1">&#39;va.annotations.toKeep2 = vds.toKeep2, &#39;</span> <span class="o">+</span>
<span class="gp">... </span>                                      <span class="s1">&#39;va.annotations.toKeep3 = vds.toKeep3&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>Using this method requires one of the two optional arguments: <code class="docutils literal"><span class="pre">code</span></code>
and <code class="docutils literal"><span class="pre">root</span></code>. They specify how to insert the annotations from <code class="docutils literal"><span class="pre">other</span></code>
into the this vds&#8217;s variant annotations.</p>
<p>The <code class="docutils literal"><span class="pre">root</span></code> argument copies all the variant annotations from <code class="docutils literal"><span class="pre">other</span></code>
to the specified annotation path.</p>
<p>The <code class="docutils literal"><span class="pre">code</span></code> argument expects an annotation expression whose scope
includes, <code class="docutils literal"><span class="pre">va</span></code>, the variant annotations in the current VDS, and <code class="docutils literal"><span class="pre">vds</span></code>,
the variant annotations in <code class="docutils literal"><span class="pre">other</span></code>.</p>
<p>VDSes with multi-allelic variants may produce surprising results because
all alternate alleles are considered part of the variant key. For
example:</p>
<ul class="simple">
<li>The variant <code class="docutils literal"><span class="pre">22:140012:A:T,TTT</span></code> will not be annotated by
<code class="docutils literal"><span class="pre">22:140012:A:T</span></code> or <code class="docutils literal"><span class="pre">22:140012:A:TTT</span></code></li>
<li>The variant <code class="docutils literal"><span class="pre">22:140012:A:T</span></code> will not be annotated by
<code class="docutils literal"><span class="pre">22:140012:A:T,TTT</span></code></li>
</ul>
<p>It is possible that an unsplit variant dataset contains no multiallelic
variants, so ignore any warnings Hail prints if you know that to be the
case.  Otherwise, run <a class="reference internal" href="#hail.VariantDataset.split_multi" title="hail.VariantDataset.split_multi"><code class="xref py py-meth docutils literal"><span class="pre">split_multi()</span></code></a> before
<a class="reference internal" href="#hail.VariantDataset.annotate_variants_vds" title="hail.VariantDataset.annotate_variants_vds"><code class="xref py py-meth docutils literal"><span class="pre">annotate_variants_vds()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>other</strong> (<a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><em>VariantDataset</em></a>) &#8211; Variant dataset to annotate with.</li>
<li><strong>root</strong> (<em>str</em>) &#8211; Sample annotation path to add variant annotations.</li>
<li><strong>code</strong> (<em>str</em>) &#8211; Annotation expression.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Annotated variant dataset.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.cache">
<code class="descname">cache</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.cache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark this variant dataset to be cached in memory.</p>
<p><a class="reference internal" href="#hail.VariantDataset.cache" title="hail.VariantDataset.cache"><code class="xref py py-meth docutils literal"><span class="pre">cache()</span></code></a> is the same as <a class="reference internal" href="#hail.VariantDataset.persist" title="hail.VariantDataset.persist"><code class="xref py py-func docutils literal"><span class="pre">persist(&quot;MEMORY_ONLY&quot;)</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.concordance">
<code class="descname">concordance</code><span class="sig-paren">(</span><em>right</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.concordance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.concordance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate call concordance with another variant dataset.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Example</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">concordance_pair</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">concordance</span><span class="p">(</span><span class="n">hc</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;data/example2.vds&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>The <cite>concordance</cite> command computes the genotype call concordance between two bialellic variant datasets. The concordance
results are stored in a global annotation of type Array[Array[Long]], which is a 5x5 table of counts with the
following mapping:</p>
<ol class="arabic simple" start="0">
<li>No Data (missing variant)</li>
<li>No Call (missing genotype call)</li>
<li>Hom Ref</li>
<li>Heterozygous</li>
<li>Hom Var</li>
</ol>
<p>The first index in array is the left dataset, the second is the right. For example, <code class="docutils literal"><span class="pre">concordance[3][2]</span></code> is the count of
genotypes which were heterozygous on the left and homozygous reference on the right. This command produces two new datasets
and returns them as a Python tuple. The first dataset contains the concordance statistics per variant. This dataset
<strong>contains no genotypes</strong> (sites-only). It contains a new variant annotation, <code class="docutils literal"><span class="pre">va.concordance</span></code>. This is the concordance
table for each variant in the outer join of the two datasets &#8211; if the variant is present in only one dataset, all
of the counts will lie in the axis <code class="docutils literal"><span class="pre">va.concordance[0][:]</span></code> (if it is missing on the left) or <code class="docutils literal"><span class="pre">va.concordance.map(x</span> <span class="pre">=&gt;</span> <span class="pre">x[0])</span></code>
(if it is missing on the right). The variant annotations from the left and right datasets are included as <code class="docutils literal"><span class="pre">va.left</span></code>
and <code class="docutils literal"><span class="pre">va.right</span></code> &#8211; these will be missing on one side if a variant was only present in one dataset. This vds also contains
the global concordance statistics in <code class="docutils literal"><span class="pre">global.concordance</span></code>, as well as the left and right global annotations in <code class="docutils literal"><span class="pre">global.left</span></code>
and <code class="docutils literal"><span class="pre">global.right</span></code>. The second dataset contains the concordance statistics per sample. This dataset <strong>contains no variants</strong>
(samples-only). It contains a new sample annotation, <code class="docutils literal"><span class="pre">sa.concordance</span></code>. This is a concordance table whose sum is the total number
of variants in the outer join of the two datasets. The sum <code class="docutils literal"><span class="pre">sa[0].sum</span></code> is equal to the number of variants in the right dataset
but not the left, and the sum <code class="docutils literal"><span class="pre">sa.concordance.map(x</span> <span class="pre">=&gt;</span> <span class="pre">x[0]).sum)</span></code> is equal to the number of variants in the left dataset but
not the right. The sample annotations from the left and right datasets are included as <code class="docutils literal"><span class="pre">sa.left</span></code> and <code class="docutils literal"><span class="pre">sa.right</span></code>. This dataset
also contains the global concordance statistics in <code class="docutils literal"><span class="pre">global.concordance</span></code>, as well as the left and right global annotations in
<code class="docutils literal"><span class="pre">global.left</span></code> and <code class="docutils literal"><span class="pre">global.right</span></code>.</p>
<p><strong>Notes</strong></p>
<p>Performs inner join on variants, outer join on samples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>right</strong> (<a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a>) &#8211; right hand variant dataset for concordance</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The global concordance stats, a variant dataset with sample concordance
statistics, and a variant dataset with variant concordance statistics.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">(list of list of int, <a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a>, <a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a>)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.count">
<code class="descname">count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.count"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of samples and variants in the dataset.</p>
<p><strong>Examples</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span><span class="p">,</span> <span class="n">variants</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>This is also the fastest way to force evaluation of a Hail pipeline.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The sample and variant counts.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">(int, int)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.count_variants">
<code class="descname">count_variants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.count_variants"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.count_variants" title="Permalink to this definition">¶</a></dt>
<dd><p>Count number of variants in variant dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">long</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.deduplicate">
<code class="descname">deduplicate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.deduplicate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.deduplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove duplicate variants.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Deduplicated variant dataset.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.delete_va_attribute">
<code class="descname">delete_va_attribute</code><span class="sig-paren">(</span><em>ann_path</em>, <em>attribute</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.delete_va_attribute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.delete_va_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes an attribute from a variant annotation field.
Attributes are key/value pairs that can be attached to a variant annotation field.</p>
<p>The following attributes are read from the VCF header when importing a VCF and written
to the VCF header when exporting a VCF:
- INFO fields attributes (attached to (<cite>va.info.*</cite>)):</p>
<blockquote>
<div><ul class="simple">
<li>&#8216;Number&#8217;: The arity of the field. Can take values</li>
</ul>
<p><cite>0</cite> (Boolean flag),
<cite>1</cite> (single value),
<cite>R</cite> (one value per allele, including the reference),
<cite>A</cite> (one value per non-reference allele),
<cite>G</cite> (one value per genotype), and
<cite>.</cite> (any number of values)</p>
<blockquote>
<div><ul class="simple">
<li>When importing: The value in read from the VCF INFO field definition</li>
<li>When exporting: The default value is <cite>0</cite> for <strong>Boolean</strong>, <cite>.</cite> for <strong>Arrays</strong> and 1 for all other types</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>&#8216;Description&#8217; (default is &#8216;&#8217;)</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>FILTER entries in the VCF header are generated based on the attributes of <cite>va.filters</cite>.</li>
</ul>
<p>Each key/value pair in the attributes will generate a FILTER entry in the VCF with ID = key and Description = value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ann_path</strong> (<em>str</em>) &#8211; Variant annotation path starting with &#8216;va&#8217;, period-delimited.</li>
<li><strong>attribute</strong> (<em>str</em>) &#8211; The attribute to remove (key).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Annotated dataset with the updated variant annotation without the attribute.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.drop_samples">
<code class="descname">drop_samples</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.drop_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.drop_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all samples from variant dataset.</p>
<p>The variants, variant annotations, and global annnotations will remain,
producing a sites-only variant dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Sites-only variant dataset.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.drop_variants">
<code class="descname">drop_variants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.drop_variants"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.drop_variants" title="Permalink to this definition">¶</a></dt>
<dd><p>Discard all variants, variant annotations and genotypes.</p>
<p>Samples, sample annotations and global annotations are retained. This
is the same as <a class="reference internal" href="#hail.VariantDataset.filter_variants_expr" title="hail.VariantDataset.filter_variants_expr"><code class="xref py py-func docutils literal"><span class="pre">filter_variants_expr('false')</span></code></a>, but much faster.</p>
<p><strong>Examples</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">drop_variants</span><span class="p">()</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Samples-only variant dataset.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.export_gen">
<code class="descname">export_gen</code><span class="sig-paren">(</span><em>output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.export_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.export_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Export variant dataset as GEN and SAMPLE file.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Examples</strong></p>
<p>Import dosage data, filter variants based on INFO score, and export data to a GEN and SAMPLE file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds3</span> <span class="o">=</span> <span class="n">hc</span><span class="o">.</span><span class="n">import_bgen</span><span class="p">(</span><span class="s2">&quot;data/example3.bgen&quot;</span><span class="p">,</span> <span class="n">sample_file</span><span class="o">=</span><span class="s2">&quot;data/example3.sample&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">vds3</span><span class="o">.</span><span class="n">filter_variants_expr</span><span class="p">(</span><span class="s2">&quot;gs.infoScore().score &gt;= 0.9&quot;</span><span class="p">)</span>
<span class="gp">... </span>     <span class="o">.</span><span class="n">export_gen</span><span class="p">(</span><span class="s2">&quot;output/infoscore_filtered&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>Writes out the internal VDS to a GEN and SAMPLE fileset in the <a class="reference external" href="http://www.stats.ox.ac.uk/%7Emarchini/software/gwas/file_format.html">Oxford spec</a>.</p>
<p>The first 6 columns of the resulting GEN file are the following:</p>
<ul class="simple">
<li>Chromosome (<code class="docutils literal"><span class="pre">v.contig</span></code>)</li>
<li>Variant ID (<code class="docutils literal"><span class="pre">va.varid</span></code> if defined, else Chromosome:Position:Ref:Alt)</li>
<li>rsID (<code class="docutils literal"><span class="pre">va.rsid</span></code> if defined, else &#8221;.&#8221;)</li>
<li>position (<code class="docutils literal"><span class="pre">v.start</span></code>)</li>
<li>reference allele (<code class="docutils literal"><span class="pre">v.ref</span></code>)</li>
<li>alternate allele (<code class="docutils literal"><span class="pre">v.alt</span></code>)</li>
</ul>
<p>Probability dosages:</p>
<ul class="simple">
<li>3 probabilities per sample <code class="docutils literal"><span class="pre">(pHomRef,</span> <span class="pre">pHet,</span> <span class="pre">pHomVar)</span></code>.</li>
<li>Any filtered genotypes will be output as <code class="docutils literal"><span class="pre">(0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0)</span></code>.</li>
<li>If the input data contained Phred-scaled likelihoods, the probabilities in the GEN file will be the normalized genotype probabilities assuming a uniform prior.</li>
<li>If the input data did not have genotype probabilities such as data imported using <a class="reference internal" href="hail.HailContext.html#hail.HailContext.import_plink" title="hail.HailContext.import_plink"><code class="xref py py-meth docutils literal"><span class="pre">import_plink()</span></code></a>, all genotype probabilities will be <code class="docutils literal"><span class="pre">(0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0)</span></code>.</li>
</ul>
<p>The sample file has 3 columns:</p>
<ul class="simple">
<li>ID_1 and ID_2 are identical and set to the sample ID (<code class="docutils literal"><span class="pre">s</span></code>).</li>
<li>The third column (&#8220;missing&#8221;) is set to 0 for all samples.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>output</strong> (<em>str</em>) &#8211; Output file base.  Will write GEN and SAMPLE files.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.export_genotypes">
<code class="descname">export_genotypes</code><span class="sig-paren">(</span><em>output</em>, <em>expr</em>, <em>types=False</em>, <em>export_ref=False</em>, <em>export_missing=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.export_genotypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.export_genotypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Export genotype-level information to delimited text file.</p>
<p><strong>Examples</strong></p>
<p>Export genotype information with identifiers that form the header:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span><span class="o">.</span><span class="n">export_genotypes</span><span class="p">(</span><span class="s1">&#39;output/genotypes.tsv&#39;</span><span class="p">,</span> <span class="s1">&#39;SAMPLE=s, VARIANT=v, GQ=g.gq, DP=g.dp, ANNO1=va.anno1, ANNO2=va.anno2&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Export the same information without identifiers, resulting in a file with no header:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span><span class="o">.</span><span class="n">export_genotypes</span><span class="p">(</span><span class="s1">&#39;output/genotypes.tsv&#39;</span><span class="p">,</span> <span class="s1">&#39;s, v, g.gq, g.dp, va.anno1, va.anno2&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p><a class="reference internal" href="#hail.VariantDataset.export_genotypes" title="hail.VariantDataset.export_genotypes"><code class="xref py py-meth docutils literal"><span class="pre">export_genotypes()</span></code></a> outputs one line per cell (genotype) in the data set, though HomRef and missing genotypes are not output by default if the genotype schema is equal to <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a>. Use the <code class="docutils literal"><span class="pre">export_ref</span></code> and <code class="docutils literal"><span class="pre">export_missing</span></code> parameters to force export of HomRef and missing genotypes, respectively.</p>
<p>The <code class="docutils literal"><span class="pre">expr</span></code> argument is a comma-separated list of fields or expressions, all of which must be of the form <code class="docutils literal"><span class="pre">IDENTIFIER</span> <span class="pre">=</span> <span class="pre">&lt;expression&gt;</span></code>, or else of the form <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code>.  If some fields have identifiers and some do not, Hail will throw an exception. The accessible namespace includes <code class="docutils literal"><span class="pre">g</span></code>, <code class="docutils literal"><span class="pre">s</span></code>, <code class="docutils literal"><span class="pre">sa</span></code>, <code class="docutils literal"><span class="pre">v</span></code>, <code class="docutils literal"><span class="pre">va</span></code>, and <code class="docutils literal"><span class="pre">global</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If the genotype schema does not have the type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a>, all genotypes will be exported unless the value of <code class="docutils literal"><span class="pre">g</span></code> is missing.
Use <a class="reference internal" href="#hail.VariantDataset.filter_genotypes" title="hail.VariantDataset.filter_genotypes"><code class="xref py py-meth docutils literal"><span class="pre">filter_genotypes()</span></code></a> to filter out genotypes based on an expression before exporting.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>output</strong> (<em>str</em>) &#8211; Output path.</li>
<li><strong>expr</strong> (<em>str</em>) &#8211; Export expression for values to export.</li>
<li><strong>types</strong> (<em>bool</em>) &#8211; Write types of exported columns to a file at (output + &#8221;.types&#8221;)</li>
<li><strong>export_ref</strong> (<em>bool</em>) &#8211; If True, export reference genotypes. Only applicable if the genotype schema is <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a>.</li>
<li><strong>export_missing</strong> (<em>bool</em>) &#8211; If True, export missing genotypes.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.export_plink">
<code class="descname">export_plink</code><span class="sig-paren">(</span><em>output</em>, <em>fam_expr='id = s'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.export_plink"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.export_plink" title="Permalink to this definition">¶</a></dt>
<dd><p>Export variant dataset as <a class="reference external" href="https://www.cog-genomics.org/plink2/formats">PLINK2</a> BED, BIM and FAM.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Examples</strong></p>
<p>Import data from a VCF file, split multi-allelic variants, and export to a PLINK binary file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span><span class="o">.</span><span class="n">split_multi</span><span class="p">()</span><span class="o">.</span><span class="n">export_plink</span><span class="p">(</span><span class="s1">&#39;output/plink&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p><code class="docutils literal"><span class="pre">fam_expr</span></code> can be used to set the fields in the FAM file.
The following fields can be assigned:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">famID:</span> <span class="pre">String</span></code></li>
<li><code class="docutils literal"><span class="pre">id:</span> <span class="pre">String</span></code></li>
<li><code class="docutils literal"><span class="pre">matID:</span> <span class="pre">String</span></code></li>
<li><code class="docutils literal"><span class="pre">patID:</span> <span class="pre">String</span></code></li>
<li><code class="docutils literal"><span class="pre">isFemale:</span> <span class="pre">Boolean</span></code></li>
<li><code class="docutils literal"><span class="pre">isCase:</span> <span class="pre">Boolean</span></code> or <code class="docutils literal"><span class="pre">qPheno:</span> <span class="pre">Double</span></code></li>
</ul>
<p>If no assignment is given, the value is missing and the
missing value is used: <code class="docutils literal"><span class="pre">0</span></code> for IDs and sex and <code class="docutils literal"><span class="pre">-9</span></code> for
phenotype.  Only one of <code class="docutils literal"><span class="pre">isCase</span></code> or <code class="docutils literal"><span class="pre">qPheno</span></code> can be
assigned.</p>
<p><code class="docutils literal"><span class="pre">fam_expr</span></code> is in sample context only and the following
symbols are in scope:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">s</span></code> (<em>Sample</em>): <span class="xref std std-ref">sample</span></li>
<li><code class="docutils literal"><span class="pre">sa</span></code>: sample annotations</li>
<li><code class="docutils literal"><span class="pre">global</span></code>: global annotations</li>
</ul>
<p>The BIM file ID field is set to <code class="docutils literal"><span class="pre">CHR:POS:REF:ALT</span></code>.</p>
<p>This code:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span><span class="o">.</span><span class="n">split_multi</span><span class="p">()</span><span class="o">.</span><span class="n">export_plink</span><span class="p">(</span><span class="s1">&#39;output/plink&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>will behave similarly to the PLINK VCF conversion command</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>plink --vcf /path/to/file.vcf --make-bed --out sample --const-fid --keep-allele-order
</pre></div>
</div>
<p>except:</p>
<ul class="simple">
<li>The order among split multi-allelic alternatives in the BED
file may disagree.</li>
<li>PLINK uses the rsID for the BIM file ID.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>output</strong> (<em>str</em>) &#8211; Output file base.  Will write BED, BIM, and FAM files.</li>
<li><strong>fam_expr</strong> (<em>str</em>) &#8211; Expression for FAM file fields.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.export_samples">
<code class="descname">export_samples</code><span class="sig-paren">(</span><em>output</em>, <em>expr</em>, <em>types=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.export_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.export_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Export sample information to delimited text file.</p>
<p><strong>Examples</strong></p>
<p>Export some sample QC metrics:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">sample_qc</span><span class="p">()</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">export_samples</span><span class="p">(</span><span class="s1">&#39;output/samples.tsv&#39;</span><span class="p">,</span> <span class="s1">&#39;SAMPLE = s, CALL_RATE = sa.qc.callRate, NHET = sa.qc.nHet&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>This will produce a file with a header and three columns.  To
produce a file with no header, just leave off the assignment
to the column identifier:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">sample_qc</span><span class="p">()</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">export_samples</span><span class="p">(</span><span class="s1">&#39;output/samples.tsv&#39;</span><span class="p">,</span> <span class="s1">&#39;s, sa.qc.rTiTv&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>One line per sample will be exported.  As <a class="reference internal" href="#hail.VariantDataset.export_samples" title="hail.VariantDataset.export_samples"><code class="xref py py-meth docutils literal"><span class="pre">export_samples()</span></code></a> runs in sample context, the following symbols are in scope:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">s</span></code> (<em>Sample</em>): <span class="xref std std-ref">sample</span></li>
<li><code class="docutils literal"><span class="pre">sa</span></code>: sample annotations</li>
<li><code class="docutils literal"><span class="pre">global</span></code>: global annotations</li>
<li><code class="docutils literal"><span class="pre">gs</span></code> (<em>Aggregable[Genotype]</em>): aggregable of <a class="reference internal" href="types.html#genotype"><span class="std std-ref">Genotype</span></a> for sample <code class="docutils literal"><span class="pre">s</span></code></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>output</strong> (<em>str</em>) &#8211; Output file.</li>
<li><strong>expr</strong> (<em>str</em>) &#8211; Export expression for values to export.</li>
<li><strong>types</strong> (<em>bool</em>) &#8211; Write types of exported columns to a file at (output + &#8221;.types&#8221;).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.export_variants">
<code class="descname">export_variants</code><span class="sig-paren">(</span><em>output</em>, <em>expr</em>, <em>types=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.export_variants"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.export_variants" title="Permalink to this definition">¶</a></dt>
<dd><p>Export variant information to delimited text file.</p>
<p><strong>Examples</strong></p>
<p>Export a four column TSV with <code class="docutils literal"><span class="pre">v</span></code>, <code class="docutils literal"><span class="pre">va.pass</span></code>, <code class="docutils literal"><span class="pre">va.filters</span></code>, and
one computed field: <code class="docutils literal"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">va.qc.callRate</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span><span class="o">.</span><span class="n">export_variants</span><span class="p">(</span><span class="s1">&#39;output/file.tsv&#39;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="s1">&#39;VARIANT = v, PASS = va.pass, FILTERS = va.filters, MISSINGNESS = 1 - va.qc.callRate&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>It is also possible to export without identifiers, which will result in
a file with no header. In this case, the expressions should look like
the examples below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span><span class="o">.</span><span class="n">export_variants</span><span class="p">(</span><span class="s1">&#39;output/file.tsv&#39;</span><span class="p">,</span> <span class="s1">&#39;v, va.pass, va.qc.AF&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If any field is named, all fields must be named.</p>
</div>
<p>In the common case that a group of annotations needs to be exported (for
example, the annotations produced by <code class="docutils literal"><span class="pre">variantqc</span></code>), one can use the
<code class="docutils literal"><span class="pre">struct.*</span></code> syntax.  This syntax produces one column per field in the
struct, and names them according to the struct field name.</p>
<p>For example, the following invocation (assuming <code class="docutils literal"><span class="pre">va.qc</span></code> was generated
by <a class="reference internal" href="#hail.VariantDataset.variant_qc" title="hail.VariantDataset.variant_qc"><code class="xref py py-meth docutils literal"><span class="pre">variant_qc()</span></code></a>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span><span class="o">.</span><span class="n">export_variants</span><span class="p">(</span><span class="s1">&#39;output/file.tsv&#39;</span><span class="p">,</span> <span class="s1">&#39;variant = v, va.qc.*&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>will produce the following set of columns:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>variant  callRate  AC  AF  nCalled  ...
</pre></div>
</div>
<p>Note that using the <code class="docutils literal"><span class="pre">.*</span></code> syntax always results in named arguments, so it
is not possible to export header-less files in this manner.  However,
naming the &#8220;splatted&#8221; struct will apply the name in front of each column
like so:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span><span class="o">.</span><span class="n">export_variants</span><span class="p">(</span><span class="s1">&#39;output/file.tsv&#39;</span><span class="p">,</span> <span class="s1">&#39;variant = v, QC = va.qc.*&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>which produces these columns:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>variant  QC.callRate  QC.AC  QC.AF  QC.nCalled  ...
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>This module takes a comma-delimited list of fields or expressions to
print. These fields will be printed in the order they appear in the
expression in the header and on each line.</p>
<p>One line per variant in the VDS will be printed.  The accessible namespace includes:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">v</span></code> (<em>Variant</em>): <a class="reference internal" href="types.html#variant"><span class="std std-ref">Variant</span></a></li>
<li><code class="docutils literal"><span class="pre">va</span></code>: variant annotations</li>
<li><code class="docutils literal"><span class="pre">global</span></code>: global annotations</li>
<li><code class="docutils literal"><span class="pre">gs</span></code> (<em>Aggregable[Genotype]</em>): aggregable of <a class="reference internal" href="types.html#genotype"><span class="std std-ref">Genotype</span></a> for variant <code class="docutils literal"><span class="pre">v</span></code></li>
</ul>
<p><strong>Designating output with an expression</strong></p>
<p>Much like the filtering methods, exporting allows flexible expressions
to be written on the command line. While the filtering methods expect an
expression that evaluates to true or false, this method expects a
comma-separated list of fields to print. These fields <em>must</em> take the
form <code class="docutils literal"><span class="pre">IDENTIFIER</span> <span class="pre">=</span> <span class="pre">&lt;expression&gt;</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>output</strong> (<em>str</em>) &#8211; Output file.</li>
<li><strong>expr</strong> (<em>str</em>) &#8211; Export expression for values to export.</li>
<li><strong>types</strong> (<em>bool</em>) &#8211; Write types of exported columns to a file at (output + &#8221;.types&#8221;)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.export_vcf">
<code class="descname">export_vcf</code><span class="sig-paren">(</span><em>output</em>, <em>append_to_header=None</em>, <em>export_pp=False</em>, <em>parallel=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.export_vcf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.export_vcf" title="Permalink to this definition">¶</a></dt>
<dd><p>Export variant dataset as a .vcf or .vcf.bgz file.</p>
<p><strong>Examples</strong></p>
<p>Export to VCF as a block-compressed file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span><span class="o">.</span><span class="n">export_vcf</span><span class="p">(</span><span class="s1">&#39;output/example.vcf.bgz&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p><a class="reference internal" href="#hail.VariantDataset.export_vcf" title="hail.VariantDataset.export_vcf"><code class="xref py py-meth docutils literal"><span class="pre">export_vcf()</span></code></a> writes the VDS to disk in VCF format as described in the <a class="reference external" href="https://samtools.github.io/hts-specs/VCFv4.2.pdf">VCF 4.2 spec</a>.</p>
<p>Use the <code class="docutils literal"><span class="pre">.vcf.bgz</span></code> extension rather than <code class="docutils literal"><span class="pre">.vcf</span></code> in the output file name for <a class="reference external" href="http://www.htslib.org/doc/tabix.html">blocked GZIP</a> compression.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We strongly recommended compressed (<code class="docutils literal"><span class="pre">.bgz</span></code> extension) and parallel output (<code class="docutils literal"><span class="pre">parallel=True</span></code>) when exporting large VCFs.</p>
</div>
<p>Consider the workflow of importing VCF to VDS and immediately exporting VDS to VCF:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span><span class="o">.</span><span class="n">export_vcf</span><span class="p">(</span><span class="s1">&#39;output/example_out.vcf&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>example_out.vcf</em> header will contain the FORMAT, FILTER, and INFO lines present in <em>example.vcf</em>. However, it will <em>not</em> contain CONTIG lines or lines added by external tools (such as bcftools and GATK) unless they are explicitly inserted using the <code class="docutils literal"><span class="pre">append_to_header</span></code> option.</p>
<p>Hail only exports the contents of <code class="docutils literal"><span class="pre">va.info</span></code> to the INFO field. No other annotations besides <code class="docutils literal"><span class="pre">va.info</span></code> are exported.</p>
<p>The genotype schema must have the type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> or <a class="reference internal" href="expr/hail.expr.TStruct.html#hail.expr.TStruct" title="hail.expr.TStruct"><code class="xref py py-class docutils literal"><span class="pre">TStruct</span></code></a>. If the type is
<a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a>, then the FORMAT fields will be GT, AD, DP, GQ, and PL (or PP if <code class="docutils literal"><span class="pre">export_pp</span></code> is True).
If the type is <a class="reference internal" href="expr/hail.expr.TStruct.html#hail.expr.TStruct" title="hail.expr.TStruct"><code class="xref py py-class docutils literal"><span class="pre">TStruct</span></code></a>, then the exported FORMAT fields will be the names of each field of the Struct.
Each field must have a type of String, Char, Int, Double, or Call. Arrays and Sets are also allowed as long as they are not nested.
For example, a field with type <code class="docutils literal"><span class="pre">Array[Int]</span></code> can be exported but not a field with type <code class="docutils literal"><span class="pre">Array[Array[Int]]</span></code>.
Nested Structs are also not allowed.</p>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p>If samples or genotypes are filtered after import, the value stored in <code class="docutils literal"><span class="pre">va.info.AC</span></code> value may no longer reflect the number of called alternate alleles in the filtered VDS. If the filtered VDS is then exported to VCF, downstream tools may produce erroneous results. The solution is to create new annotations in <code class="docutils literal"><span class="pre">va.info</span></code> or overwrite existing annotations. For example, in order to produce an accurate <code class="docutils literal"><span class="pre">AC</span></code> field, one can run <a class="reference internal" href="#hail.VariantDataset.variant_qc" title="hail.VariantDataset.variant_qc"><code class="xref py py-meth docutils literal"><span class="pre">variant_qc()</span></code></a> and copy the <code class="docutils literal"><span class="pre">va.qc.AC</span></code> field to <code class="docutils literal"><span class="pre">va.info.AC</span></code>:</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">filter_genotypes</span><span class="p">(</span><span class="s1">&#39;g.gq &gt;= 20&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">variant_qc</span><span class="p">()</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="s1">&#39;va.info.AC = va.qc.AC&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">export_vcf</span><span class="p">(</span><span class="s1">&#39;output/example.vcf.bgz&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>output</strong> (<em>str</em>) &#8211; Path of .vcf file to write.</li>
<li><strong>append_to_header</strong> (<em>str</em><em> or </em><em>None</em>) &#8211; Path of file to append to VCF header.</li>
<li><strong>export_pp</strong> (<em>bool</em>) &#8211; If True, export linear-scaled probabilities (Hail&#8217;s <cite>pp</cite> field on genotype) as the VCF PP FORMAT field.</li>
<li><strong>parallel</strong> (<em>bool</em>) &#8211; If True, return a set of VCF files (one per partition) rather than serially concatenating these files.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.file_version">
<code class="descname">file_version</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.file_version"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.file_version" title="Permalink to this definition">¶</a></dt>
<dd><p>File version of variant dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.filter_alleles">
<code class="descname">filter_alleles</code><span class="sig-paren">(</span><em>condition</em>, <em>annotation='va = va'</em>, <em>subset=True</em>, <em>keep=True</em>, <em>filter_altered_genotypes=False</em>, <em>max_shift=100</em>, <em>keep_star=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.filter_alleles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.filter_alleles" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter a user-defined set of alternate alleles for each variant.
If all alternate alleles of a variant are filtered, the
variant itself is filtered.  The condition expression is
evaluated for each alternate allele, but not for
the reference allele (i.e. <code class="docutils literal"><span class="pre">aIndex</span></code> will never be zero).</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Examples</strong></p>
<p>To remove alternate alleles with zero allele count and
update the alternate allele count annotation with the new
indices:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">filter_alleles</span><span class="p">(</span><span class="s1">&#39;va.info.AC[aIndex - 1] == 0&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">annotation</span><span class="o">=</span><span class="s1">&#39;va.info.AC = aIndices[1:].map(i =&gt; va.info.AC[i - 1])&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we skip the first element of <code class="docutils literal"><span class="pre">aIndices</span></code> because
we are mapping between the old and new <em>allele</em> indices, not
the <em>alternate allele</em> indices.</p>
<p><strong>Notes</strong></p>
<p>If <code class="docutils literal"><span class="pre">filter_altered_genotypes</span></code> is true, genotypes that contain filtered-out alleles are set to missing.</p>
<p><a class="reference internal" href="#hail.VariantDataset.filter_alleles" title="hail.VariantDataset.filter_alleles"><code class="xref py py-meth docutils literal"><span class="pre">filter_alleles()</span></code></a> implements two algorithms for filtering alleles: subset and downcode. We will illustrate their
behavior on the example genotype below when filtering the first alternate allele (allele 1) at a site with 1 reference
allele and 2 alternate alleles.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>GT: 1/2
GQ: 10
AD: 0,50,35

0 | 1000
1 | 1000   10
2 | 1000   0     20
  +-----------------
     0     1     2
</pre></div>
</div>
<p><strong>Subset algorithm</strong></p>
<p>The subset algorithm (the default, <code class="docutils literal"><span class="pre">subset=True</span></code>) subsets the
AD and PL arrays (i.e. removes entries corresponding to filtered alleles)
and then sets GT to the genotype with the minimum PL.  Note
that if the genotype changes (as in the example), the PLs
are re-normalized (shifted) so that the most likely genotype has a PL of
0.  Qualitatively, subsetting corresponds to the belief
that the filtered alleles are not real so we should discard any
probability mass associated with them.</p>
<p>The subset algorithm would produce the following:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>GT: 1/1
GQ: 980
AD: 0,50

0 | 980
1 | 980    0
  +-----------
     0      1
</pre></div>
</div>
<p>In summary:</p>
<ul class="simple">
<li>GT: Set to most likely genotype based on the PLs ignoring the filtered allele(s).</li>
<li>AD: The filtered alleles&#8217; columns are eliminated, e.g., filtering alleles 1 and 2 transforms <code class="docutils literal"><span class="pre">25,5,10,20</span></code> to <code class="docutils literal"><span class="pre">25,20</span></code>.</li>
<li>DP: No change.</li>
<li>PL: The filtered alleles&#8217; columns are eliminated and the remaining columns shifted so the minimum value is 0.</li>
<li>GQ: The second-lowest PL (after shifting).</li>
</ul>
<p><strong>Downcode algorithm</strong></p>
<p>The downcode algorithm (<code class="docutils literal"><span class="pre">subset=False</span></code>) recodes occurances of filtered alleles
to occurances of the reference allele (e.g. 1 -&gt; 0 in our example). So the depths of filtered alleles in the AD field
are added to the depth of the reference allele. Where downcodeing filtered alleles merges distinct genotypes, the minimum PL is used (since PL is on a log scale, this roughly corresponds to adding probabilities). The PLs
are then re-normalized (shifted) so that the most likely genotype has a PL of 0, and GT is set to this genotype.
If an allele is filtered, this algorithm acts similarly to <a class="reference internal" href="#hail.VariantDataset.split_multi" title="hail.VariantDataset.split_multi"><code class="xref py py-meth docutils literal"><span class="pre">split_multi()</span></code></a>.</p>
<p>The downcoding algorithm would produce the following:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>GT: 0/1
GQ: 10
AD: 35,50

0 | 20
1 | 0    10
  +-----------
    0    1
</pre></div>
</div>
<p>In summary:</p>
<ul class="simple">
<li>GT: Downcode filtered alleles to reference.</li>
<li>AD: The filtered alleles&#8217; columns are eliminated and their value is added to the reference, e.g., filtering alleles 1 and 2 transforms <code class="docutils literal"><span class="pre">25,5,10,20</span></code> to <code class="docutils literal"><span class="pre">40,20</span></code>.</li>
<li>DP: No change.</li>
<li>PL: Downcode filtered alleles to reference, combine PLs using minimum for each overloaded genotype, and shift so the overall minimum PL is 0.</li>
<li>GQ: The second-lowest PL (after shifting).</li>
</ul>
<p><strong>Expression Variables</strong></p>
<p>The following symbols are in scope for <code class="docutils literal"><span class="pre">condition</span></code>:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">v</span></code> (<em>Variant</em>): <a class="reference internal" href="types.html#variant"><span class="std std-ref">Variant</span></a></li>
<li><code class="docutils literal"><span class="pre">va</span></code>: variant annotations</li>
<li><code class="docutils literal"><span class="pre">aIndex</span></code> (<em>Int</em>): the index of the allele being tested</li>
</ul>
<p>The following symbols are in scope for <code class="docutils literal"><span class="pre">annotation</span></code>:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">v</span></code> (<em>Variant</em>): <a class="reference internal" href="types.html#variant"><span class="std std-ref">Variant</span></a></li>
<li><code class="docutils literal"><span class="pre">va</span></code>: variant annotations</li>
<li><code class="docutils literal"><span class="pre">aIndices</span></code> (<em>Array[Int]</em>): the array of old indices (such that <code class="docutils literal"><span class="pre">aIndices[newIndex]</span> <span class="pre">=</span> <span class="pre">oldIndex</span></code> and <code class="docutils literal"><span class="pre">aIndices[0]</span> <span class="pre">=</span> <span class="pre">0</span></code>)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>condition</strong> (<em>str</em>) &#8211; Filter expression involving v (variant), va (variant annotations), and aIndex (allele index)</li>
<li><strong>annotation</strong> (<em>str</em>) &#8211; Annotation modifying expression involving v (new variant), va (old variant annotations),
and aIndices (maps from new to old indices)</li>
<li><strong>subset</strong> (<em>bool</em>) &#8211; If true, subsets PL and AD, otherwise downcodes the PL and AD.
Genotype and GQ are set based on the resulting PLs.</li>
<li><strong>keep</strong> (<em>bool</em>) &#8211; If true, keep variants matching condition</li>
<li><strong>filter_altered_genotypes</strong> (<em>bool</em>) &#8211; If true, genotypes that contain filtered-out alleles are set to missing.</li>
<li><strong>max_shift</strong> (<em>int</em>) &#8211; maximum number of base pairs by which
a split variant can move.  Affects memory usage, and will
cause Hail to throw an error if a variant that moves further
is encountered.</li>
<li><strong>keepStar</strong> (<em>bool</em>) &#8211; If true, keep variants where the only allele left is a <code class="docutils literal"><span class="pre">*</span></code> allele.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Filtered variant dataset.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.filter_genotypes">
<code class="descname">filter_genotypes</code><span class="sig-paren">(</span><em>condition</em>, <em>keep=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.filter_genotypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.filter_genotypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter genotypes based on expression.</p>
<p><strong>Examples</strong></p>
<p>Filter genotypes by allele balance dependent on genotype call:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">filter_genotypes</span><span class="p">(</span><span class="s1">&#39;let ab = g.ad[1] / g.ad.sum() in &#39;</span> <span class="o">+</span>
<span class="gp">... </span>                     <span class="s1">&#39;((g.isHomRef() &amp;&amp; ab &lt;= 0.1) || &#39;</span> <span class="o">+</span>
<span class="gp">... </span>                     <span class="s1">&#39;(g.isHet() &amp;&amp; ab &gt;= 0.25 &amp;&amp; ab &lt;= 0.75) || &#39;</span> <span class="o">+</span>
<span class="gp">... </span>                     <span class="s1">&#39;(g.isHomVar() &amp;&amp; ab &gt;= 0.9))&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p><code class="docutils literal"><span class="pre">condition</span></code> is in genotype context so the following symbols are in scope:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">s</span></code> (<em>Sample</em>): <span class="xref std std-ref">sample</span></li>
<li><code class="docutils literal"><span class="pre">v</span></code> (<em>Variant</em>): <a class="reference internal" href="types.html#variant"><span class="std std-ref">Variant</span></a></li>
<li><code class="docutils literal"><span class="pre">sa</span></code>: sample annotations</li>
<li><code class="docutils literal"><span class="pre">va</span></code>: variant annotations</li>
<li><code class="docutils literal"><span class="pre">global</span></code>: global annotations</li>
</ul>
<p>For more information, see the documentation on <a class="reference external" href="overview.html#">data representation, annotations</a>, and
the <a class="reference external" href="exprlang.html">expression language</a>.</p>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">When <code class="docutils literal"><span class="pre">condition</span></code> evaluates to missing, the genotype will be removed regardless of whether <code class="docutils literal"><span class="pre">keep=True</span></code> or <code class="docutils literal"><span class="pre">keep=False</span></code>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>condition</strong> (<em>str</em>) &#8211; Expression for filter condition.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Filtered variant dataset.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.filter_multi">
<code class="descname">filter_multi</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.filter_multi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.filter_multi" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter out multi-allelic sites.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p>This method is much less computationally expensive than
<a class="reference internal" href="#hail.VariantDataset.split_multi" title="hail.VariantDataset.split_multi"><code class="xref py py-meth docutils literal"><span class="pre">split_multi()</span></code></a>, and can also be used to produce
a variant dataset that can be used with methods that do not
support multiallelic variants.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Dataset with no multiallelic sites, which can
be used for biallelic-only methods.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.filter_samples_expr">
<code class="descname">filter_samples_expr</code><span class="sig-paren">(</span><em>condition</em>, <em>keep=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.filter_samples_expr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.filter_samples_expr" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter samples based on expression.</p>
<p><strong>Examples</strong></p>
<p>Filter samples by phenotype (assumes sample annotation <em>sa.isCase</em> exists and is a Boolean variable):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">filter_samples_expr</span><span class="p">(</span><span class="s2">&quot;sa.isCase&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Remove samples with an ID that matches a regular expression:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">filter_samples_expr</span><span class="p">(</span><span class="s1">&#39;&quot;^NA&quot; ~ s&#39;</span> <span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Filter samples from sample QC metrics and write output to a new variant dataset:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">sample_qc</span><span class="p">()</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">filter_samples_expr</span><span class="p">(</span><span class="s1">&#39;sa.qc.callRate &gt;= 0.99 &amp;&amp; sa.qc.dpMean &gt;= 10&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;output/filter_samples.vds&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p><code class="docutils literal"><span class="pre">condition</span></code> is in sample context so the following symbols are in scope:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">s</span></code> (<em>Sample</em>): <span class="xref std std-ref">sample</span></li>
<li><code class="docutils literal"><span class="pre">sa</span></code>: sample annotations</li>
<li><code class="docutils literal"><span class="pre">global</span></code>: global annotations</li>
<li><code class="docutils literal"><span class="pre">gs</span></code> (<em>Aggregable[Genotype]</em>): aggregable of <a class="reference internal" href="types.html#genotype"><span class="std std-ref">Genotype</span></a> for sample <code class="docutils literal"><span class="pre">s</span></code></li>
</ul>
<p>For more information, see the documentation on <a class="reference external" href="overview.html#">data representation, annotations</a>, and
the <a class="reference external" href="exprlang.html">expression language</a>.</p>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">When <code class="docutils literal"><span class="pre">condition</span></code> evaluates to missing, the sample will be removed regardless of whether <code class="docutils literal"><span class="pre">keep=True</span></code> or <code class="docutils literal"><span class="pre">keep=False</span></code>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>condition</strong> (<em>str</em>) &#8211; Expression for filter condition.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Filtered variant dataset.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.filter_samples_list">
<code class="descname">filter_samples_list</code><span class="sig-paren">(</span><em>samples</em>, <em>keep=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.filter_samples_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.filter_samples_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter samples with a list of samples.</p>
<p><strong>Examples</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;NA12878&#39;</span><span class="p">,</span> <span class="s1">&#39;NA12891&#39;</span><span class="p">,</span> <span class="s1">&#39;NA12892&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">filter_samples_list</span><span class="p">(</span><span class="n">to_remove</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Read list from a file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data/exclude_samples.txt&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">filter_samples_list</span><span class="p">(</span><span class="n">to_remove</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>list of str</em>) &#8211; List of samples to keep or remove.</li>
<li><strong>keep</strong> (<em>bool</em>) &#8211; If true, keep samples in <code class="docutils literal"><span class="pre">samples</span></code>, otherwise remove them.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Filtered variant dataset.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.filter_variants_expr">
<code class="descname">filter_variants_expr</code><span class="sig-paren">(</span><em>condition</em>, <em>keep=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.filter_variants_expr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.filter_variants_expr" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter variants based on expression.</p>
<p><strong>Examples</strong></p>
<p>Keep variants in the gene CHD8 (assumes the variant annotation <code class="docutils literal"><span class="pre">va.gene</span></code> exists):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">filter_variants_expr</span><span class="p">(</span><span class="s1">&#39;va.gene == &quot;CHD8&quot;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Remove all variants on chromosome 1:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">filter_variants_expr</span><span class="p">(</span><span class="s1">&#39;v.contig == &quot;1&quot;&#39;</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">The double quotes on <code class="docutils literal"><span class="pre">&quot;1&quot;</span></code> are necessary because <code class="docutils literal"><span class="pre">v.contig</span></code> is of type String.</p>
</div>
<p><strong>Notes</strong></p>
<p>The following symbols are in scope for <code class="docutils literal"><span class="pre">condition</span></code>:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">v</span></code> (<em>Variant</em>): <a class="reference internal" href="types.html#variant"><span class="std std-ref">Variant</span></a></li>
<li><code class="docutils literal"><span class="pre">va</span></code>: variant annotations</li>
<li><code class="docutils literal"><span class="pre">global</span></code>: global annotations</li>
<li><code class="docutils literal"><span class="pre">gs</span></code> (<em>Aggregable[Genotype]</em>): aggregable of <a class="reference internal" href="types.html#genotype"><span class="std std-ref">Genotype</span></a> for variant <code class="docutils literal"><span class="pre">v</span></code></li>
</ul>
<p>For more information, see the <a class="reference external" href="overview.html#">Overview</a> and the <a class="reference external" href="exprlang.html">Expression Language</a>.</p>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">When <code class="docutils literal"><span class="pre">condition</span></code> evaluates to missing, the variant will be removed regardless of whether <code class="docutils literal"><span class="pre">keep=True</span></code> or <code class="docutils literal"><span class="pre">keep=False</span></code>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>condition</strong> (<em>str</em>) &#8211; Expression for filter condition.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Filtered variant dataset.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.filter_variants_intervals">
<code class="descname">filter_variants_intervals</code><span class="sig-paren">(</span><em>intervals</em>, <em>keep=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.filter_variants_intervals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.filter_variants_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter variants with an interval or interval tree.</p>
<p><strong>Examples</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hail.representation</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">filter_variants_intervals</span><span class="p">(</span><span class="n">IntervalTree</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;data/intervals.txt&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">filter_variants_intervals</span><span class="p">(</span><span class="n">IntervalTree</span><span class="o">.</span><span class="n">parse_all</span><span class="p">([</span><span class="s1">&#39;1:50M-75M&#39;</span><span class="p">,</span> <span class="s1">&#39;2:START-400000&#39;</span><span class="p">,</span><span class="s1">&#39;3-22&#39;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">filter_variants_intervals</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="n">Locus</span><span class="p">(</span><span class="s1">&#39;17&#39;</span><span class="p">,</span> <span class="mi">38449840</span><span class="p">),</span> <span class="n">Locus</span><span class="p">(</span><span class="s1">&#39;17&#39;</span><span class="p">,</span> <span class="mi">38530994</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">filter_variants_intervals</span><span class="p">(</span><span class="n">Interval</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;17:38449840-38530994&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>This method takes an argument either of <a class="reference internal" href="representation/hail.representation.Interval.html#hail.representation.Interval" title="hail.representation.Interval"><code class="xref py py-class docutils literal"><span class="pre">Interval</span></code></a> or <a class="reference internal" href="representation/hail.representation.IntervalTree.html#hail.representation.IntervalTree" title="hail.representation.IntervalTree"><code class="xref py py-class docutils literal"><span class="pre">IntervalTree</span></code></a>.</p>
<p>Based on the <code class="docutils literal"><span class="pre">keep</span></code> argument, this method will either restrict to variants in the
supplied interval range, or remove all variants in that range.  Note that intervals
are left-inclusive, and right-exclusive.  The below interval includes the locus
<code class="docutils literal"><span class="pre">15:100000</span></code> but not <code class="docutils literal"><span class="pre">15:101000</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">interval</span> <span class="o">=</span> <span class="n">Interval</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;15:100000-101000&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To supply a file containing intervals, use <a class="reference internal" href="representation/hail.representation.IntervalTree.html#hail.representation.IntervalTree.read" title="hail.representation.IntervalTree.read"><code class="xref py py-meth docutils literal"><span class="pre">IntervalTree.read()</span></code></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">filter_variants_intervals</span><span class="p">(</span><span class="n">IntervalTree</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;data/intervals.txt&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>This method performs predicate pushdown when <code class="docutils literal"><span class="pre">keep</span></code> is <code class="docutils literal"><span class="pre">True</span></code>, meaning that data shards
that don&#8217;t overlap any supplied interval will not be loaded at all.  This property
enables <code class="docutils literal"><span class="pre">filter_variants_intervals</span></code> to be used for reasonably low-latency queries of one
or more variants, even on large variant datasets:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span> <span class="c1"># We are interested in the variant 15:100203:A:T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds_filtered</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">filter_variants_expr</span><span class="p">(</span><span class="s1">&#39;v.contig == &quot;15&quot; &amp;&amp; v.start == 100203&#39;</span><span class="p">)</span>  <span class="c1"># slow</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds_filtered</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">filter_variants_intervals</span><span class="p">(</span><span class="n">Interval</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;15:100203-100204&#39;</span><span class="p">))</span>  <span class="c1"># very fast</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>intervals</strong> (s:class:<cite>.Interval</cite> or <a class="reference internal" href="representation/hail.representation.IntervalTree.html#hail.representation.IntervalTree" title="hail.representation.IntervalTree"><code class="xref py py-class docutils literal"><span class="pre">IntervalTree</span></code></a>) &#8211; interval or interval tree object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Filtered variant dataset.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.filter_variants_kt">
<code class="descname">filter_variants_kt</code><span class="sig-paren">(</span><em>kt</em>, <em>keep=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.filter_variants_kt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.filter_variants_kt" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter variants with a Variant keyed key table.</p>
<p><strong>Example</strong></p>
<p>Filter variants of a VDS to those appearing in the Variant column of a TSV file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kt</span> <span class="o">=</span> <span class="n">hc</span><span class="o">.</span><span class="n">import_keytable</span><span class="p">(</span><span class="s1">&#39;data/sample_variants.txt&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;Variant&#39;</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">TextTableConfig</span><span class="p">(</span><span class="n">impute</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered_vds</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">filter_variants_kt</span><span class="p">(</span><span class="n">kt</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>kt</strong> (<a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a>) &#8211; Keep or remove <code class="docutils literal"><span class="pre">kt</span></code> keys.</li>
<li><strong>keep</strong> (<em>bool</em>) &#8211; If true, keep variants which appear as keys
in <code class="docutils literal"><span class="pre">kt</span></code>, otherwise remove them.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Filtered variant dataset.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.filter_variants_list">
<code class="descname">filter_variants_list</code><span class="sig-paren">(</span><em>variants</em>, <em>keep=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.filter_variants_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.filter_variants_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter variants with a list of variants.</p>
<p><strong>Examples</strong></p>
<p>Filter VDS down to a list of variants:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span><span class="o">.</span><span class="n">filter_variants_list</span><span class="p">([</span><span class="n">Variant</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;20:10626633:G:GC&#39;</span><span class="p">),</span> <span class="n">Variant</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;20:10019093:A:G&#39;</span><span class="p">)],</span> <span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variants</strong> (list of <a class="reference internal" href="representation/hail.representation.Variant.html#hail.representation.Variant" title="hail.representation.Variant"><code class="xref py py-class docutils literal"><span class="pre">Variant</span></code></a>) &#8211; List of variants to keep or remove.</li>
<li><strong>keep</strong> (<em>bool</em>) &#8211; If true, keep variants in <code class="docutils literal"><span class="pre">variants</span></code>, otherwise remove them.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Filtered variant dataset.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="hail.VariantDataset.from_keytable">
<em class="property">static </em><code class="descname">from_keytable</code><span class="sig-paren">(</span><em>key_table</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.from_keytable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.from_keytable" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a sites-only variant dataset from a key table.</p>
<p>The key table must be keyed by one column of type <a class="reference internal" href="expr/hail.expr.TVariant.html#hail.expr.TVariant" title="hail.expr.TVariant"><code class="xref py py-class docutils literal"><span class="pre">TVariant</span></code></a>.</p>
<p>All columns in the key table become variant annotations in the result.
For example, a key table with key column <code class="docutils literal"><span class="pre">v</span></code> (<em>Variant</em>) and column
<code class="docutils literal"><span class="pre">gene</span></code> (<em>String</em>) will produce a sites-only variant dataset with a
<code class="docutils literal"><span class="pre">va.gene</span></code> variant annotation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key_table</strong> (<a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a>) &#8211; variant-keyed key table</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Sites-only variant dataset.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="hail.VariantDataset.genotype_schema">
<code class="descname">genotype_schema</code><a class="headerlink" href="#hail.VariantDataset.genotype_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the signature of the genotypes contained in this VDS.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">genotype_schema</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="expr/hail.expr.Type.html#hail.expr.Type" title="hail.expr.Type"><code class="xref py py-class docutils literal"><span class="pre">Type</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="hail.VariantDataset.global_schema">
<code class="descname">global_schema</code><a class="headerlink" href="#hail.VariantDataset.global_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the signature of the global annotations contained in this VDS.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">global_schema</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="expr/hail.expr.Type.html#hail.expr.Type" title="hail.expr.Type"><code class="xref py py-class docutils literal"><span class="pre">Type</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="hail.VariantDataset.globals">
<code class="descname">globals</code><a class="headerlink" href="#hail.VariantDataset.globals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return global annotations as a Python object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Dataset global annotations.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="representation/hail.representation.Struct.html#hail.representation.Struct" title="hail.representation.Struct"><code class="xref py py-class docutils literal"><span class="pre">Struct</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.grm">
<code class="descname">grm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.grm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.grm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Genetic Relatedness Matrix (GRM).</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Examples</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">km</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">grm</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>The genetic relationship matrix (GRM) <span class="math">\(G\)</span> encodes genetic correlation between each pair of samples. It is defined by <span class="math">\(G = MM^T\)</span> where <span class="math">\(M\)</span> is a standardized version of the genotype matrix, computed as follows. Let <span class="math">\(C\)</span> be the <span class="math">\(n \times m\)</span> matrix of raw genotypes in the variant dataset, with rows indexed by <span class="math">\(n\)</span> samples and columns indexed by <span class="math">\(m\)</span> bialellic autosomal variants; <span class="math">\(C_{ij}\)</span> is the number of alternate alleles of variant <span class="math">\(j\)</span> carried by sample <span class="math">\(i\)</span>, which can be 0, 1, 2, or missing. For each variant <span class="math">\(j\)</span>, the sample alternate allele frequency <span class="math">\(p_j\)</span> is computed as half the mean of the non-missing entries of column <span class="math">\(j\)</span>. Entries of <span class="math">\(M\)</span> are then mean-centered and variance-normalized as</p>
<div class="math">
\[M_{ij} = \frac{C_{ij}-2p_j}{\sqrt{2p_j(1-p_j)m}},\]</div>
<p>with <span class="math">\(M_{ij} = 0\)</span> for <span class="math">\(C_{ij}\)</span> missing (i.e. mean genotype imputation). This scaling normalizes genotype variances to a common value <span class="math">\(1/m\)</span> for variants in Hardy-Weinberg equilibrium and is further motivated in the paper <a class="reference external" href="http://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.0020190">Patterson, Price and Reich, 2006</a>. (The resulting amplification of signal from the low end of the allele frequency spectrum will also introduce noise for rare variants; common practice is to filter out variants with minor allele frequency below some cutoff.)  The factor <span class="math">\(1/m\)</span> gives each sample row approximately unit total variance (assuming linkage equilibrium) so that the diagonal entries of the GRM are approximately 1. Equivalently,</p>
<div class="math">
\[G_{ik} = \frac{1}{m} \sum_{j=1}^m \frac{(C_{ij}-2p_j)(C_{kj}-2p_j)}{2 p_j (1-p_j)}  \]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Genetic Relatedness Matrix for all samples.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="hail.KinshipMatrix.html#hail.KinshipMatrix" title="hail.KinshipMatrix"><code class="xref py py-class docutils literal"><span class="pre">KinshipMatrix</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.hardcalls">
<code class="descname">hardcalls</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.hardcalls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.hardcalls" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop all genotype fields except the GT field.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p>A hard-called variant dataset is about two orders of magnitude
smaller than a standard sequencing dataset. Use this
method to create a smaller, faster
representation for downstream processing that only
requires the GT field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Variant dataset with no genotype metadata.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.ibd">
<code class="descname">ibd</code><span class="sig-paren">(</span><em>maf=None</em>, <em>bounded=True</em>, <em>min=None</em>, <em>max=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.ibd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.ibd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute matrix of identity-by-descent estimations.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Examples</strong></p>
<p>To calculate a full IBD matrix, using minor allele frequencies computed
from the variant dataset itself:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span><span class="o">.</span><span class="n">ibd</span><span class="p">()</span>
</pre></div>
</div>
<p>To calculate an IBD matrix containing only pairs of samples with
<code class="docutils literal"><span class="pre">PI_HAT</span></code> in [0.2, 0.9], using minor allele frequencies stored in
<code class="docutils literal"><span class="pre">va.panel_maf</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span><span class="o">.</span><span class="n">ibd</span><span class="p">(</span><span class="n">maf</span><span class="o">=</span><span class="s1">&#39;va.panel_maf&#39;</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>The implementation is based on the IBD algorithm described in the <a class="reference external" href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC1950838">PLINK
paper</a>.</p>
<p><a class="reference internal" href="#hail.VariantDataset.ibd" title="hail.VariantDataset.ibd"><code class="xref py py-meth docutils literal"><span class="pre">ibd()</span></code></a> requires the dataset to be
bi-allelic (otherwise run <a class="reference internal" href="#hail.VariantDataset.split_multi" title="hail.VariantDataset.split_multi"><code class="xref py py-meth docutils literal"><span class="pre">split_multi()</span></code></a> or otherwise run <a class="reference internal" href="#hail.VariantDataset.filter_multi" title="hail.VariantDataset.filter_multi"><code class="xref py py-meth docutils literal"><span class="pre">filter_multi()</span></code></a>)
and does not perform LD pruning. Linkage disequilibrium may bias the
result so consider filtering variants first.</p>
<p>The resulting <a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a> entries have the type: <em>{ i: String,
j: String, ibd: { Z0: Double, Z1: Double, Z2: Double, PI_HAT: Double },
ibs0: Long, ibs1: Long, ibs2: Long }</em>. The key list is: <cite>*i: String, j:
String*</cite>.</p>
<p>Conceptually, the output is a symmetric, sample-by-sample matrix. The
output key table has the following form</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>i           j       ibd.Z0  ibd.Z1  ibd.Z2  ibd.PI_HAT ibs0 ibs1    ibs2
sample1     sample2 1.0000  0.0000  0.0000  0.0000 ...
sample1     sample3 1.0000  0.0000  0.0000  0.0000 ...
sample1     sample4 0.6807  0.0000  0.3193  0.3193 ...
sample1     sample5 0.1966  0.0000  0.8034  0.8034 ...
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>maf</strong> (<em>str</em><em> or </em><em>None</em>) &#8211; Expression for the minor allele frequency.</li>
<li><strong>bounded</strong> (<em>bool</em>) &#8211; Forces the estimations for Z0, Z1, Z2,
and PI_HAT to take on biologically meaningful values
(in the range [0,1]).</li>
<li><strong>min</strong> (<em>float</em><em> or </em><em>None</em>) &#8211; Sample pairs with a PI_HAT below this value will
not be included in the output. Must be in [0,1].</li>
<li><strong>max</strong> (<em>float</em><em> or </em><em>None</em>) &#8211; Sample pairs with a PI_HAT above this value will
not be included in the output. Must be in [0,1].</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A <a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a> mapping pairs of samples to their IBD
statistics</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.ibd_prune">
<code class="descname">ibd_prune</code><span class="sig-paren">(</span><em>threshold</em>, <em>tiebreaking_expr=None</em>, <em>maf=None</em>, <em>bounded=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.ibd_prune"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.ibd_prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Prune samples from the <a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a> based on <a class="reference internal" href="#hail.VariantDataset.ibd" title="hail.VariantDataset.ibd"><code class="xref py py-meth docutils literal"><span class="pre">ibd()</span></code></a> PI_HAT measures of relatedness.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Examples</strong></p>
<p>Prune samples so that no two have a PI_HAT value greater than or equal to 0.5:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pruned_vds</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">ibd_prune</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>The variant dataset returned may change in near future as a result of algorithmic improvements. The current algorithm is very efficient on datasets with many small
families, less so on datasets with large families. Currently, the algorithm works by deleting the person from each family who has the highest number of relatives,
and iterating until no two people have a PI_HAT value greater than that specified. If two people within a family have the same number of relatives, the tiebreaking_expr
given will be used to determine which sample gets deleted.</p>
<p>The tiebreaking_expr namespace has the following variables available:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">s1</span></code>: The first sample id.</li>
<li><code class="docutils literal"><span class="pre">sa1</span></code>: The annotations associated with s1.</li>
<li><code class="docutils literal"><span class="pre">s2</span></code>: The second sample id.</li>
<li><code class="docutils literal"><span class="pre">sa2</span></code>: The annotations associated with s2.</li>
</ul>
<p>The tiebreaking_expr returns an integer expressing the preference for one sample over the other. Any negative integer expresses a preference for keeping <code class="docutils literal"><span class="pre">s1</span></code>. Any positive integer expresses a preference for keeping <code class="docutils literal"><span class="pre">s2</span></code>. A zero expresses no preference. This function must induce a <a class="reference external" href="https://en.wikipedia.org/wiki/Preorder">preorder</a> on the samples, in particular:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">tiebreaking_expr(sample1,</span> <span class="pre">sample2)</span></code> must equal <code class="docutils literal"><span class="pre">-1</span> <span class="pre">*</span> <span class="pre">tie</span> <span class="pre">breaking_expr(sample2,</span> <span class="pre">sample1)</span></code>, which evokes the common sense understanding that if <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> then <cite>y &gt; x`</cite>.</li>
<li><code class="docutils literal"><span class="pre">tiebreaking_expr(sample1,</span> <span class="pre">sample1)</span></code> must equal 0, i.e. <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span></code></li>
<li>if sample1 is preferred to sample2 and sample2 is preferred to sample3, then sample1 must also be preferred to sample3</li>
</ul>
<p>The last requirement is only important if you have three related samples with the same number of relatives and all three are related to one another. In cases like this one, it is important that either:</p>
<ul class="simple">
<li>one of the three is preferred to <strong>both</strong> other ones, or</li>
<li>there is no preference among the three samples</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>threshold</strong> &#8211; The desired maximum PI_HAT value between any pair of samples.</li>
<li><strong>tiebreaking_expr</strong> &#8211; Expression used to choose between two samples with the same number of relatives.</li>
<li><strong>maf</strong> &#8211; Expression for the minor allele frequency.</li>
<li><strong>bounded</strong> &#8211; Forces the estimations for Z0, Z1, Z2, and PI_HAT to take on biologically meaningful values (in the range [0,1]).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A <a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a> containing no samples with a PI_HAT greater than threshold.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.impute_sex">
<code class="descname">impute_sex</code><span class="sig-paren">(</span><em>maf_threshold=0.0</em>, <em>include_par=False</em>, <em>female_threshold=0.2</em>, <em>male_threshold=0.8</em>, <em>pop_freq=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.impute_sex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.impute_sex" title="Permalink to this definition">¶</a></dt>
<dd><p>Impute sex of samples by calculating inbreeding coefficient on the
X chromosome.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Examples</strong></p>
<p>Remove samples where imputed sex does not equal reported sex:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">imputed_sex_vds</span> <span class="o">=</span> <span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">impute_sex</span><span class="p">()</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">annotate_samples_expr</span><span class="p">(</span><span class="s1">&#39;sa.sexcheck = sa.pheno.isFemale == sa.imputesex.isFemale&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">filter_samples_expr</span><span class="p">(</span><span class="s1">&#39;sa.sexcheck || isMissing(sa.sexcheck)&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>We have used the same implementation as <a class="reference external" href="http://pngu.mgh.harvard.edu/~purcell/plink/summary.shtml#sexcheck">PLINK v1.7</a>.</p>
<ol class="arabic simple">
<li>X chromosome variants are selected from the VDS: <code class="docutils literal"><span class="pre">v.contig</span> <span class="pre">==</span> <span class="pre">&quot;X&quot;</span> <span class="pre">||</span> <span class="pre">v.contig</span> <span class="pre">==</span> <span class="pre">&quot;23&quot;</span></code></li>
<li>Variants with a minor allele frequency less than the threshold given by <code class="docutils literal"><span class="pre">maf-threshold</span></code> are removed</li>
<li>Variants in the pseudoautosomal region <cite>(X:60001-2699520) || (X:154931044-155260560)</cite> are included if the <code class="docutils literal"><span class="pre">include_par</span></code> optional parameter is set to true.</li>
<li>The minor allele frequency (maf) per variant is calculated.</li>
<li>For each variant and sample with a non-missing genotype call, <span class="math">\(E\)</span>, the expected number of homozygotes (from population MAF), is computed as <span class="math">\(1.0 - (2.0*maf*(1.0-maf))\)</span>.</li>
<li>For each variant and sample with a non-missing genotype call, <span class="math">\(O\)</span>, the observed number of homozygotes, is computed as <cite>0 = heterozygote; 1 = homozygote</cite></li>
<li>For each variant and sample with a non-missing genotype call, <span class="math">\(N\)</span> is incremented by 1</li>
<li>For each sample, <span class="math">\(E\)</span>, <span class="math">\(O\)</span>, and <span class="math">\(N\)</span> are combined across variants</li>
<li><span class="math">\(F\)</span> is calculated by <span class="math">\((O - E) / (N - E)\)</span></li>
<li>A sex is assigned to each sample with the following criteria: <cite>F &lt; 0.2 =&gt; Female; F &gt; 0.8 =&gt; Male</cite>. Use <code class="docutils literal"><span class="pre">female-threshold</span></code> and <code class="docutils literal"><span class="pre">male-threshold</span></code> to change this behavior.</li>
</ol>
<p><strong>Annotations</strong></p>
<p>The below annotations can be accessed with <code class="docutils literal"><span class="pre">sa.imputesex</span></code>.</p>
<ul class="simple">
<li><strong>isFemale</strong> (<em>Boolean</em>) &#8211; True if the imputed sex is female, false if male, missing if undetermined</li>
<li><strong>Fstat</strong> (<em>Double</em>) &#8211; Inbreeding coefficient</li>
<li><strong>nTotal</strong> (<em>Long</em>) &#8211; Total number of variants considered</li>
<li><strong>nCalled</strong>  (<em>Long</em>) &#8211; Number of variants with a genotype call</li>
<li><strong>expectedHoms</strong> (<em>Double</em>) &#8211; Expected number of homozygotes</li>
<li><strong>observedHoms</strong> (<em>Long</em>) &#8211; Observed number of homozygotes</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>maf_threshold</strong> (<em>float</em>) &#8211; Minimum minor allele frequency threshold.</li>
<li><strong>include_par</strong> (<em>bool</em>) &#8211; Include pseudoautosomal regions.</li>
<li><strong>female_threshold</strong> (<em>float</em>) &#8211; Samples are called females if F &lt; femaleThreshold</li>
<li><strong>male_threshold</strong> (<em>float</em>) &#8211; Samples are called males if F &gt; maleThreshold</li>
<li><strong>pop_freq</strong> (<em>str</em>) &#8211; Variant annotation for estimate of MAF.
If None, MAF will be computed.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Annotated dataset.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.is_dosage">
<code class="descname">is_dosage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.is_dosage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.is_dosage" title="Permalink to this definition">¶</a></dt>
<dd><p>True if genotype probabilities are dosages.</p>
<p>The result of <code class="docutils literal"><span class="pre">is_dosage()</span></code> will be True if the variant dataset was imported with <a class="reference internal" href="hail.HailContext.html#hail.HailContext.import_gen" title="hail.HailContext.import_gen"><code class="xref py py-meth docutils literal"><span class="pre">import_gen()</span></code></a> or
<a class="reference internal" href="hail.HailContext.html#hail.HailContext.import_bgen" title="hail.HailContext.import_bgen"><code class="xref py py-meth docutils literal"><span class="pre">import_bgen()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.join">
<code class="descname">join</code><span class="sig-paren">(</span><em>right</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.join"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Join two variant datasets.</p>
<p><strong>Notes</strong></p>
<p>This method performs an inner join on variants,
concatenates samples, and takes variant and
global annotations from the left dataset (self).</p>
<p>The datasets must have distinct samples, the same sample schema, and the same split status (both split or both multi-allelic).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>right</strong> (<a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a>) &#8211; right-hand variant dataset</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Joined variant dataset</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.ld_prune">
<code class="descname">ld_prune</code><span class="sig-paren">(</span><em>r2=0.2</em>, <em>window=1000000</em>, <em>memory_per_core=256</em>, <em>num_cores=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.ld_prune"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.ld_prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Prune variants in linkage disequilibrium (LD).</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p>Requires <a class="reference internal" href="#hail.VariantDataset.was_split" title="hail.VariantDataset.was_split"><code class="xref py py-class docutils literal"><span class="pre">was_split</span></code></a> equals True.</p>
<p><strong>Examples</strong></p>
<p>Export the set of common LD pruned variants to a file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">variant_qc</span><span class="p">()</span>
<span class="gp">... </span>                 <span class="o">.</span><span class="n">filter_variants_expr</span><span class="p">(</span><span class="s2">&quot;va.qc.AF &gt;= 0.05 &amp;&amp; va.qc.AF &lt;= 0.95&quot;</span><span class="p">)</span>
<span class="gp">... </span>                 <span class="o">.</span><span class="n">ld_prune</span><span class="p">()</span>
<span class="gp">... </span>                 <span class="o">.</span><span class="n">export_variants</span><span class="p">(</span><span class="s2">&quot;output/ldpruned.variants&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>Variants are pruned in each contig from smallest to largest start position. The LD pruning algorithm is as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">pruned_set</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">contig</span><span class="p">:</span>
    <span class="n">keep</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">pruned_set</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">v1</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">v2</span><span class="o">.</span><span class="n">position</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">window</span> <span class="ow">and</span> <span class="n">correlation</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">r2</span><span class="p">):</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
        <span class="n">pruned_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal"><span class="pre">window</span></code> defines the maximum distance in base pairs between two variants to check whether
the variants are independent (<span class="math">\(R^2\)</span> &lt; <code class="docutils literal"><span class="pre">r2</span></code>) where <code class="docutils literal"><span class="pre">r2</span></code> is the maximum <span class="math">\(R^2\)</span> allowed.
<span class="math">\(R^2\)</span> is defined as the square of <a class="reference external" href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson&#8217;s correlation coefficient</a>
<span class="math">\({\rho}_{x,y}\)</span> between the two genotype vectors <span class="math">\({\mathbf{x}}\)</span> and <span class="math">\({\mathbf{y}}\)</span>.</p>
<div class="math">
\[{\rho}_{x,y} = \frac{\mathrm{Cov}(X,Y)}{\sigma_X \sigma_Y}\]</div>
<p><a class="reference internal" href="#hail.VariantDataset.ld_prune" title="hail.VariantDataset.ld_prune"><code class="xref py py-meth docutils literal"><span class="pre">ld_prune()</span></code></a> with default arguments is equivalent to <code class="docutils literal"><span class="pre">plink</span> <span class="pre">--indep-pairwise</span> <span class="pre">1000kb</span> <span class="pre">1</span> <span class="pre">0.2</span></code>.
The list of pruned variants returned by Hail and PLINK will differ because Hail mean-imputes missing values and tests pairs of variants in a different order than PLINK.</p>
<p>Be sure to provide enough disk space per worker because <a class="reference internal" href="#hail.VariantDataset.ld_prune" title="hail.VariantDataset.ld_prune"><code class="xref py py-meth docutils literal"><span class="pre">ld_prune()</span></code></a> <a class="reference external" href="http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence">persists</a> up to 3 copies of the data to both memory and disk.
The amount of disk space required will depend on the size and minor allele frequency of the input data and the prune parameters <code class="docutils literal"><span class="pre">r2</span></code> and <code class="docutils literal"><span class="pre">window</span></code>. The number of bytes stored in memory per variant is about <code class="docutils literal"><span class="pre">nSamples</span> <span class="pre">/</span> <span class="pre">4</span> <span class="pre">+</span> <span class="pre">50</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The variants in the pruned set are not guaranteed to be identical each time <a class="reference internal" href="#hail.VariantDataset.ld_prune" title="hail.VariantDataset.ld_prune"><code class="xref py py-meth docutils literal"><span class="pre">ld_prune()</span></code></a> is run. We recommend running <a class="reference internal" href="#hail.VariantDataset.ld_prune" title="hail.VariantDataset.ld_prune"><code class="xref py py-meth docutils literal"><span class="pre">ld_prune()</span></code></a> once and exporting the list of LD pruned variants using
<a class="reference internal" href="#hail.VariantDataset.export_variants" title="hail.VariantDataset.export_variants"><code class="xref py py-meth docutils literal"><span class="pre">export_variants()</span></code></a> for future use.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>r2</strong> (<em>float</em>) &#8211; Maximum <span class="math">\(R^2\)</span> threshold between two variants in the pruned set within a given window.</li>
<li><strong>window</strong> (<em>int</em>) &#8211; Width of window in base-pairs for computing pair-wise <span class="math">\(R^2\)</span> values.</li>
<li><strong>memory_per_core</strong> (<em>float</em>) &#8211; Total amount of memory available for each core in MB. If unsure, use the default value.</li>
<li><strong>num_cores</strong> (<em>int</em>) &#8211; The number of cores available. Equivalent to the total number of workers times the number of cores per worker.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Variant dataset filtered to those variants which remain after LD pruning.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset">VariantDataset</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.linreg">
<code class="descname">linreg</code><span class="sig-paren">(</span><em>y</em>, <em>covariates=[]</em>, <em>root='va.linreg'</em>, <em>use_dosages=False</em>, <em>min_ac=1</em>, <em>min_af=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.linreg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.linreg" title="Permalink to this definition">¶</a></dt>
<dd><p>Test each variant for association using linear regression.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Examples</strong></p>
<p>Run linear regression per variant using a phenotype and two covariates stored in sample annotations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">linreg</span><span class="p">(</span><span class="s1">&#39;sa.pheno.height&#39;</span><span class="p">,</span> <span class="n">covariates</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sa.pheno.age&#39;</span><span class="p">,</span> <span class="s1">&#39;sa.pheno.isFemale&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>The <a class="reference internal" href="#hail.VariantDataset.linreg" title="hail.VariantDataset.linreg"><code class="xref py py-meth docutils literal"><span class="pre">linreg()</span></code></a> command computes, for each variant, statistics of
the <span class="math">\(t\)</span>-test for the genotype coefficient of the linear function
of best fit from sample genotype and covariates to quantitative
phenotype or case-control status. Hail only includes samples for which
phenotype and all covariates are defined. For each variant, missing genotypes
as the mean of called genotypes.</p>
<p>By default, genotypes values are given by hard call genotypes (<code class="docutils literal"><span class="pre">g.gt</span></code>).
If <code class="docutils literal"><span class="pre">use_dosages=True</span></code>, then genotype values are given by dosage genotypes, defined by
<span class="math">\(\mathrm{P}(\mathrm{Het}) + 2 \cdot \mathrm{P}(\mathrm{HomVar})\)</span>. For any variant, if <code class="docutils literal"><span class="pre">Variant.is_dosage</span></code>
is false, then <span class="math">\(\mathrm{P}(\mathrm{Het})\)</span> and <span class="math">\(\mathrm{P}(\mathrm{HomVar})\)</span> are
calculated by normalizing the PL likelihoods (converted from the Phred-scale) to sum to 1.</p>
<p>Assuming there are sample annotations <code class="docutils literal"><span class="pre">sa.pheno.height</span></code>,
<code class="docutils literal"><span class="pre">sa.pheno.age</span></code>, <code class="docutils literal"><span class="pre">sa.pheno.isFemale</span></code>, and <code class="docutils literal"><span class="pre">sa.cov.PC1</span></code>, the command:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">linreg</span><span class="p">(</span><span class="s1">&#39;sa.pheno.height&#39;</span><span class="p">,</span> <span class="n">covariates</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sa.pheno.age&#39;</span><span class="p">,</span> <span class="s1">&#39;sa.pheno.isFemale&#39;</span><span class="p">,</span> <span class="s1">&#39;sa.cov.PC1&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>considers a model of the form</p>
<div class="math">
\[\mathrm{height} = \beta_0 + \beta_1 \, \mathrm{gt} + \beta_2 \, \mathrm{age} + \beta_3 \, \mathrm{isFemale} + \beta_4 \, \mathrm{PC1} + \varepsilon, \quad \varepsilon \sim \mathrm{N}(0, \sigma^2)\]</div>
<p>where the genotype <span class="math">\(\mathrm{gt}\)</span> is coded as <span class="math">\(0\)</span> for HomRef, <span class="math">\(1\)</span> for
Het, and <span class="math">\(2\)</span> for HomVar, and the Boolean covariate <span class="math">\(\mathrm{isFemale}\)</span>
is coded as <span class="math">\(1\)</span> for true (female) and <span class="math">\(0\)</span> for false (male). The null
model sets <span class="math">\(\beta_1 = 0\)</span>.</p>
<p><a class="reference internal" href="#hail.VariantDataset.linreg" title="hail.VariantDataset.linreg"><code class="xref py py-meth docutils literal"><span class="pre">linreg()</span></code></a> skips variants that don&#8217;t vary across the included samples,
such as when all genotypes are homozygous reference. One can further
restrict computation to those variants with at least <span class="math">\(k\)</span> observed
alternate alleles (AC) or alternate allele frequency (AF) at least
<span class="math">\(p\)</span> in the included samples using the options <code class="docutils literal"><span class="pre">minac=k</span></code> or
<code class="docutils literal"><span class="pre">minaf=p</span></code>, respectively. Unlike the <a class="reference internal" href="#hail.VariantDataset.filter_variants_expr" title="hail.VariantDataset.filter_variants_expr"><code class="xref py py-meth docutils literal"><span class="pre">filter_variants_expr()</span></code></a>
command, these filters do not remove variants from the underlying
variant dataset. Adding both filters is equivalent to applying the more
stringent of the two, as AF equals AC over twice the number of included
samples.</p>
<p>Phenotype and covariate sample annotations may also be specified using <a class="reference external" href="exprlang.html">programmatic expressions</a> without identifiers, such as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">linreg</span><span class="p">(</span><span class="s1">&#39;if (sa.pheno.isFemale) sa.pheno.age else (2 * sa.pheno.age + 10)&#39;</span><span class="p">,</span> <span class="n">covariates</span><span class="o">=</span><span class="p">[])</span>
</pre></div>
</div>
<p>For Boolean covariate types, true is coded as 1 and false as 0. In particular, for the sample annotation <code class="docutils literal"><span class="pre">sa.fam.isCase</span></code> added by importing a FAM file with case-control phenotype, case is 1 and control is 0.</p>
<p>The standard least-squares linear regression model is derived in Section
3.2 of <a class="reference external" href="http://statweb.stanford.edu/~tibs/ElemStatLearn/printings/ESLII_print10.pdf">The Elements of Statistical Learning, 2nd Edition</a>. See
equation 3.12 for the t-statistic which follows the t-distribution with
<span class="math">\(n - k - 2\)</span> degrees of freedom, under the null hypothesis of no
effect, with <span class="math">\(n\)</span> samples and <span class="math">\(k\)</span> covariates in addition to
genotype and intercept.</p>
<p><strong>Annotations</strong></p>
<p>With the default root, the following four variant annotations are added.</p>
<ul class="simple">
<li><strong>va.linreg.beta</strong> (<em>Double</em>) &#8211; fit genotype coefficient, <span class="math">\(\hat\beta_1\)</span></li>
<li><strong>va.linreg.se</strong> (<em>Double</em>) &#8211; estimated standard error, <span class="math">\(\widehat{\mathrm{se}}\)</span></li>
<li><strong>va.linreg.tstat</strong> (<em>Double</em>) &#8211; <span class="math">\(t\)</span>-statistic, equal to <span class="math">\(\hat\beta_1 / \widehat{\mathrm{se}}\)</span></li>
<li><strong>va.linreg.pval</strong> (<em>Double</em>) &#8211; <span class="math">\(p\)</span>-value</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>y</strong> (<em>str</em>) &#8211; Response expression</li>
<li><strong>covariates</strong> (<em>list of str</em>) &#8211; list of covariate expressions</li>
<li><strong>root</strong> (<em>str</em>) &#8211; Variant annotation path to store result of linear regression.</li>
<li><strong>use_dosages</strong> (<em>bool</em>) &#8211; If true, use dosage genotypes rather than hard call genotypes.</li>
<li><strong>min_ac</strong> (<em>int</em>) &#8211; Minimum alternate allele count.</li>
<li><strong>min_af</strong> (<em>float</em>) &#8211; Minimum alternate allele frequency.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Variant dataset with linear regression variant annotations.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.linreg_multi_pheno">
<code class="descname">linreg_multi_pheno</code><span class="sig-paren">(</span><em>ys</em>, <em>covariates=[]</em>, <em>root='va.linreg'</em>, <em>use_dosages=False</em>, <em>min_ac=1</em>, <em>min_af=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.linreg_multi_pheno"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.linreg_multi_pheno" title="Permalink to this definition">¶</a></dt>
<dd><p>Test each variant for association with multiple phenotypes using linear regression.</p>
<p>This method runs linear regression for multiple phenotypes more efficiently
than looping over <a class="reference internal" href="#hail.VariantDataset.linreg" title="hail.VariantDataset.linreg"><code class="xref py py-meth docutils literal"><span class="pre">linreg()</span></code></a>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><a class="reference internal" href="#hail.VariantDataset.linreg_multi_pheno" title="hail.VariantDataset.linreg_multi_pheno"><code class="xref py py-meth docutils literal"><span class="pre">linreg_multi_pheno()</span></code></a> uses the same set of samples for each phenotype,
namely the set of samples for which <strong>all</strong> phenotypes and covariates are defined.</p>
</div>
<p><strong>Annotations</strong></p>
<p>With the default root, the following four variant annotations are added.
The indexing of these annotations corresponds to that of <code class="docutils literal"><span class="pre">y</span></code>.</p>
<ul class="simple">
<li><strong>va.linreg.beta</strong> (<em>Array[Double]</em>) &#8211; array of fit genotype coefficients, <span class="math">\(\hat\beta_1\)</span></li>
<li><strong>va.linreg.se</strong> (<em>Array[Double]</em>) &#8211; array of estimated standard errors, <span class="math">\(\widehat{\mathrm{se}}\)</span></li>
<li><strong>va.linreg.tstat</strong> (<em>Array[Double]</em>) &#8211; array of <span class="math">\(t\)</span>-statistics, equal to <span class="math">\(\hat\beta_1 / \widehat{\mathrm{se}}\)</span></li>
<li><strong>va.linreg.pval</strong> (<em>Array[Double]</em>) &#8211; array of <span class="math">\(p\)</span>-values</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ys</strong> &#8211; list of one or more response expressions.</li>
<li><strong>covariates</strong> (<em>list of str</em>) &#8211; list of covariate expressions.</li>
<li><strong>root</strong> (<em>str</em>) &#8211; Variant annotation path to store result of linear regression.</li>
<li><strong>use_dosages</strong> (<em>bool</em>) &#8211; If true, use dosage genotypes rather than hard call genotypes.</li>
<li><strong>min_ac</strong> (<em>int</em>) &#8211; Minimum alternate allele count.</li>
<li><strong>min_af</strong> (<em>float</em>) &#8211; Minimum alternate allele frequency.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Variant dataset with linear regression variant annotations.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.lmmreg">
<code class="descname">lmmreg</code><span class="sig-paren">(</span><em>kinshipMatrix</em>, <em>y</em>, <em>covariates=[]</em>, <em>global_root='global.lmmreg'</em>, <em>va_root='va.lmmreg'</em>, <em>run_assoc=True</em>, <em>use_ml=False</em>, <em>delta=None</em>, <em>sparsity_threshold=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.lmmreg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.lmmreg" title="Permalink to this definition">¶</a></dt>
<dd><p>Use a kinship-based linear mixed model to estimate the genetic component of phenotypic variance (narrow-sense heritability) and optionally test each variant for association.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Examples</strong></p>
<p>Suppose the variant dataset saved at <em>data/example_lmmreg.vds</em> has a Boolean variant annotation <code class="docutils literal"><span class="pre">va.useInKinship</span></code> and numeric or Boolean sample annotations <code class="docutils literal"><span class="pre">sa.pheno</span></code>, <code class="docutils literal"><span class="pre">sa.cov1</span></code>, <code class="docutils literal"><span class="pre">sa.cov2</span></code>. Then the <a class="reference internal" href="#hail.VariantDataset.lmmreg" title="hail.VariantDataset.lmmreg"><code class="xref py py-meth docutils literal"><span class="pre">lmmreg()</span></code></a> function in</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">assoc_vds</span> <span class="o">=</span> <span class="n">hc</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;data/example_lmmreg.vds&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kinship_matrix</span> <span class="o">=</span> <span class="n">assoc_vds</span><span class="o">.</span><span class="n">filter_variants_expr</span><span class="p">(</span><span class="s1">&#39;va.useInKinship&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">rrm</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lmm_vds</span> <span class="o">=</span> <span class="n">assoc_vds</span><span class="o">.</span><span class="n">lmmreg</span><span class="p">(</span><span class="n">kinship_matrix</span><span class="p">,</span> <span class="s1">&#39;sa.pheno&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;sa.cov1&#39;</span><span class="p">,</span> <span class="s1">&#39;sa.cov2&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>will execute the following four steps in order:</p>
<ol class="arabic simple">
<li>filter to samples in given kinship matrix to those for which <code class="docutils literal"><span class="pre">sa.pheno</span></code>, <code class="docutils literal"><span class="pre">sa.cov</span></code>, and <code class="docutils literal"><span class="pre">sa.cov2</span></code> are all defined</li>
<li>compute the eigendecomposition <span class="math">\(K = USU^T\)</span> of the kinship matrix</li>
<li>fit covariate coefficients and variance parameters in the sample-covariates-only (global) model using restricted maximum likelihood (<a class="reference external" href="https://en.wikipedia.org/wiki/Restricted_maximum_likelihood">REML</a>), storing results in global annotations under <code class="docutils literal"><span class="pre">global.lmmreg</span></code></li>
<li>test each variant for association, storing results under <code class="docutils literal"><span class="pre">va.lmmreg</span></code> in variant annotations</li>
</ol>
<p>This plan can be modified as follows:</p>
<ul class="simple">
<li>Set <code class="docutils literal"><span class="pre">run_assoc=False</span></code> to not test any variants for association, i.e. skip Step 5.</li>
<li>Set <code class="docutils literal"><span class="pre">use_ml=True</span></code> to use maximum likelihood instead of REML in Steps 4 and 5.</li>
<li>Set the <code class="docutils literal"><span class="pre">delta</span></code> argument to manually set the value of <span class="math">\(\delta\)</span> rather that fitting <span class="math">\(\delta\)</span> in Step 4.</li>
<li>Set the <code class="docutils literal"><span class="pre">global_root</span></code> argument to change the global annotation root in Step 4.</li>
<li>Set the <code class="docutils literal"><span class="pre">va_root</span></code> argument to change the variant annotation root in Step 5.</li>
</ul>
<p><a class="reference internal" href="#hail.VariantDataset.lmmreg" title="hail.VariantDataset.lmmreg"><code class="xref py py-meth docutils literal"><span class="pre">lmmreg()</span></code></a> adds eight global annotations in Step 4; the last three are omitted if <span class="math">\(\delta\)</span> is set rather than fit.</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="11%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Annotation</th>
<th class="head">Type</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">global.lmmreg.useML</span></code></td>
<td>Boolean</td>
<td>true if fit by ML, false if fit by REML</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">global.lmmreg.beta</span></code></td>
<td>Dict[String, Double]</td>
<td>map from <em>intercept</em> and the given <code class="docutils literal"><span class="pre">covariates</span></code> expressions to the corresponding fit <span class="math">\(\beta\)</span> coefficients</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">global.lmmreg.sigmaG2</span></code></td>
<td>Double</td>
<td>fit coefficient of genetic variance, <span class="math">\(\hat{\sigma}_g^2\)</span></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">global.lmmreg.sigmaE2</span></code></td>
<td>Double</td>
<td>fit coefficient of environmental variance <span class="math">\(\hat{\sigma}_e^2\)</span></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">global.lmmreg.delta</span></code></td>
<td>Double</td>
<td>fit ratio of variance component coefficients, <span class="math">\(\hat{\delta}\)</span></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">global.lmmreg.h2</span></code></td>
<td>Double</td>
<td>fit narrow-sense heritability, <span class="math">\(\hat{h}^2\)</span></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">global.lmmreg.evals</span></code></td>
<td>Array[Double]</td>
<td>eigenvalues of the kinship matrix in descending order</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">global.lmmreg.fit.logDeltaGrid</span></code></td>
<td>Array[Double]</td>
<td>values of <span class="math">\(\mathit{ln}(\delta)\)</span> used in the grid search</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">global.lmmreg.fit.logLkhdVals</span></code></td>
<td>Array[Double]</td>
<td>(restricted) log likelihood of <span class="math">\(y\)</span> given <span class="math">\(X\)</span> and <span class="math">\(\mathit{ln}(\delta)\)</span> at the (RE)ML fit of <span class="math">\(\beta\)</span> and <span class="math">\(\sigma_g^2\)</span></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">global.lmmreg.fit.maxLogLkhd</span></code></td>
<td>Double</td>
<td>(restricted) maximum log likelihood corresponding to the fit delta</td>
</tr>
</tbody>
</table>
<p>These global annotations are also added to <code class="docutils literal"><span class="pre">hail.log</span></code>, with the ranked evals and <span class="math">\(\delta\)</span> grid with values in .tsv tabular form.  Use <code class="docutils literal"><span class="pre">grep</span> <span class="pre">'lmmreg:'</span> <span class="pre">hail.log</span></code> to find the lines just above each table.</p>
<p>If Step 5 is performed, <a class="reference internal" href="#hail.VariantDataset.lmmreg" title="hail.VariantDataset.lmmreg"><code class="xref py py-meth docutils literal"><span class="pre">lmmreg()</span></code></a> also adds four linear regression variant annotations.</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="8%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Annotation</th>
<th class="head">Type</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">va.lmmreg.beta</span></code></td>
<td>Double</td>
<td>fit genotype coefficient, <span class="math">\(\hat\beta_0\)</span></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">va.lmmreg.sigmaG2</span></code></td>
<td>Double</td>
<td>fit coefficient of genetic variance component, <span class="math">\(\hat{\sigma}_g^2\)</span></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">va.lmmreg.chi2</span></code></td>
<td>Double</td>
<td><span class="math">\(\chi^2\)</span> statistic of the likelihood ratio test</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">va.lmmreg.pval</span></code></td>
<td>Double</td>
<td><span class="math">\(p\)</span>-value</td>
</tr>
</tbody>
</table>
<p>Those variants that don&#8217;t vary across the included samples (e.g., all genotypes are HomRef) will have missing annotations.</p>
<p>The simplest way to export all resulting annotations is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lmm_vds</span><span class="o">.</span><span class="n">export_variants</span><span class="p">(</span><span class="s1">&#39;output/lmmreg.tsv.bgz&#39;</span><span class="p">,</span> <span class="s1">&#39;variant = v, va.lmmreg.*&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lmmreg_results</span> <span class="o">=</span> <span class="n">lmm_vds</span><span class="o">.</span><span class="n">globals</span><span class="p">[</span><span class="s1">&#39;lmmreg&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p><strong>Performance</strong></p>
<p>Hail&#8217;s initial version of <a class="reference internal" href="#hail.VariantDataset.lmmreg" title="hail.VariantDataset.lmmreg"><code class="xref py py-meth docutils literal"><span class="pre">lmmreg()</span></code></a> scales to well beyond 10k samples and to an essentially unbounded number of variants, making it particularly well-suited to modern sequencing studies and complementary to tools designed for SNP arrays. The first analysts to apply <a class="reference internal" href="#hail.VariantDataset.lmmreg" title="hail.VariantDataset.lmmreg"><code class="xref py py-meth docutils literal"><span class="pre">lmmreg()</span></code></a> in research computed kinship from 262k common variants and tested 25 million non-rare variants on 8185 whole genomes in 32 minutes. As another example, starting from a VDS of the 1000 Genomes Project (consisting of 2535 whole genomes), <a class="reference internal" href="#hail.VariantDataset.lmmreg" title="hail.VariantDataset.lmmreg"><code class="xref py py-meth docutils literal"><span class="pre">lmmreg()</span></code></a> computes a kinship matrix based on 100k common variants, fits coefficients and variance components in the sample-covariates-only model, runs a linear-mixed-model likelihood ratio test for all 15 million high-quality non-rare variants, and exports the results in 3m42s minutes. Here we used 42 preemptible workers (~680 cores) on 2k partitions at a compute cost of about 50 cents on Google cloud (see <a class="reference external" href="http://discuss.hail.is/t/using-hail-on-the-google-cloud-platform/80">Using Hail on the Google Cloud Platform</a>).</p>
<p>While <a class="reference internal" href="#hail.VariantDataset.lmmreg" title="hail.VariantDataset.lmmreg"><code class="xref py py-meth docutils literal"><span class="pre">lmmreg()</span></code></a> computes the kinship matrix <span class="math">\(K\)</span> using distributed matrix multiplication (Step 2), the full <a class="reference external" href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix">eigendecomposition</a> (Step 3) is currently run on a single core of master using the <a class="reference external" href="http://www.netlib.org/lapack/explore-html/d2/d8a/group__double_s_yeigen_ga694ddc6e5527b6223748e3462013d867.html">LAPACK routine DSYEVD</a>, which we empirically find to be the most performant of the four available routines; laptop performance plots showing cubic complexity in <span class="math">\(n\)</span> are available <a class="reference external" href="https://github.com/hail-is/hail/pull/906">here</a>. On Google cloud, eigendecomposition takes about 2 seconds for 2535 sampes and 1 minute for 8185 samples. If you see worse performance, check that LAPACK natives are being properly loaded (see &#8220;BLAS and LAPACK&#8221; in Getting Started).</p>
<p>Given the eigendecomposition, fitting the global model (Step 4) takes on the order of a few seconds on master. Association testing (Step 5) is fully distributed by variant with per-variant time complexity that is completely independent of the number of sample covariates and dominated by multiplication of the genotype vector <span class="math">\(v\)</span> by the matrix of eigenvectors <span class="math">\(U^T\)</span> as described below, which we accelerate with a sparse representation of <span class="math">\(v\)</span>.  The matrix <span class="math">\(U^T\)</span> has size about <span class="math">\(8n^2\)</span> bytes and is currently broadcast to each Spark executor. For example, with 15k samples, storing <span class="math">\(U^T\)</span> consumes about 3.6GB of memory on a 16-core worker node with two 8-core executors. So for large <span class="math">\(n\)</span>, we recommend using a high-memory configuration such as <code class="docutils literal"><span class="pre">highmem</span></code> workers.</p>
<p><strong>Linear mixed model</strong></p>
<p><a class="reference internal" href="#hail.VariantDataset.lmmreg" title="hail.VariantDataset.lmmreg"><code class="xref py py-meth docutils literal"><span class="pre">lmmreg()</span></code></a> estimates the genetic proportion of residual phenotypic variance (narrow-sense heritability) under a kinship-based linear mixed model, and then optionally tests each variant for association using the likelihood ratio test. Inference is exact.</p>
<p>We first describe the sample-covariates-only model used to estimate heritability, which we simply refer to as the <em>global model</em>. With <span class="math">\(n\)</span> samples and <span class="math">\(c\)</span> sample covariates, we define:</p>
<ul class="simple">
<li><span class="math">\(y = n \times 1\)</span> vector of phenotypes</li>
<li><span class="math">\(X = n \times c\)</span> matrix of sample covariates and intercept column of ones</li>
<li><span class="math">\(K = n \times n\)</span> kinship matrix</li>
<li><span class="math">\(I = n \times n\)</span> identity matrix</li>
<li><span class="math">\(\beta = c \times 1\)</span> vector of covariate coefficients</li>
<li><span class="math">\(\sigma_g^2 =\)</span> coefficient of genetic variance component <span class="math">\(K\)</span></li>
<li><span class="math">\(\sigma_e^2 =\)</span> coefficient of environmental variance component <span class="math">\(I\)</span></li>
<li><span class="math">\(\delta = \frac{\sigma_e^2}{\sigma_g^2} =\)</span> ratio of environmental and genetic variance component coefficients</li>
<li><span class="math">\(h^2 = \frac{\sigma_g^2}{\sigma_g^2 + \sigma_e^2} = \frac{1}{1 + \delta} =\)</span> genetic proportion of residual phenotypic variance</li>
</ul>
<p>Under a linear mixed model, <span class="math">\(y\)</span> is sampled from the <span class="math">\(n\)</span>-dimensional <a class="reference external" href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution">multivariate normal distribution</a> with mean <span class="math">\(X \beta\)</span> and variance components that are scalar multiples of <span class="math">\(K\)</span> and <span class="math">\(I\)</span>:</p>
<div class="math">
\[y \sim \mathrm{N}\left(X\beta, \sigma_g^2 K + \sigma_e^2 I\right)\]</div>
<p>Thus the model posits that the residuals <span class="math">\(y_i - X_{i,:}\beta\)</span> and <span class="math">\(y_j - X_{j,:}\beta\)</span> have covariance <span class="math">\(\sigma_g^2 K_{ij}\)</span> and approximate correlation <span class="math">\(h^2 K_{ij}\)</span>. Informally: phenotype residuals are correlated as the product of overall heritability and pairwise kinship. By contrast, standard (unmixed) linear regression is equivalent to fixing <span class="math">\(\sigma_2\)</span> (equivalently, <span class="math">\(h^2\)</span>) at 0 above, so that all phenotype residuals are independent.</p>
<p><strong>Caution:</strong> while it is tempting to interpret <span class="math">\(h^2\)</span> as the <a class="reference external" href="https://en.wikipedia.org/wiki/Heritability#Definition">narrow-sense heritability</a> of the phenotype alone, note that its value depends not only the phenotype and genetic data, but also on the choice of sample covariates.</p>
<p><strong>Fitting the global model</strong></p>
<p>The core algorithm is essentially a distributed implementation of the spectral approach taken in <a class="reference external" href="https://www.microsoft.com/en-us/research/project/fastlmm/">FastLMM</a>. Let <span class="math">\(K = USU^T\)</span> be the <a class="reference external" href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix#Real_symmetric_matrices">eigendecomposition</a> of the real symmetric matrix <span class="math">\(K\)</span>. That is:</p>
<ul class="simple">
<li><span class="math">\(U = n \times n\)</span> orthonormal matrix whose columns are the eigenvectors of <span class="math">\(K\)</span></li>
<li><span class="math">\(S = n \times n\)</span> diagonal matrix of eigenvalues of <span class="math">\(K\)</span> in descending order. <span class="math">\(S_{ii}\)</span> is the eigenvalue of eigenvector <span class="math">\(U_{:,i}\)</span></li>
<li><span class="math">\(U^T = n \times n\)</span> orthonormal matrix, the transpose (and inverse) of <span class="math">\(U\)</span></li>
</ul>
<p>A bit of matrix algebra on the multivariate normal density shows that the linear mixed model above is mathematically equivalent to the model</p>
<div class="math">
\[U^Ty \sim \mathrm{N}\left(U^TX\beta, \sigma_g^2 (S + \delta I)\right)\]</div>
<p>for which the covariance is diagonal (e.g., unmixed). That is, rotating the phenotype vector (<span class="math">\(y\)</span>) and covariate vectors (columns of <span class="math">\(X\)</span>) in <span class="math">\(\mathbb{R}^n\)</span> by <span class="math">\(U^T\)</span> transforms the model to one with independent residuals. For any particular value of <span class="math">\(\delta\)</span>, the restricted maximum likelihood (REML) solution for the latter model can be solved exactly in time complexity that is linear rather than cubic in <span class="math">\(n\)</span>.  In particular, having rotated, we can run a very efficient 1-dimensional optimization procedure over <span class="math">\(\delta\)</span> to find the REML estimate <span class="math">\((\hat{\delta}, \hat{\beta}, \hat{\sigma}_g^2)\)</span> of the triple <span class="math">\((\delta, \beta, \sigma_g^2)\)</span>, which in turn determines <span class="math">\(\hat{\sigma}_e^2\)</span> and <span class="math">\(\hat{h}^2\)</span>.</p>
<p>We first compute the maximum log likelihood on a <span class="math">\(\delta\)</span>-grid that is uniform on the log scale, with <span class="math">\(\mathit{ln}(\delta)\)</span> running from -10 to 10 by 0.01, corresponding to <span class="math">\(h^2\)</span> decreasing from 0.999999998 to 0.000000002. If <span class="math">\(h^2\)</span> is maximized at the lower boundary then standard linear regression would be more appropriate and Hail will exit; more generally, consider using standard linear regression when <span class="math">\(\hat{h}^2\)</span> is very small. A maximum at the upper boundary is highly suspicious and will also cause Hail to exit, with the <code class="docutils literal"><span class="pre">hail.log</span></code> recording all values over the grid for further inspection.</p>
<p>If the optimal grid point falls in the interior of the grid as expected, we then use <a class="reference external" href="https://en.wikipedia.org/wiki/Brent%27s_method">Brent&#8217;s method</a> to find the precise location of the maximum over the same range, with initial guess given by the optimal grid point and a tolerance on <span class="math">\(\mathit{ln}(\delta)\)</span> of 1e-6. If this location differs from the optimal grid point by more than .01, a warning will be displayed and logged, and one would be wise to investigate by plotting the values over the grid. Note that <span class="math">\(h^2\)</span> is related to <span class="math">\(\mathit{ln}(\delta)\)</span> through the <a class="reference external" href="https://en.wikipedia.org/wiki/Sigmoid_function">sigmoid function</a>. Hence one can change variables to extract a high-resolution discretization of the likelihood function of <span class="math">\(h^2\)</span> over <span class="math">\([0,1]\)</span> at the corresponding REML estimators for <span class="math">\(\beta\)</span> and <span class="math">\(\sigma_g^2\)</span>.</p>
<p><strong>Testing each variant for association</strong></p>
<p>Fixing a single variant, we define:</p>
<ul class="simple">
<li><span class="math">\(v = n \times 1\)</span> vector of genotypes, with missing genotypes imputed as the mean of called genotypes</li>
<li><span class="math">\(X_v = \left[v | X \right] = n \times (1 + c)\)</span> matrix concatenating <span class="math">\(v\)</span> and <span class="math">\(X\)</span></li>
<li><span class="math">\(\beta_v = (\beta^0_v, \beta^1_v, \ldots, \beta^c_v) = (1 + c) \times 1\)</span> vector of covariate coefficients</li>
</ul>
<p>Fixing <span class="math">\(\delta\)</span> at the global REML estimate <span class="math">\(\hat{\delta}\)</span>, we find the REML estimate <span class="math">\((\hat{\beta}_v, \hat{\sigma}_{g,v}^2)\)</span> via rotation of the model</p>
<div class="math">
\[y \sim \mathrm{N}\left(X_v\beta_v, \sigma_{g,v}^2 (K + \hat{\delta} I)\right)\]</div>
<p>Note that the only new rotation to compute here is <span class="math">\(U^T v\)</span>.</p>
<p>To test the null hypothesis that the genotype coefficient <span class="math">\(\beta^0_v\)</span> is zero, we consider the restricted model with parameters <span class="math">\(((0, \beta^1_v, \ldots, \beta^c_v), \sigma_{g,v}^2)\)</span> within the full model with parameters <span class="math">\((\beta^0_v, \beta^1_v, \ldots, \beta^c_v), \sigma_{g_v}^2)\)</span>, with <span class="math">\(\delta\)</span> fixed at <span class="math">\(\hat\delta\)</span> in both. The latter fit is simply that of the global model, <span class="math">\(((0, \hat{\beta}^1, \ldots, \hat{\beta}^c), \hat{\sigma}_g^2)\)</span>. The likelihood ratio test statistic is given by</p>
<div class="math">
\[\chi^2 = n \, \mathit{ln}\left(\frac{\hat{\sigma}^2_g}{\hat{\sigma}_{g,v}^2}\right)\]</div>
<p>and follows a chi-squared distribution with one degree of freedom. Here the ratio <span class="math">\(\hat{\sigma}^2_g / \hat{\sigma}_{g,v}^2\)</span> captures the degree to which adding the variant <span class="math">\(v\)</span> to the global model reduces the residual phenotypic variance.</p>
<p><strong>Kinship Matrix</strong></p>
<p>FastLMM uses the Realized Relationship Matrix (RRM) for kinship. This can be computed with <a class="reference internal" href="#hail.VariantDataset.rrm" title="hail.VariantDataset.rrm"><code class="xref py py-meth docutils literal"><span class="pre">rrm()</span></code></a>. However, any instance of <a class="reference internal" href="hail.KinshipMatrix.html#hail.KinshipMatrix" title="hail.KinshipMatrix"><code class="xref py py-class docutils literal"><span class="pre">KinshipMatrix</span></code></a> may be used, so long as <code class="docutils literal"><span class="pre">sample_list</span></code> contains the complete samples of the caller variant dataset in the same order.</p>
<p><strong>Further background</strong></p>
<p>For the history and mathematics of linear mixed models in genetics, including <a class="reference external" href="https://www.microsoft.com/en-us/research/project/fastlmm/">FastLMM</a>, see <a class="reference external" href="https://publikationen.uni-tuebingen.de/xmlui/bitstream/handle/10900/50003/pdf/thesis_komplett.pdf">Christoph Lippert&#8217;s PhD thesis</a>. For an investigation of various approaches to defining kinship, see <a class="reference external" href="http://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1004445">Comparison of Methods to Account for Relatedness in Genome-Wide Association Studies with Family-Based Data</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>kinshipMatrix</strong> (<a class="reference internal" href="hail.KinshipMatrix.html#hail.KinshipMatrix" title="hail.KinshipMatrix"><code class="xref py py-class docutils literal"><span class="pre">KinshipMatrix</span></code></a>) &#8211; Kinship matrix to be used.</li>
<li><strong>y</strong> (<em>str</em>) &#8211; Response sample annotation.</li>
<li><strong>covariates</strong> (<em>list of str</em>) &#8211; List of covariate sample annotations.</li>
<li><strong>global_root</strong> (<em>str</em>) &#8211; Global annotation root, a period-delimited path starting with <cite>global</cite>.</li>
<li><strong>va_root</strong> (<em>str</em>) &#8211; Variant annotation root, a period-delimited path starting with <cite>va</cite>.</li>
<li><strong>run_assoc</strong> (<em>bool</em>) &#8211; If True, run association testing in addition to fitting the global model.</li>
<li><strong>use_ml</strong> (<em>bool</em>) &#8211; Use ML instead of REML throughout.</li>
<li><strong>delta</strong> (<em>float</em><em> or </em><em>None</em>) &#8211; Fixed delta value to use in the global model, overrides fitting delta.</li>
<li><strong>sparsity_threshold</strong> (<em>float</em>) &#8211; AF threshold above which to use dense genotype vectors in rotation (advanced).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Variant dataset with linear mixed regression annotations.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.logreg">
<code class="descname">logreg</code><span class="sig-paren">(</span><em>test</em>, <em>y</em>, <em>covariates=[]</em>, <em>root='va.logreg'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.logreg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.logreg" title="Permalink to this definition">¶</a></dt>
<dd><p>Test each variant for association using logistic regression.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Examples</strong></p>
<p>Run the logistic regression Wald test per variant using a phenotype and two covariates stored in sample annotations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">logreg</span><span class="p">(</span><span class="s1">&#39;wald&#39;</span><span class="p">,</span> <span class="s1">&#39;sa.pheno.isCase&#39;</span><span class="p">,</span> <span class="n">covariates</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sa.pheno.age&#39;</span><span class="p">,</span> <span class="s1">&#39;sa.pheno.isFemale&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>The <a class="reference internal" href="#hail.VariantDataset.logreg" title="hail.VariantDataset.logreg"><code class="xref py py-meth docutils literal"><span class="pre">logreg()</span></code></a> command performs,
for each variant, a significance test of the genotype in
predicting a binary (case-control) phenotype based on the
logistic regression model. Hail supports the Wald test (&#8216;wald&#8217;),
likelihood ratio test (&#8216;lrt&#8217;), Rao score test (&#8216;score&#8217;), and Firth test (&#8216;firth&#8217;). Hail only
includes samples for which the phenotype and all covariates are
defined. For each variant, Hail imputes missing genotypes as
the mean of called genotypes.</p>
<p>The example above considers a model of the form</p>
<div class="math">
\[\mathrm{Prob}(\mathrm{isCase}) = \mathrm{sigmoid}(\beta_0 + \beta_1 \, \mathrm{gt} + \beta_2 \, \mathrm{age} + \beta_3 \, \mathrm{isFemale} + \varepsilon), \quad \varepsilon \sim \mathrm{N}(0, \sigma^2)\]</div>
<p>where <span class="math">\(\mathrm{sigmoid}\)</span> is the <a class="reference external" href="https://en.wikipedia.org/wiki/Sigmoid_function">sigmoid
function</a>, the
genotype <span class="math">\(\mathrm{gt}\)</span> is coded as 0 for HomRef, 1 for
Het, and 2 for HomVar, and the Boolean covariate
<span class="math">\(\mathrm{isFemale}\)</span> is coded as 1 for true (female) and
0 for false (male). The null model sets <span class="math">\(\beta_1 = 0\)</span>.</p>
<p>The resulting variant annotations depend on the test statistic
as shown in the tables below.</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="17%" />
<col width="5%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Test</th>
<th class="head">Annotation</th>
<th class="head">Type</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Wald</td>
<td><code class="docutils literal"><span class="pre">va.logreg.beta</span></code></td>
<td>Double</td>
<td>fit genotype coefficient, <span class="math">\(\hat\beta_1\)</span></td>
</tr>
<tr class="row-odd"><td>Wald</td>
<td><code class="docutils literal"><span class="pre">va.logreg.se</span></code></td>
<td>Double</td>
<td>estimated standard error, <span class="math">\(\widehat{\mathrm{se}}\)</span></td>
</tr>
<tr class="row-even"><td>Wald</td>
<td><code class="docutils literal"><span class="pre">va.logreg.zstat</span></code></td>
<td>Double</td>
<td>Wald <span class="math">\(z\)</span>-statistic, equal to <span class="math">\(\hat\beta_1 / \widehat{\mathrm{se}}\)</span></td>
</tr>
<tr class="row-odd"><td>Wald</td>
<td><code class="docutils literal"><span class="pre">va.logreg.pval</span></code></td>
<td>Double</td>
<td>Wald p-value testing <span class="math">\(\beta_1 = 0\)</span></td>
</tr>
<tr class="row-even"><td>LRT, Firth</td>
<td><code class="docutils literal"><span class="pre">va.logreg.beta</span></code></td>
<td>Double</td>
<td>fit genotype coefficient, <span class="math">\(\hat\beta_1\)</span></td>
</tr>
<tr class="row-odd"><td>LRT, Firth</td>
<td><code class="docutils literal"><span class="pre">va.logreg.chi2</span></code></td>
<td>Double</td>
<td>deviance statistic</td>
</tr>
<tr class="row-even"><td>LRT, Firth</td>
<td><code class="docutils literal"><span class="pre">va.logreg.pval</span></code></td>
<td>Double</td>
<td>LRT / Firth p-value testing <span class="math">\(\beta_1 = 0\)</span></td>
</tr>
<tr class="row-odd"><td>Score</td>
<td><code class="docutils literal"><span class="pre">va.logreg.chi2</span></code></td>
<td>Double</td>
<td>score statistic</td>
</tr>
<tr class="row-even"><td>Score</td>
<td><code class="docutils literal"><span class="pre">va.logreg.pval</span></code></td>
<td>Double</td>
<td>score p-value testing <span class="math">\(\beta_1 = 0\)</span></td>
</tr>
</tbody>
</table>
<p>For the Wald and likelihood ratio tests, Hail fits the logistic model for each variant using Newton iteration and only emits the above annotations when the maximum likelihood estimate of the coefficients converges. The Firth test uses a modified form of Newton iteration. To help diagnose convergence issues, Hail also emits three variant annotations which summarize the iterative fitting process:</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="18%" />
<col width="5%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Test</th>
<th class="head">Annotation</th>
<th class="head">Type</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Wald, LRT, Firth</td>
<td><code class="docutils literal"><span class="pre">va.logreg.fit.nIter</span></code></td>
<td>Int</td>
<td>number of iterations until convergence, explosion, or reaching the max (25 for Wald, LRT; 100 for Firth)</td>
</tr>
<tr class="row-odd"><td>Wald, LRT, Firth</td>
<td><code class="docutils literal"><span class="pre">va.logreg.fit.converged</span></code></td>
<td>Boolean</td>
<td>true if iteration converged</td>
</tr>
<tr class="row-even"><td>Wald, LRT, Firth</td>
<td><code class="docutils literal"><span class="pre">va.logreg.fit.exploded</span></code></td>
<td>Boolean</td>
<td>true if iteration exploded</td>
</tr>
</tbody>
</table>
<p>We consider iteration to have converged when every coordinate of <span class="math">\(\beta\)</span> changes by less than <span class="math">\(10^{-6}\)</span>. For Wald and LRT, up to 25 iterations are attempted; in testing we find 4 or 5 iterations nearly always suffice. Convergence may also fail due to explosion, which refers to low-level numerical linear algebra exceptions caused by manipulating ill-conditioned matrices. Explosion may result from (nearly) linearly dependent covariates or complete <a class="reference external" href="https://en.wikipedia.org/wiki/Separation_(statistics)">separation</a>.</p>
<p>A more common situation in genetics is quasi-complete seperation, e.g. variants that are observed only in cases (or controls). Such variants inevitably arise when testing millions of variants with very low minor allele count. The maximum likelihood estimate of <span class="math">\(\beta\)</span> under logistic regression is then undefined but convergence may still occur after a large number of iterations due to a very flat likelihood surface. In testing, we find that such variants produce a secondary bump from 10 to 15 iterations in the histogram of number of iterations per variant. We also find that this faux convergence produces large standard errors and large (insignificant) p-values. To not miss such variants, consider using Firth logistic regression, linear regression, or group-based tests.</p>
<p>Here&#8217;s a concrete illustration of quasi-complete seperation in R. Suppose we have 2010 samples distributed as follows for a particular variant:</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="27%" />
<col width="14%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Status</th>
<th class="head">HomRef</th>
<th class="head">Het</th>
<th class="head">HomVar</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Case</td>
<td>1000</td>
<td>10</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Control</td>
<td>1000</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>The following R code fits the (standard) logistic, Firth logistic, and linear regression models to this data, where <code class="docutils literal"><span class="pre">x</span></code> is genotype, <code class="docutils literal"><span class="pre">y</span></code> is phenotype, and <code class="docutils literal"><span class="pre">logistf</span></code> is from the logistf package:</p>
<div class="highlight-R"><div class="highlight"><pre><span></span>x <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="kp">rep</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1000</span><span class="p">),</span> <span class="kp">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1000</span><span class="p">),</span> <span class="kp">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">10</span><span class="p">)</span>
y <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="kp">rep</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1000</span><span class="p">),</span> <span class="kp">rep</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1000</span><span class="p">),</span> <span class="kp">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">10</span><span class="p">))</span>
logfit <span class="o">&lt;-</span> glm<span class="p">(</span>y <span class="o">~</span> x<span class="p">,</span> family<span class="o">=</span>binomial<span class="p">())</span>
firthfit <span class="o">&lt;-</span> logistf<span class="p">(</span>y <span class="o">~</span> x<span class="p">)</span>
linfit <span class="o">&lt;-</span> lm<span class="p">(</span>y <span class="o">~</span> x<span class="p">)</span>
</pre></div>
</div>
<p>The resulting p-values for the genotype coefficient are 0.991, 0.00085, and 0.0016, respectively. The erroneous value 0.991 is due to quasi-complete separation. Moving one of the 10 hets from case to control eliminates this quasi-complete separation; the p-values from R are then 0.0373, 0.0111, and 0.0116, respectively, as expected for a less significant association.</p>
<p>The Firth test reduces bias from small counts and resolves the issue of separation by penalizing maximum likelihood estimation by the <a class="reference external" href="https://en.wikipedia.org/wiki/Jeffreys_prior">Jeffrey&#8217;s invariant prior</a>. This test is slower, as both the null and full model must be fit per variant, and convergence of the modified Newton method is linear rather than quadratic. For Firth, 100 iterations are attempted for the null model and, if that is successful, for the full model as well. In testing we find 20 iterations nearly always suffices. If the null model fails to converge, then the <code class="docutils literal"><span class="pre">sa.lmmreg.fit</span></code> annotations reflect the null model; otherwise, they reflect the full model.</p>
<p>See <a class="reference external" href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC4049324/">Recommended joint and meta-analysis strategies for case-control association testing of single low-count variants</a> for an empirical comparison of the logistic Wald, LRT, score, and Firth tests. The theoretical foundations of the Wald, likelihood ratio, and score tests may be found in Chapter 3 of Gesine Reinert&#8217;s notes <a class="reference external" href="http://www.stats.ox.ac.uk/~reinert/stattheory/theoryshort09.pdf">Statistical Theory</a>.  Firth introduced his approach in <a class="reference external" href="http://www2.stat.duke.edu/~scs/Courses/Stat376/Papers/GibbsFieldEst/BiasReductionMLE.pdf">Bias reduction of maximum likelihood estimates, 1993</a>. Heinze and Schemper further analyze Firth&#8217;s approach in <a class="reference external" href="https://cemsiis.meduniwien.ac.at/fileadmin/msi_akim/CeMSIIS/KB/volltexte/Heinze_Schemper_2002_Statistics_in_Medicine.pdf">A solution to the problem of separation in logistic regression, 2002</a>.</p>
<p>Phenotype and covariate sample annotations may also be specified using <a class="reference external" href="exprlang.html">programmatic expressions</a> without identifiers, such as:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>if (sa.isFemale) sa.cov.age else (2 * sa.cov.age + 10)
</pre></div>
</div>
<p>For Boolean covariate types, true is coded as 1 and false as 0. In particular, for the sample annotation <code class="docutils literal"><span class="pre">sa.fam.isCase</span></code> added by importing a FAM file with case-control phenotype, case is 1 and control is 0.</p>
<p>Hail&#8217;s logistic regression tests correspond to the <code class="docutils literal"><span class="pre">b.wald</span></code>, <code class="docutils literal"><span class="pre">b.lrt</span></code>, and <code class="docutils literal"><span class="pre">b.score</span></code> tests in <a class="reference external" href="http://genome.sph.umich.edu/wiki/EPACTS#Single_Variant_Tests">EPACTS</a>. For each variant, Hail imputes missing genotypes as the mean of called genotypes, whereas EPACTS subsets to those samples with called genotypes. Hence, Hail and EPACTS results will currently only agree for variants with no missing genotypes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<em>str</em>) &#8211; Statistical test, one of: &#8216;wald&#8217;, &#8216;lrt&#8217;, &#8216;score&#8217;, or &#8216;firth&#8217;.</li>
<li><strong>y</strong> (<em>str</em>) &#8211; Response expression.  Must evaluate to Boolean or
numeric with all values 0 or 1.</li>
<li><strong>covariates</strong> (<em>list of str</em>) &#8211; list of covariate expressions</li>
<li><strong>root</strong> (<em>str</em>) &#8211; Variant annotation path to store result of linear regression.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Variant dataset with logistic regression variant annotations.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.make_keytable">
<code class="descname">make_keytable</code><span class="sig-paren">(</span><em>variant_expr</em>, <em>genotype_expr</em>, <em>key=[]</em>, <em>separator='.'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.make_keytable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.make_keytable" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a KeyTable with one row per variant.</p>
<p>Per sample field names in the result are formed by
concatenating the sample ID with the <code class="docutils literal"><span class="pre">genotype_expr</span></code> left
hand side with <code class="docutils literal"><span class="pre">seperator</span></code> (default: dot (.)).  If the left
hand side is empty:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>`` = expr
</pre></div>
</div>
<p>then the dot (.) is ommited.</p>
<p><strong>Examples</strong></p>
<p>Consider a <a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a> <code class="docutils literal"><span class="pre">vds</span></code> with 2 variants and 3 samples:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Variant       FORMAT  A       B       C
1:1:A:T       GT:GQ   0/1:99  ./.     0/0:99
1:2:G:C       GT:GQ   0/1:89  0/1:99  1/1:93
</pre></div>
</div>
<p>Then:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kt</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">make_keytable</span><span class="p">(</span><span class="s1">&#39;v = v&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;gt = g.gt&#39;</span><span class="p">,</span> <span class="s1">&#39;gq = g.gq&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>returns a <a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a> with schema</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>v: Variant
A.gt: Int
B.gt: Int
C.gt: Int
A.gq: Int
B.gq: Int
C.gq: Int
</pre></div>
</div>
<p>in particular, the values would be</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>v   A.gt    B.gt    C.gt    A.gq    B.gq    C.gq
1:1:A:T     1       NA      0       99      NA      99
1:2:G:C     1       1       2       89      99      93
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variant_expr</strong> (<em>str</em><em> or </em><em>list of str</em>) &#8211; Variant annotation expressions.</li>
<li><strong>genotype_expr</strong> (<em>str</em><em> or </em><em>list of str</em>) &#8211; Genotype annotation expressions.</li>
<li><strong>key</strong> (<em>str</em><em> or </em><em>list of str</em>) &#8211; List of key columns.</li>
<li><strong>separator</strong> (<em>str</em>) &#8211; Seperator to use between sample IDs and genotype expression left hand side identifiers.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.mendel_errors">
<code class="descname">mendel_errors</code><span class="sig-paren">(</span><em>output</em>, <em>fam</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.mendel_errors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.mendel_errors" title="Permalink to this definition">¶</a></dt>
<dd><p>Find Mendel errors; count per variant, individual and nuclear
family.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Examples</strong></p>
<p>Find all violations of Mendelian inheritance in each (dad,
mom, kid) trio in <em>trios.fam</em> and save results to files with root <code class="docutils literal"><span class="pre">mydata</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">mendel_errors</span><span class="p">(</span><span class="s1">&#39;output/genomes&#39;</span><span class="p">,</span> <span class="s1">&#39;data/trios.fam&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>The code above outputs four TSV files according to the <a class="reference external" href="https://www.cog-genomics.org/plink2/formats#mendel">PLINK mendel
formats</a>:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">mydata.mendel</span></code> &#8211; all mendel errors: FID KID CHR SNP CODE ERROR</li>
<li><code class="docutils literal"><span class="pre">mydata.fmendel</span></code> &#8211; error count per nuclear family: FID PAT MAT CHLD N NSNP</li>
<li><code class="docutils literal"><span class="pre">mydata.imendel</span></code> &#8211; error count per individual: FID IID N NSNP</li>
<li><code class="docutils literal"><span class="pre">mydata.lmendel</span></code> &#8211; error count per variant: CHR SNP N</li>
</ul>
<p><strong>FID</strong>, <strong>KID</strong>, <strong>PAT</strong>, <strong>MAT</strong>, and <strong>IID</strong> refer to family, kid,
dad, mom, and individual ID, respectively, with missing values set to
<code class="docutils literal"><span class="pre">0</span></code>.</p>
<p>SNP denotes the variant identifier <code class="docutils literal"><span class="pre">chr:pos:ref:alt</span></code>.</p>
<p>N counts all errors, while NSNP only counts SNP errors (NSNP is not in Plink).</p>
<p>CHLD is the number of children in a nuclear family.</p>
<p>The CODE of each Mendel error is determined by the table below,
extending the <a class="reference external" href="https://www.cog-genomics.org/plink2/basic_stats#mendel">Plink
classification</a>.</p>
<p>Those individuals implicated by each code are in bold.</p>
<p>The copy state of a locus with respect to a trio is defined as follows,
where PAR is the <a class="reference external" href="https://en.wikipedia.org/wiki/Pseudoautosomal_region">pseudoautosomal region</a> (PAR).</p>
<ul class="simple">
<li>HemiX &#8211; in non-PAR of X, male child</li>
<li>HemiY &#8211; in non-PAR of Y, male child</li>
<li>Auto &#8211; otherwise (in autosome or PAR, or female child)</li>
</ul>
<p>Any refers to <span class="math">\(\{ HomRef, Het, HomVar, NoCall \}\)</span> and ! denotes complement in this set.</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="20%" />
<col width="20%" />
<col width="17%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Code</th>
<th class="head">Dad</th>
<th class="head">Mom</th>
<th class="head">Kid</th>
<th class="head">Copy State</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>HomVar</td>
<td>HomVar</td>
<td>Het</td>
<td>Auto</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>HomRef</td>
<td>HomRef</td>
<td>Het</td>
<td>Auto</td>
</tr>
<tr class="row-even"><td>3</td>
<td>HomRef</td>
<td>! HomRef</td>
<td>HomVar</td>
<td>Auto</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>! HomRef</td>
<td>HomRef</td>
<td>HomVar</td>
<td>Auto</td>
</tr>
<tr class="row-even"><td>5</td>
<td>HomRef</td>
<td>HomRef</td>
<td>HomVar</td>
<td>Auto</td>
</tr>
<tr class="row-odd"><td>6</td>
<td>HomVar</td>
<td>! HomVar</td>
<td>HomRef</td>
<td>Auto</td>
</tr>
<tr class="row-even"><td>7</td>
<td>! HomVar</td>
<td>HomVar</td>
<td>HomRef</td>
<td>Auto</td>
</tr>
<tr class="row-odd"><td>8</td>
<td>HomVar</td>
<td>HomVar</td>
<td>HomRef</td>
<td>Auto</td>
</tr>
<tr class="row-even"><td>9</td>
<td>Any</td>
<td>HomVar</td>
<td>HomRef</td>
<td>HemiX</td>
</tr>
<tr class="row-odd"><td>10</td>
<td>Any</td>
<td>HomRef</td>
<td>HomVar</td>
<td>HemiX</td>
</tr>
<tr class="row-even"><td>11</td>
<td>HomVar</td>
<td>Any</td>
<td>HomRef</td>
<td>HemiY</td>
</tr>
<tr class="row-odd"><td>12</td>
<td>HomRef</td>
<td>Any</td>
<td>HomVar</td>
<td>HemiY</td>
</tr>
</tbody>
</table>
<p>This method only considers children with two parents and a defined sex.</p>
<p>PAR is currently defined with respect to reference
<a class="reference external" href="http://www.ncbi.nlm.nih.gov/projects/genome/assembly/grc/human/">GRCh37</a>:</p>
<ul class="simple">
<li>X: 60001 - 2699520, 154931044 - 155260560</li>
<li>Y: 10001 - 2649520, 59034050 - 59363566</li>
</ul>
<p>This method assumes all contigs apart from X and Y are fully autosomal;
mitochondria, decoys, etc. are not given special treatment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>output</strong> (<em>str</em>) &#8211; Output root filename.</li>
<li><strong>fam</strong> (<em>str</em>) &#8211; Path to .fam file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.min_rep">
<code class="descname">min_rep</code><span class="sig-paren">(</span><em>max_shift=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.min_rep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.min_rep" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives minimal, left-aligned representation of alleles. Note that this can change the variant position.</p>
<p><strong>Examples</strong></p>
<p>1. Simple trimming of a multi-allelic site, no change in variant position
<cite>1:10000:TAA:TAA,AA</cite> =&gt; <cite>1:10000:TA:T,A</cite></p>
<p>2. Trimming of a bi-allelic site leading to a change in position
<cite>1:10000:AATAA,AAGAA</cite> =&gt; <cite>1:10002:T:G</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>max_shift</strong> (<em>int</em>) &#8211; maximum number of base pairs by which
a split variant can move.  Affects memory usage, and will
cause Hail to throw an error if a variant that moves further
is encountered.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.num_partitions">
<code class="descname">num_partitions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.num_partitions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.num_partitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of partitions.</p>
<p><strong>Notes</strong></p>
<p>The data in a variant dataset is divided into chunks called partitions, which may be stored together or across a network, so that each partition may be read and processed in parallel by available cores. Partitions are a core concept of distributed computation in Spark, see <a class="reference external" href="http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds">here</a> for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="hail.VariantDataset.num_samples">
<code class="descname">num_samples</code><a class="headerlink" href="#hail.VariantDataset.num_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of samples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.pca">
<code class="descname">pca</code><span class="sig-paren">(</span><em>scores</em>, <em>loadings=None</em>, <em>eigenvalues=None</em>, <em>k=10</em>, <em>as_array=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.pca"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.pca" title="Permalink to this definition">¶</a></dt>
<dd><p>Run Principal Component Analysis (PCA) on the matrix of genotypes.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Examples</strong></p>
<p>Compute the top 10 principal component scores, stored as sample annotations <code class="docutils literal"><span class="pre">sa.scores.PC1</span></code>, ..., <code class="docutils literal"><span class="pre">sa.scores.PC10</span></code> of type Double:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">pca</span><span class="p">(</span><span class="s1">&#39;sa.scores&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute the top 5 principal component scores, loadings, and eigenvalues, stored as annotations <code class="docutils literal"><span class="pre">sa.scores</span></code>, <code class="docutils literal"><span class="pre">va.loadings</span></code>, and <code class="docutils literal"><span class="pre">global.evals</span></code> of type Array[Double]:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">pca</span><span class="p">(</span><span class="s1">&#39;sa.scores&#39;</span><span class="p">,</span> <span class="s1">&#39;va.loadings&#39;</span><span class="p">,</span> <span class="s1">&#39;global.evals&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">as_array</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>Hail supports principal component analysis (PCA) of genotype data, a now-standard procedure <a class="reference external" href="http://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.0020190">Patterson, Price and Reich, 2006</a>. This method expects a variant dataset with biallelic autosomal variants. Scores are computed and stored as sample annotations of type Struct by default; variant loadings and eigenvalues can optionally be computed and stored in variant and global annotations, respectively.</p>
<p>PCA is based on the singular value decomposition (SVD) of a standardized genotype matrix <span class="math">\(M\)</span>, computed as follows. An <span class="math">\(n \times m\)</span> matrix <span class="math">\(C\)</span> records raw genotypes, with rows indexed by <span class="math">\(n\)</span> samples and columns indexed by <span class="math">\(m\)</span> bialellic autosomal variants; <span class="math">\(C_{ij}\)</span> is the number of alternate alleles of variant <span class="math">\(j\)</span> carried by sample <span class="math">\(i\)</span>, which can be 0, 1, 2, or missing. For each variant <span class="math">\(j\)</span>, the sample alternate allele frequency <span class="math">\(p_j\)</span> is computed as half the mean of the non-missing entries of column <span class="math">\(j\)</span>. Entries of <span class="math">\(M\)</span> are then mean-centered and variance-normalized as</p>
<div class="math">
\[M_{ij} = \frac{C_{ij}-2p_j}{\sqrt{2p_j(1-p_j)m}},\]</div>
<p>with <span class="math">\(M_{ij} = 0\)</span> for <span class="math">\(C_{ij}\)</span> missing (i.e. mean genotype imputation). This scaling normalizes genotype variances to a common value <span class="math">\(1/m\)</span> for variants in Hardy-Weinberg equilibrium and is further motivated in the paper cited above. (The resulting amplification of signal from the low end of the allele frequency spectrum will also introduce noise for rare variants; common practice is to filter out variants with minor allele frequency below some cutoff.)  The factor <span class="math">\(1/m\)</span> gives each sample row approximately unit total variance (assuming linkage equilibrium) and yields the sample correlation or genetic relationship matrix (GRM) as simply <span class="math">\(MM^T\)</span>.</p>
<p>PCA then computes the SVD</p>
<div class="math">
\[M = USV^T\]</div>
<p>where columns of <span class="math">\(U\)</span> are left singular vectors (orthonormal in <span class="math">\(\mathbb{R}^n\)</span>), columns of <span class="math">\(V\)</span> are right singular vectors (orthonormal in <span class="math">\(\mathbb{R}^m\)</span>), and <span class="math">\(S=\mathrm{diag}(s_1, s_2, \ldots)\)</span> with ordered singular values <span class="math">\(s_1 \ge s_2 \ge \cdots \ge 0\)</span>. Typically one computes only the first <span class="math">\(k\)</span> singular vectors and values, yielding the best rank <span class="math">\(k\)</span> approximation <span class="math">\(U_k S_k V_k^T\)</span> of <span class="math">\(M\)</span>; the truncations <span class="math">\(U_k\)</span>, <span class="math">\(S_k\)</span> and <span class="math">\(V_k\)</span> are <span class="math">\(n \times k\)</span>, <span class="math">\(k \times k\)</span> and <span class="math">\(m \times k\)</span> respectively.</p>
<p>From the perspective of the samples or rows of <span class="math">\(M\)</span> as data, <span class="math">\(V_k\)</span> contains the variant loadings for the first <span class="math">\(k\)</span> PCs while <span class="math">\(MV_k = U_k S_k\)</span> contains the first <span class="math">\(k\)</span> PC scores of each sample. The loadings represent a new basis of features while the scores represent the projected data on those features. The eigenvalues of the GRM <span class="math">\(MM^T\)</span> are the squares of the singular values <span class="math">\(s_1^2, s_2^2, \ldots\)</span>, which represent the variances carried by the respective PCs. By default, Hail only computes the loadings if the <code class="docutils literal"><span class="pre">loadings</span></code> parameter is specified.</p>
<p><em>Note:</em> In PLINK/GCTA the GRM is taken as the starting point and it is computed slightly differently with regard to missing data. Here the <span class="math">\(ij\)</span> entry of <span class="math">\(MM^T\)</span> is simply the dot product of rows <span class="math">\(i\)</span> and <span class="math">\(j\)</span> of <span class="math">\(M\)</span>; in terms of <span class="math">\(C\)</span> it is</p>
<div class="math">
\[\frac{1}{m}\sum_{l\in\mathcal{C}_i\cap\mathcal{C}_j}\frac{(C_{il}-2p_l)(C_{jl} - 2p_l)}{2p_l(1-p_l)}\]</div>
<p>where <span class="math">\(\mathcal{C}_i = \{l \mid C_{il} \text{ is non-missing}\}\)</span>. In PLINK/GCTA the denominator <span class="math">\(m\)</span> is replaced with the number of terms in the sum <span class="math">\(\lvert\mathcal{C}_i\cap\mathcal{C}_j\rvert\)</span>, i.e. the number of variants where both samples have non-missing genotypes. While this is arguably a better estimator of the true GRM (trading shrinkage for noise), it has the drawback that one loses the clean interpretation of the loadings and scores as features and projections.</p>
<p>Separately, for the PCs PLINK/GCTA output the eigenvectors of the GRM; even ignoring the above discrepancy that means the left singular vectors <span class="math">\(U_k\)</span> instead of the component scores <span class="math">\(U_k S_k\)</span>. While this is just a matter of the scale on each PC, the scores have the advantage of representing true projections of the data onto features with the variance of a score reflecting the variance explained by the corresponding feature. (In PC bi-plots this amounts to a change in aspect ratio; for use of PCs as covariates in regression it is immaterial.)</p>
<p><strong>Annotations</strong></p>
<p>Given root <code class="docutils literal"><span class="pre">scores='sa.scores'</span></code> and <code class="docutils literal"><span class="pre">as_array=False</span></code>, <a class="reference internal" href="#hail.VariantDataset.pca" title="hail.VariantDataset.pca"><code class="xref py py-meth docutils literal"><span class="pre">pca()</span></code></a> adds a Struct to sample annotations:</p>
<blockquote>
<div><ul class="simple">
<li><strong>sa.scores</strong> (<em>Struct</em>) &#8211; Struct of sample scores</li>
</ul>
</div></blockquote>
<p>With <code class="docutils literal"><span class="pre">k=3</span></code>, the Struct has three field:</p>
<blockquote>
<div><ul class="simple">
<li><strong>sa.scores.PC1</strong> (<em>Double</em>) &#8211; Score from first PC</li>
<li><strong>sa.scores.PC2</strong> (<em>Double</em>) &#8211; Score from second PC</li>
<li><strong>sa.scores.PC3</strong> (<em>Double</em>) &#8211; Score from third PC</li>
</ul>
</div></blockquote>
<p>Analogous variant and global annotations of type Struct are added by specifying the <code class="docutils literal"><span class="pre">loadings</span></code> and <code class="docutils literal"><span class="pre">eigenvalues</span></code> arguments, respectively.</p>
<p>Given roots <code class="docutils literal"><span class="pre">scores='sa.scores'</span></code>, <code class="docutils literal"><span class="pre">loadings='va.loadings'</span></code>, and <code class="docutils literal"><span class="pre">eigenvalues='global.evals'</span></code>, and <code class="docutils literal"><span class="pre">as_array=True</span></code>, <a class="reference internal" href="#hail.VariantDataset.pca" title="hail.VariantDataset.pca"><code class="xref py py-meth docutils literal"><span class="pre">pca()</span></code></a> adds the following annotations:</p>
<blockquote>
<div><ul class="simple">
<li><strong>sa.scores</strong> (<em>Array[Double]</em>) &#8211; Array of sample scores from the top k PCs</li>
<li><strong>va.loadings</strong> (<em>Array[Double]</em>) &#8211; Array of variant loadings in the top k PCs</li>
<li><strong>global.evals</strong> (<em>Array[Double]</em>) &#8211; Array of the top k eigenvalues</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>scores</strong> (<em>str</em>) &#8211; Sample annotation path to store scores.</li>
<li><strong>loadings</strong> (<em>str</em><em> or </em><em>None</em>) &#8211; Variant annotation path to store site loadings.</li>
<li><strong>eigenvalues</strong> (<em>str</em><em> or </em><em>None</em>) &#8211; Global annotation path to store eigenvalues.</li>
<li><strong>k</strong> (<em>bool</em><em> or </em><em>None</em>) &#8211; Number of principal components.</li>
<li><strong>as_array</strong> (<em>bool</em>) &#8211; Store annotations as type Array rather than Struct</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Dataset with new PCA annotations.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.persist">
<code class="descname">persist</code><span class="sig-paren">(</span><em>storage_level='MEMORY_AND_DISK'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.persist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.persist" title="Permalink to this definition">¶</a></dt>
<dd><p>Persist this variant dataset to memory and/or disk.</p>
<p><strong>Examples</strong></p>
<p>Persist the variant dataset to both memory and disk:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">persist</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>The <a class="reference internal" href="#hail.VariantDataset.persist" title="hail.VariantDataset.persist"><code class="xref py py-meth docutils literal"><span class="pre">persist()</span></code></a> and <a class="reference internal" href="#hail.VariantDataset.cache" title="hail.VariantDataset.cache"><code class="xref py py-meth docutils literal"><span class="pre">cache()</span></code></a> commands 
allow you to store the current dataset on disk or in memory to avoid redundant computation and 
improve the performance of Hail pipelines.</p>
<p><a class="reference internal" href="#hail.VariantDataset.cache" title="hail.VariantDataset.cache"><code class="xref py py-meth docutils literal"><span class="pre">cache()</span></code></a> is an alias for 
<a class="reference internal" href="#hail.VariantDataset.persist" title="hail.VariantDataset.persist"><code class="xref py py-func docutils literal"><span class="pre">persist(&quot;MEMORY_ONLY&quot;)</span></code></a>.  Most users will want &#8220;MEMORY_AND_DISK&#8221;.
See the <a class="reference external" href="http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence">Spark documentation</a> 
for a more in-depth discussion of persisting data.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Persist, like all other <a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a> functions, is functional.
Its output must be captured. This is wrong:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">linreg</span><span class="p">(</span><span class="s1">&#39;sa.phenotype&#39;</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span><span class="o">.</span><span class="n">persist</span><span class="p">()</span> 
</pre></div>
</div>
<p>The above code does NOT persist <code class="docutils literal"><span class="pre">vds</span></code>. Instead, it copies <code class="docutils literal"><span class="pre">vds</span></code> and persists that result. 
The proper usage is this:</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">pca</span><span class="p">()</span><span class="o">.</span><span class="n">persist</span><span class="p">()</span> 
</pre></div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>storage_level</strong> &#8211; Storage level.  One of: NONE, DISK_ONLY,
DISK_ONLY_2, MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_ONLY_SER,
MEMORY_ONLY_SER_2, MEMORY_AND_DISK, MEMORY_AND_DISK_2,
MEMORY_AND_DISK_SER, MEMORY_AND_DISK_SER_2, OFF_HEAP</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.query_genotypes">
<code class="descname">query_genotypes</code><span class="sig-paren">(</span><em>exprs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.query_genotypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.query_genotypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs aggregation queries over genotypes, and returns Python object(s).</p>
<p><strong>Examples</strong></p>
<p>Compute global GQ histogram</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gq_hist</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_genotypes</span><span class="p">(</span><span class="s1">&#39;gs.map(g =&gt; g.gq).hist(0, 100, 100)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute call rate</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">call_rate</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_genotypes</span><span class="p">(</span><span class="s1">&#39;gs.fraction(g =&gt; g.isCalled)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute GQ and DP histograms</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">gq_hist</span><span class="p">,</span> <span class="n">dp_hist</span><span class="p">]</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_genotypes</span><span class="p">([</span><span class="s1">&#39;gs.map(g =&gt; g.gq).hist(0, 100, 100)&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                                    <span class="s1">&#39;gs.map(g =&gt; g.dp).hist(0, 60, 60)&#39;</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>exprs</strong> (<em>str</em><em> or </em><em>list of str</em>) &#8211; query expressions</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">annotation or list of annotation</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.query_genotypes_typed">
<code class="descname">query_genotypes_typed</code><span class="sig-paren">(</span><em>exprs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.query_genotypes_typed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.query_genotypes_typed" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs aggregation queries over genotypes, and returns Python object(s) and type(s).</p>
<p><strong>Examples</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gq_hist</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_genotypes_typed</span><span class="p">(</span><span class="s1">&#39;gs.map(g =&gt; g.gq).hist(0, 100, 100)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">gq_hist</span><span class="p">,</span> <span class="n">dp_hist</span><span class="p">],</span> <span class="p">[</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_genotypes_typed</span><span class="p">([</span><span class="s1">&#39;gs.map(g =&gt; g.gq).hist(0, 100, 100)&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                                          <span class="s1">&#39;gs.map(g =&gt; g.dp).hist(0, 60, 60)&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#hail.VariantDataset.query_genotypes" title="hail.VariantDataset.query_genotypes"><code class="xref py py-meth docutils literal"><span class="pre">query_genotypes()</span></code></a> for more information.</p>
<p>This method evaluates Hail expressions over genotypes, along with
all variant and sample metadata for that genotype. The <code class="docutils literal"><span class="pre">exprs</span></code>
argument requires either a list of strings or a single string
The method returns a list of results and a list of types (which
each contain one element if the input parameter was a single str).</p>
<p>The namespace of the expressions includes:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">global</span></code>: global annotations</li>
<li><code class="docutils literal"><span class="pre">gs</span></code> (<em>Aggregable[Genotype]</em>): aggregable of <a class="reference internal" href="types.html#genotype"><span class="std std-ref">Genotype</span></a></li>
</ul>
<p>Map and filter expressions on this aggregable have the following
namespace:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">global</span></code>: global annotations</li>
<li><code class="docutils literal"><span class="pre">g</span></code>: <a class="reference internal" href="types.html#genotype"><span class="std std-ref">Genotype</span></a></li>
<li><code class="docutils literal"><span class="pre">v</span></code>: <a class="reference internal" href="types.html#variant"><span class="std std-ref">Variant</span></a></li>
<li><code class="docutils literal"><span class="pre">va</span></code>: variant annotations</li>
<li><code class="docutils literal"><span class="pre">s</span></code>: sample</li>
<li><code class="docutils literal"><span class="pre">sa</span></code>: sample annotations</li>
</ul>
<p><strong>Performance Note</strong>
It is far faster to execute multiple queries in one method than
to execute multiple query methods.  This:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result1</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_genotypes</span><span class="p">(</span><span class="s1">&#39;gs.count()&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result2</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_genotypes</span><span class="p">(</span><span class="s1">&#39;gs.filter(g =&gt; v.altAllele.isSNP() &amp;&amp; g.isHet).count()&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>will be nearly twice as slow as this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;gs.count()&#39;</span><span class="p">,</span> <span class="s1">&#39;gs.filter(g =&gt; v.altAllele.isSNP() &amp;&amp; g.isHet).count()&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">geno_count</span><span class="p">,</span> <span class="n">snp_hets</span><span class="p">]</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_genotypes</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>exprs</strong> (<em>str</em><em> or </em><em>list of str</em>) &#8211; query expressions</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">(annotation or list of annotation, <a class="reference internal" href="expr/hail.expr.Type.html#hail.expr.Type" title="hail.expr.Type"><code class="xref py py-class docutils literal"><span class="pre">Type</span></code></a> or list of <a class="reference internal" href="expr/hail.expr.Type.html#hail.expr.Type" title="hail.expr.Type"><code class="xref py py-class docutils literal"><span class="pre">Type</span></code></a>)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.query_samples">
<code class="descname">query_samples</code><span class="sig-paren">(</span><em>exprs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.query_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.query_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs aggregation queries over samples and sample annotations, and returns Python object(s).</p>
<p><strong>Examples</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">low_callrate_samples</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_samples</span><span class="p">(</span><span class="s1">&#39;samples.filter(s =&gt; sa.qc.callRate &lt; 0.95).collect()&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>This method evaluates Hail expressions over samples and sample
annotations.  The <code class="docutils literal"><span class="pre">exprs</span></code> argument requires either a single string
or a list of strings. If a single string was passed, then a single
result is returned. If a list is passed, a list is returned.</p>
<p>The namespace of the expressions includes:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">global</span></code>: global annotations</li>
<li><code class="docutils literal"><span class="pre">samples</span></code> (<em>Aggregable[Sample]</em>): aggregable of <span class="xref std std-ref">sample</span></li>
</ul>
<p>Map and filter expressions on this aggregable have the additional
namespace:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">global</span></code>: global annotations</li>
<li><code class="docutils literal"><span class="pre">s</span></code>: sample</li>
<li><code class="docutils literal"><span class="pre">sa</span></code>: sample annotations</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>exprs</strong> (<em>str</em><em> or </em><em>list of str</em>) &#8211; query expressions</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">annotation or list of annotation</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.query_samples_typed">
<code class="descname">query_samples_typed</code><span class="sig-paren">(</span><em>exprs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.query_samples_typed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.query_samples_typed" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs aggregation queries over samples and sample annotations, and returns Python object(s) and type(s).</p>
<p><strong>Examples</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">low_callrate_samples</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_samples_typed</span><span class="p">(</span>
<span class="gp">... </span>   <span class="s1">&#39;samples.filter(s =&gt; sa.qc.callRate &lt; 0.95).collect()&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#hail.VariantDataset.query_samples" title="hail.VariantDataset.query_samples"><code class="xref py py-meth docutils literal"><span class="pre">query_samples()</span></code></a> for more information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>exprs</strong> (<em>str</em><em> or </em><em>list of str</em>) &#8211; query expressions</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">(annotation or list of annotation,  <a class="reference internal" href="expr/hail.expr.Type.html#hail.expr.Type" title="hail.expr.Type"><code class="xref py py-class docutils literal"><span class="pre">Type</span></code></a> or list of <a class="reference internal" href="expr/hail.expr.Type.html#hail.expr.Type" title="hail.expr.Type"><code class="xref py py-class docutils literal"><span class="pre">Type</span></code></a>)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.query_variants">
<code class="descname">query_variants</code><span class="sig-paren">(</span><em>exprs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.query_variants"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.query_variants" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs aggregation queries over variants and variant annotations, and returns Python object(s).</p>
<p><strong>Examples</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lof_variant_count</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_variants</span><span class="p">(</span><span class="s1">&#39;variants.filter(v =&gt; va.consequence == &quot;LOF&quot;).count()&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">lof_variant_count</span><span class="p">,</span> <span class="n">missense_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_variants</span><span class="p">([</span>
<span class="gp">... </span>    <span class="s1">&#39;variants.filter(v =&gt; va.consequence == &quot;LOF&quot;).count()&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s1">&#39;variants.filter(v =&gt; va.consequence == &quot;Missense&quot;).count()&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>This method evaluates Hail expressions over variants and variant
annotations.  The <code class="docutils literal"><span class="pre">exprs</span></code> argument requires either a single string
or a list of strings. If a single string was passed, then a single
result is returned. If a list is passed, a list is returned.</p>
<p>The namespace of the expressions includes:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">global</span></code>: global annotations</li>
<li><code class="docutils literal"><span class="pre">variants</span></code> (<em>Aggregable[Variant]</em>): aggregable of <a class="reference internal" href="types.html#variant"><span class="std std-ref">Variant</span></a></li>
</ul>
<p>Map and filter expressions on this aggregable have the additional
namespace:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">global</span></code>: global annotations</li>
<li><code class="docutils literal"><span class="pre">v</span></code>: <a class="reference internal" href="types.html#variant"><span class="std std-ref">Variant</span></a></li>
<li><code class="docutils literal"><span class="pre">va</span></code>: variant annotations</li>
</ul>
<p><strong>Performance Note</strong>
It is far faster to execute multiple queries in one method than
to execute multiple query methods.  The combined query:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;variants.count()&#39;</span><span class="p">,</span> <span class="s1">&#39;variants.filter(v =&gt; v.altAllele.isSNP()).count()&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">num_variants</span><span class="p">,</span> <span class="n">num_snps</span><span class="p">]</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_variants</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span>
</pre></div>
</div>
<p>will be nearly twice as fast as the split query:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result1</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_variants</span><span class="p">(</span><span class="s1">&#39;variants.count()&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result2</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_variants</span><span class="p">(</span><span class="s1">&#39;variants.filter(v =&gt; v.altAllele.isSNP()).count()&#39;</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>exprs</strong> (<em>str</em><em> or </em><em>list of str</em>) &#8211; query expressions</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">annotation or list of annotation</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.query_variants_typed">
<code class="descname">query_variants_typed</code><span class="sig-paren">(</span><em>exprs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.query_variants_typed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.query_variants_typed" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs aggregation queries over variants and variant annotations, and returns Python object(s) and type(s).</p>
<p><strong>Examples</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lof_variant_count</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_variants_typed</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;variants.filter(v =&gt; va.consequence == &quot;LOF&quot;).count()&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">lof_variant_count</span><span class="p">,</span> <span class="n">missense_count</span><span class="p">],</span> <span class="p">[</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">query_variants_typed</span><span class="p">([</span>
<span class="gp">... </span>    <span class="s1">&#39;variants.filter(v =&gt; va.consequence == &quot;LOF&quot;).count()&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s1">&#39;variants.filter(v =&gt; va.consequence == &quot;Missense&quot;).count()&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#hail.VariantDataset.query_variants" title="hail.VariantDataset.query_variants"><code class="xref py py-meth docutils literal"><span class="pre">query_variants()</span></code></a> for more information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>exprs</strong> (<em>str</em><em> or </em><em>list of str</em>) &#8211; query expressions</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">(annotation or list of annotation, <a class="reference internal" href="expr/hail.expr.Type.html#hail.expr.Type" title="hail.expr.Type"><code class="xref py py-class docutils literal"><span class="pre">Type</span></code></a> or list of <a class="reference internal" href="expr/hail.expr.Type.html#hail.expr.Type" title="hail.expr.Type"><code class="xref py py-class docutils literal"><span class="pre">Type</span></code></a>)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.rename_samples">
<code class="descname">rename_samples</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.rename_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.rename_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename samples.</p>
<p><strong>Examples</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">rename_samples</span><span class="p">({</span><span class="s1">&#39;ID1&#39;</span><span class="p">:</span> <span class="s1">&#39;id1&#39;</span><span class="p">,</span> <span class="s1">&#39;ID2&#39;</span><span class="p">:</span> <span class="s1">&#39;id2&#39;</span><span class="p">})</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mapping</strong> (<em>dict</em>) &#8211; Mapping from old to new sample IDs.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Dataset with remapped sample IDs.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.repartition">
<code class="descname">repartition</code><span class="sig-paren">(</span><em>num_partitions</em>, <em>shuffle=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.repartition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.repartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Increase or decrease the number of variant dataset partitions.</p>
<p><strong>Examples</strong></p>
<p>Repartition the variant dataset to have 500 partitions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>Check the current number of partitions with <a class="reference internal" href="#hail.VariantDataset.num_partitions" title="hail.VariantDataset.num_partitions"><code class="xref py py-meth docutils literal"><span class="pre">num_partitions()</span></code></a>.</p>
<p>The data in a variant dataset is divided into chunks called partitions, which may be stored together or across a network, so that each partition may be read and processed in parallel by available cores. When a variant dataset with <span class="math">\(M\)</span> variants is first imported, each of the <span class="math">\(k\)</span> partition will contain about <span class="math">\(M/k\)</span> of the variants. Since each partition has some computational overhead, decreasing the number of partitions can improve performance after significant filtering. Since it&#8217;s recommended to have at least 2 - 4 partitions per core, increasing the number of partitions can allow one to take advantage of more cores.</p>
<p>Partitions are a core concept of distributed computation in Spark, see <a class="reference external" href="http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds">here</a> for details. With <code class="docutils literal"><span class="pre">shuffle=True</span></code>, Hail does a full shuffle of the data and creates equal sized partitions. With <code class="docutils literal"><span class="pre">shuffle=False</span></code>, Hail combines existing partitions to avoid a full shuffle. These algorithms correspond to the <code class="docutils literal"><span class="pre">repartition</span></code> and <code class="docutils literal"><span class="pre">coalesce</span></code> commands in Spark, respectively. In particular, when <code class="docutils literal"><span class="pre">shuffle=False</span></code>, <code class="docutils literal"><span class="pre">num_partitions</span></code> cannot exceed current number of partitions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>num_partitions</strong> (<em>int</em>) &#8211; Desired number of partitions, must be less than the current number if <code class="docutils literal"><span class="pre">shuffle=False</span></code></li>
<li><strong>shuffle</strong> (<em>bool</em>) &#8211; If True, use full shuffle to repartition.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Variant dataset with the number of partitions equal to at most <code class="docutils literal"><span class="pre">num_partitions</span></code></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.rrm">
<code class="descname">rrm</code><span class="sig-paren">(</span><em>force_block=False</em>, <em>force_gramian=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.rrm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.rrm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Realized Relationship Matrix (RRM).</p>
<p><strong>Examples</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kinship_matrix</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">rrm</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>The Realized Relationship Matrix is defined as follows. Consider the <span class="math">\(n \times m\)</span> matrix <span class="math">\(C\)</span> of raw genotypes, with rows indexed by <span class="math">\(n\)</span> samples and
columns indexed by the <span class="math">\(m\)</span> bialellic autosomal variants; <span class="math">\(C_{ij}\)</span> is the number of alternate alleles of variant <span class="math">\(j\)</span> carried by sample <span class="math">\(i\)</span>, which
can be 0, 1, 2, or missing. For each variant <span class="math">\(j\)</span>, the sample alternate allele frequency <span class="math">\(p_j\)</span> is computed as half the mean of the non-missing entries of column
<span class="math">\(j\)</span>. Entries of <span class="math">\(M\)</span> are then mean-centered and variance-normalized as</p>
<div class="math">
\[M_{ij} = \frac{C_{ij}-2p_j}{\sqrt{\frac{m}{n} \sum_{k=1}^n (C_{ij}-2p_j)^2}},\]</div>
<p>with <span class="math">\(M_{ij} = 0\)</span> for <span class="math">\(C_{ij}\)</span> missing (i.e. mean genotype imputation). This scaling normalizes each variant column to have empirical variance <span class="math">\(1/m\)</span>, which gives each sample row approximately unit total variance (assuming linkage equilibrium) and yields the <span class="math">\(n \times n\)</span> sample correlation or realized relationship matrix (RRM) <span class="math">\(K\)</span> as simply</p>
<div class="math">
\[K = MM^T\]</div>
<p>Note that the only difference between the Realized Relationship Matrix and the Genetic Relationship Matrix (GRM) used in <a class="reference internal" href="#hail.VariantDataset.grm" title="hail.VariantDataset.grm"><code class="xref py py-meth docutils literal"><span class="pre">grm()</span></code></a> is the variant (column) normalization: where RRM uses empirical variance, GRM uses expected variance under Hardy-Weinberg Equilibrium.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>force_block</strong> (<em>bool</em>) &#8211; Force using Spark&#8217;s BlockMatrix to compute kinship (advanced).</li>
<li><strong>force_gramian</strong> (<em>bool</em>) &#8211; Force using Spark&#8217;s RowMatrix.computeGramian to compute kinship (advanced).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Realized Relationship Matrix for all samples.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="hail.KinshipMatrix.html#hail.KinshipMatrix" title="hail.KinshipMatrix"><code class="xref py py-class docutils literal"><span class="pre">KinshipMatrix</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.same">
<code class="descname">same</code><span class="sig-paren">(</span><em>other</em>, <em>tolerance=1e-06</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.same"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.same" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the two variant datasets have the same variants, samples, genotypes, and annotation schemata and values.</p>
<p><strong>Examples</strong></p>
<p>This will return True:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span><span class="o">.</span><span class="n">same</span><span class="p">(</span><span class="n">vds</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>The <code class="docutils literal"><span class="pre">tolerance</span></code> parameter sets the tolerance for equality when comparing floating-point fields. More precisely, <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are equal if</p>
<div class="math">
\[bs{x - y} \leq tolerance * \max{bs{x}, bs{y}}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>other</strong> (<a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a>) &#8211; variant dataset to compare against</li>
<li><strong>tolerance</strong> (<em>float</em>) &#8211; floating-point tolerance for equality</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="hail.VariantDataset.sample_annotations">
<code class="descname">sample_annotations</code><a class="headerlink" href="#hail.VariantDataset.sample_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dict of sample annotations.</p>
<p>The keys of this dictionary are the sample IDs (strings).
The values are sample annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="hail.VariantDataset.sample_ids">
<code class="descname">sample_ids</code><a class="headerlink" href="#hail.VariantDataset.sample_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return sampleIDs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">List of sample IDs.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.sample_qc">
<code class="descname">sample_qc</code><span class="sig-paren">(</span><em>root='sa.qc'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.sample_qc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.sample_qc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute per-sample QC metrics.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Annotations</strong></p>
<p><a class="reference internal" href="#hail.VariantDataset.sample_qc" title="hail.VariantDataset.sample_qc"><code class="xref py py-meth docutils literal"><span class="pre">sample_qc()</span></code></a> computes 20 sample statistics from the 
genotype data and stores the results as sample annotations that can be accessed with</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">sa.qc.&lt;identifier&gt;</span></code> (or <code class="docutils literal"><span class="pre">&lt;root&gt;.&lt;identifier&gt;</span></code> if a non-default root was passed):</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="9%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">callRate</span></code></td>
<td>Double</td>
<td>Fraction of genotypes called</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">nHomRef</span></code></td>
<td>Int</td>
<td>Number of homozygous reference genotypes</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">nHet</span></code></td>
<td>Int</td>
<td>Number of heterozygous genotypes</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">nHomVar</span></code></td>
<td>Int</td>
<td>Number of homozygous alternate genotypes</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">nCalled</span></code></td>
<td>Int</td>
<td>Sum of <code class="docutils literal"><span class="pre">nHomRef</span></code> + <code class="docutils literal"><span class="pre">nHet</span></code> + <code class="docutils literal"><span class="pre">nHomVar</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">nNotCalled</span></code></td>
<td>Int</td>
<td>Number of uncalled genotypes</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">nSNP</span></code></td>
<td>Int</td>
<td>Number of SNP alternate alleles</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">nInsertion</span></code></td>
<td>Int</td>
<td>Number of insertion alternate alleles</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">nDeletion</span></code></td>
<td>Int</td>
<td>Number of deletion alternate alleles</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">nSingleton</span></code></td>
<td>Int</td>
<td>Number of private alleles</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">nTransition</span></code></td>
<td>Int</td>
<td>Number of transition (A-G, C-T) alternate alleles</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">nTransversion</span></code></td>
<td>Int</td>
<td>Number of transversion alternate alleles</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">nNonRef</span></code></td>
<td>Int</td>
<td>Sum of <code class="docutils literal"><span class="pre">nHet</span></code> and <code class="docutils literal"><span class="pre">nHomVar</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">rTiTv</span></code></td>
<td>Double</td>
<td>Transition/Transversion ratio</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">rHetHomVar</span></code></td>
<td>Double</td>
<td>Het/HomVar genotype ratio</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">rInsertionDeletion</span></code></td>
<td>Double</td>
<td>Insertion/Deletion ratio</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">dpMean</span></code></td>
<td>Double</td>
<td>Depth mean across all genotypes</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">dpStDev</span></code></td>
<td>Double</td>
<td>Depth standard deviation across all genotypes</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">gqMean</span></code></td>
<td>Double</td>
<td>The average genotype quality across all genotypes</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">gqStDev</span></code></td>
<td>Double</td>
<td>Genotype quality standard deviation across all genotypes</td>
</tr>
</tbody>
</table>
<p>Missing values <code class="docutils literal"><span class="pre">NA</span></code> may result (for example, due to division by zero) and are handled properly in filtering and written as &#8220;NA&#8221; in export modules. The empirical standard deviation is computed with zero degrees of freedom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>root</strong> (<em>str</em>) &#8211; Sample annotation root for the computed struct.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Annotated variant dataset with new sample qc annotations.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="hail.VariantDataset.sample_schema">
<code class="descname">sample_schema</code><a class="headerlink" href="#hail.VariantDataset.sample_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the signature of the sample annotations contained in this VDS.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">sample_schema</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="expr/hail.expr.Type.html#hail.expr.Type" title="hail.expr.Type"><code class="xref py py-class docutils literal"><span class="pre">Type</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.sample_variants">
<code class="descname">sample_variants</code><span class="sig-paren">(</span><em>fraction</em>, <em>seed=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.sample_variants"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.sample_variants" title="Permalink to this definition">¶</a></dt>
<dd><p>Downsample variants to a given fraction of the dataset.</p>
<p><strong>Examples</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">small_vds</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">sample_variants</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>This method may not sample exactly <code class="docutils literal"><span class="pre">(fraction</span> <span class="pre">*</span> <span class="pre">n_variants)</span></code>
variants from the dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fraction</strong> (<em>float</em>) &#8211; (Expected) fraction of variants to keep.</li>
<li><strong>seed</strong> (<em>int</em>) &#8211; Random seed.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Downsampled variant dataset.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.samples_keytable">
<code class="descname">samples_keytable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.samples_keytable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.samples_keytable" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert samples and sample annotations to KeyTable.</p>
<p>The resulting KeyTable has schema:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Struct {
  s: Sample
  sa: sample annotations
}
</pre></div>
</div>
<p>with a single key <code class="docutils literal"><span class="pre">s</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Key table with samples and sample annotations.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.set_va_attributes">
<code class="descname">set_va_attributes</code><span class="sig-paren">(</span><em>ann_path</em>, <em>attributes</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.set_va_attributes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.set_va_attributes" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets attributes for a variant annotation.
Attributes are key/value pairs that can be attached to a variant annotation field.</p>
<p>The following attributes are read from the VCF header when importing a VCF and written
to the VCF header when exporting a VCF:
- INFO fields attributes (attached to (<cite>va.info.*</cite>)):</p>
<blockquote>
<div><ul class="simple">
<li>&#8216;Number&#8217;: The arity of the field. Can take values</li>
</ul>
<p><cite>0</cite> (Boolean flag),
<cite>1</cite> (single value),
<cite>R</cite> (one value per allele, including the reference),
<cite>A</cite> (one value per non-reference allele),
<cite>G</cite> (one value per genotype), and
<cite>.</cite> (any number of values)</p>
<blockquote>
<div><ul class="simple">
<li>When importing: The value in read from the VCF INFO field definition</li>
<li>When exporting: The default value is <cite>0</cite> for <strong>Boolean</strong>, <cite>.</cite> for <strong>Arrays</strong> and 1 for all other types</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>&#8216;Description&#8217; (default is &#8216;&#8217;)</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>FILTER entries in the VCF header are generated based on the attributes of <cite>va.filters</cite>.</li>
</ul>
<p>Each key/value pair in the attributes will generate a FILTER entry in the VCF with ID = key and Description = value.</p>
<p><strong>Examples</strong></p>
<p>Consider the following command which adds a filter and an annotation to the VDS (we&#8217;re assuming a split VDS for simplicity):
1) an INFO field <cite>AC_HC</cite>, which stores the allele count of high confidence genotypes (DP &gt;= 10, GQ &gt;= 20) for each non-reference allele,
2) a filter <cite>HardFilter</cite> that filters all sites with the [GATK suggested hard filters]
(<a class="reference external" href="http://gatkforums.broadinstitute.org/gatk/discussion/2806/howto-apply-hard-filters-to-a-call-set">http://gatkforums.broadinstitute.org/gatk/discussion/2806/howto-apply-hard-filters-to-a-call-set</a>):</p>
<blockquote>
<div><ul class="simple">
<li>For SNVs: QD &lt; 2.0 || FS &lt; 60 || MQ &lt; 40 || MQRankSum &lt; -12.5 || ReadPosRankSum &lt; -8.0</li>
<li>For Indels (and other complex): QD &lt; 2.0 || FS &lt; 200.0 || ReadPosRankSum &lt; 20.0</li>
</ul>
</div></blockquote>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">annotated_vds</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">([</span>
<span class="gp">... </span><span class="s1">&#39;va.info.AC_HC = gs.filter(g =&gt; g.dp &gt;= 10 &amp;&amp; g.gq &gt;= 20).callStats(g =&gt; v).AC[1:]&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;va.filters = if((v.altAllele.isSNP &amp;&amp; (va.info.QD &lt; 2.0 || va.info.FS &lt; 60 || va.info.MQ &lt; 40 || &#39;</span> <span class="o">+</span>
<span class="gp">... </span><span class="s1">&#39;va.info.MQRankSum &lt; -12.5 || va.info.ReadPosRankSum &lt; -8.0)) || &#39;</span> <span class="o">+</span>
<span class="gp">... </span><span class="s1">&#39;(va.info.QD &lt; 2.0 || va.info.FS &lt; 200.0 || va.info.ReadPosRankSum &lt; 20.0)) va.filters.add(&quot;HardFilter&quot;) else va.filters&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>If we now export this VDS as VCF, it would produce the following header (for these new fields):
<code class="docutils literal"><span class="pre">`</span>
<span class="pre">##INFO=&lt;ID=AC_HC,Number=.,Type=String,Description=&quot;&quot;</span>
<span class="pre">`</span></code></p>
<p>This header doesn&#8217;t contain all information that should be present in an optimal VCF header:
1) There is no FILTER entry for <cite>HardFilter</cite>
2) Since <cite>AC_HC</cite> has one entry per non-reference allele, its <cite>Number</cite> should be <cite>A</cite>
3) <cite>AC_HC</cite> should have a Description</p>
<p>We can fix this by setting the attributes of these fields:
&gt;&gt;&gt; annotated_vds = vds.set_va_attributes(&#8216;va.info.AC_HC&#8217;, {&#8216;Description&#8217;:&#8217;Allele count for high quality genotypes (DP &gt;= 10, GQ &gt;= 20)&#8217;,
... &#8216;Number&#8217;: &#8216;A&#8217;})
&gt;&gt;&gt; annotated_vds = vds.set_va_attributes(&#8216;va.filters&#8217;, {&#8216;HardFilter&#8217;: &#8216;This site fails GATK suggested hard filters.&#8217;})</p>
<p>Exporting the VDS with the attributes now prints the following header lines:
<code class="docutils literal"><span class="pre">`</span>
<span class="pre">##INFO=&lt;ID=test,Number=A,Type=String,Description=&quot;Allele</span> <span class="pre">count</span> <span class="pre">for</span> <span class="pre">high</span> <span class="pre">quality</span> <span class="pre">genotypes</span> <span class="pre">(DP</span> <span class="pre">&gt;=</span> <span class="pre">10,</span> <span class="pre">GQ</span> <span class="pre">&gt;=</span> <span class="pre">20)&quot;</span>
<span class="pre">##FILTER=&lt;ID=HardFilter,Description=&quot;This</span> <span class="pre">site</span> <span class="pre">fails</span> <span class="pre">GATK</span> <span class="pre">suggested</span> <span class="pre">hard</span> <span class="pre">filters.&quot;&gt;</span>
<span class="pre">`</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ann_path</strong> (<em>str</em>) &#8211; Path to variant annotation beginning with <cite>va</cite>.</li>
<li><strong>attributes</strong> (<em>dict</em>) &#8211; A str-str dict containing the attributes to set</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Annotated dataset with the attribute added to the variant annotation.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.split_multi">
<code class="descname">split_multi</code><span class="sig-paren">(</span><em>propagate_gq=False</em>, <em>keep_star_alleles=False</em>, <em>max_shift=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.split_multi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.split_multi" title="Permalink to this definition">¶</a></dt>
<dd><p>Split multiallelic variants.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Examples</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span><span class="o">.</span><span class="n">split_multi</span><span class="p">()</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;output/split.vds&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>We will explain by example. Consider a hypothetical 3-allelic
variant:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>A   C,T 0/2:7,2,6:15:45:99,50,99,0,45,99
</pre></div>
</div>
<p>split_multi will create two biallelic variants (one for each
alternate allele) at the same position</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>A   C   0/0:13,2:15:45:0,45,99
A   T   0/1:9,6:15:50:50,0,99
</pre></div>
</div>
<p>Each multiallelic GT field is downcoded once for each
alternate allele. A call for an alternate allele maps to 1 in
the biallelic variant corresponding to itself and 0
otherwise. For example, in the example above, 0/2 maps to 0/0
and 0/1. The genotype 1/2 maps to 0/1 and 0/1.</p>
<p>The biallelic alt AD entry is just the multiallelic AD entry
corresponding to the alternate allele. The ref AD entry is the
sum of the other multiallelic entries.</p>
<p>The biallelic DP is the same as the multiallelic DP.</p>
<p>The biallelic PL entry for for a genotype g is the minimum
over PL entries for multiallelic genotypes that downcode to
g. For example, the PL for (A, T) at 0/1 is the minimum of the
PLs for 0/1 (50) and 1/2 (45), and thus 45.</p>
<p>Fixing an alternate allele and biallelic variant, downcoding
gives a map from multiallelic to biallelic alleles and
genotypes. The biallelic AD entry for an allele is just the
sum of the multiallelic AD entries for alleles that map to
that allele. Similarly, the biallelic PL entry for a genotype
is the minimum over multiallelic PL entries for genotypes that
map to that genotype.</p>
<p>By default, GQ is recomputed from PL. If <code class="docutils literal"><span class="pre">propagate_gq=True</span></code>
is passed, the biallelic GQ field is simply the multiallelic
GQ field, that is, genotype qualities are unchanged.</p>
<p>Here is a second example for a het non-ref</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>A   C,T 1/2:2,8,6:16:45:99,50,99,45,0,99
</pre></div>
</div>
<p>splits as</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>A   C   0/1:8,8:16:45:45,0,99
A   T   0/1:10,6:16:50:50,0,99
</pre></div>
</div>
<p><strong>VCF Info Fields</strong></p>
<p>Hail does not split annotations in the info field. This means
that if a multiallelic site with <code class="docutils literal"><span class="pre">info.AC</span></code> value <code class="docutils literal"><span class="pre">[10,</span> <span class="pre">2]</span></code> is
split, each split site will contain the same array <code class="docutils literal"><span class="pre">[10,</span>
<span class="pre">2]</span></code>. The provided allele index annotation <code class="docutils literal"><span class="pre">va.aIndex</span></code> can be used
to select the value corresponding to the split allele&#8217;s
position:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">split_multi</span><span class="p">()</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">filter_variants_expr</span><span class="p">(</span><span class="s1">&#39;va.info.AC[va.aIndex - 1] &lt; 10&#39;</span><span class="p">,</span> <span class="n">keep</span> <span class="o">=</span> <span class="kc">False</span><span class="p">))</span>
</pre></div>
</div>
<p>VCFs split by Hail and exported to new VCFs may be
incompatible with other tools, if action is not taken
first. Since the &#8220;Number&#8221; of the arrays in split multiallelic
sites no longer matches the structure on import (&#8220;A&#8221; for 1 per
allele, for example), Hail will export these fields with
number &#8221;.&#8221;.</p>
<p>If the desired output is one value per site, then it is
possible to use annotate_variants_expr to remap these
values. Here is an example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">split_multi</span><span class="p">()</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">annotate_variants_expr</span><span class="p">(</span><span class="s1">&#39;va.info.AC = va.info.AC[va.aIndex - 1]&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">export_vcf</span><span class="p">(</span><span class="s1">&#39;output/export.vcf&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>The info field AC in <em>data/export.vcf</em> will have <code class="docutils literal"><span class="pre">Number=1</span></code>.</p>
<p><strong>Annotations</strong></p>
<p><a class="reference internal" href="#hail.VariantDataset.split_multi" title="hail.VariantDataset.split_multi"><code class="xref py py-meth docutils literal"><span class="pre">split_multi()</span></code></a> adds the
following annotations:</p>
<blockquote>
<div><ul class="simple">
<li><strong>va.wasSplit</strong> (<em>Boolean</em>) &#8211; true if this variant was
originally multiallelic, otherwise false.</li>
<li><strong>va.aIndex</strong> (<em>Int</em>) &#8211; The original index of this
alternate allele in the multiallelic representation (NB: 1
is the first alternate allele or the only alternate allele
in a biallelic variant). For example, 1:100:A:T,C splits
into two variants: 1:100:A:T with <code class="docutils literal"><span class="pre">aIndex</span> <span class="pre">=</span> <span class="pre">1</span></code> and
1:100:A:C with <code class="docutils literal"><span class="pre">aIndex</span> <span class="pre">=</span> <span class="pre">2</span></code>.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>propagate_gq</strong> (<em>bool</em>) &#8211; Set the GQ of output (split)
genotypes to be the GQ of the input (multi-allelic) variants
instead of recompute GQ as the difference between the two
smallest PL values.  Intended to be used in conjunction with
<code class="docutils literal"><span class="pre">import_vcf(store_gq=True)</span></code>.  This option will be obviated
in the future by generic genotype schemas.  Experimental.</li>
<li><strong>keep_star_alleles</strong> (<em>bool</em>) &#8211; Do not filter out * alleles.</li>
<li><strong>max_shift</strong> (<em>int</em>) &#8211; maximum number of base pairs by which
a split variant can move.  Affects memory usage, and will
cause Hail to throw an error if a variant that moves further
is encountered.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A biallelic variant dataset.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.storage_level">
<code class="descname">storage_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.storage_level"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.storage_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the storage (persistence) level of the variant dataset.</p>
<p><strong>Notes</strong></p>
<p>See the <a class="reference external" href="http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence">Spark documentation</a> for details on persistence levels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.summarize">
<code class="descname">summarize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.summarize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.summarize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a summary of useful information about the dataset.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Examples</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">summarize</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">contigs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;call rate is </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">s</span><span class="o">.</span><span class="n">call_rate</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">report</span><span class="p">()</span>
</pre></div>
</div>
<p>The following information is contained in the summary:</p>
<blockquote>
<div><ul class="simple">
<li><strong>samples</strong> (<em>int</em>) - Number of samples.</li>
<li><strong>variants</strong> (<em>int</em>) - Number of variants.</li>
<li><strong>call_rate</strong> (<em>float</em>) - Fraction of all genotypes called.</li>
<li><strong>contigs</strong> (<em>list of str</em>) - List of all unique contigs found in the dataset.</li>
<li><strong>multiallelics</strong> (<em>int</em>) - Number of multiallelic variants.</li>
<li><strong>snps</strong> (<em>int</em>) - Number of SNP alternate alleles.</li>
<li><strong>mnps</strong> (<em>int</em>) - Number of MNP alternate alleles.</li>
<li><strong>insertions</strong> (<em>int</em>) - Number of insertion alternate alleles.</li>
<li><strong>deletions</strong> (<em>int</em>) - Number of deletions alternate alleles.</li>
<li><strong>complex</strong> (<em>int</em>) - Number of complex alternate alleles.</li>
<li><strong>star</strong> (<em>int</em>) - Number of star (upstream deletion) alternate alleles.</li>
<li><strong>max_alleles</strong> (<em>int</em>) - The highest number of alleles at any variant.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Object containing summary information.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="utils/index.html#hail.utils.Summary" title="hail.utils.Summary"><code class="xref py py-class docutils literal"><span class="pre">Summary</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.tdt">
<code class="descname">tdt</code><span class="sig-paren">(</span><em>fam</em>, <em>root='va.tdt'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.tdt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.tdt" title="Permalink to this definition">¶</a></dt>
<dd><p>Find transmitted and untransmitted variants; count per variant and
nuclear family.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Examples</strong></p>
<p>Compute TDT association results:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">tdt</span><span class="p">(</span><span class="s2">&quot;data/trios.fam&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">export_variants</span><span class="p">(</span><span class="s2">&quot;output/tdt_results.tsv&quot;</span><span class="p">,</span> <span class="s2">&quot;Variant = v, va.tdt.*&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<p>The transmission disequilibrium test tracks the number of times the alternate allele is transmitted (t) or not transmitted (u) from a heterozgyous parent to an affected child under the null that the rate of such transmissions is 0.5.  For variants where transmission is guaranteed (i.e., the Y chromosome, mitochondria, and paternal chromosome X variants outside of the PAR), the test cannot be used.</p>
<p>The TDT statistic is given by</p>
<div class="math">
\[(t-u)^2 \over (t+u)\]</div>
<p>and follows a 1 degree of freedom chi-squared distribution under the null hypothesis.</p>
<p>The number of transmissions and untransmissions for each possible set of genotypes is determined from the table below.  The copy state of a locus with respect to a trio is defined as follows, where PAR is the pseudoautosomal region (PAR).</p>
<ul class="simple">
<li>HemiX &#8211; in non-PAR of X and child is male</li>
<li>Auto &#8211; otherwise (in autosome or PAR, or child is female)</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="19%" />
<col width="19%" />
<col width="29%" />
<col width="7%" />
<col width="7%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Kid</th>
<th class="head">Dad</th>
<th class="head">Mom</th>
<th class="head">Copy State</th>
<th class="head">T</th>
<th class="head">U</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>HomRef</td>
<td>Het</td>
<td>Het</td>
<td>Auto</td>
<td>0</td>
<td>2</td>
</tr>
<tr class="row-odd"><td>HomRef</td>
<td>HomRef</td>
<td>Het</td>
<td>Auto</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-even"><td>HomRef</td>
<td>Het</td>
<td>HomRef</td>
<td>Auto</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Het</td>
<td>Het</td>
<td>Het</td>
<td>Auto</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>Het</td>
<td>HomRef</td>
<td>Het</td>
<td>Auto</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Het</td>
<td>Het</td>
<td>HomRef</td>
<td>Auto</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Het</td>
<td>HomVar</td>
<td>Het</td>
<td>Auto</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Het</td>
<td>Het</td>
<td>HomVar</td>
<td>Auto</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-even"><td>HomVar</td>
<td>Het</td>
<td>Het</td>
<td>Auto</td>
<td>2</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>HomVar</td>
<td>Het</td>
<td>HomVar</td>
<td>Auto</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-even"><td>HomVar</td>
<td>HomVar</td>
<td>Het</td>
<td>Auto</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>HomRef</td>
<td>HomRef</td>
<td>Het</td>
<td>HemiX</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-even"><td>HomRef</td>
<td>HomVar</td>
<td>Het</td>
<td>HemiX</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>HomVar</td>
<td>HomRef</td>
<td>Het</td>
<td>HemiX</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-even"><td>HomVar</td>
<td>HomVar</td>
<td>Het</td>
<td>HemiX</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#hail.VariantDataset.tdt" title="hail.VariantDataset.tdt"><code class="xref py py-meth docutils literal"><span class="pre">tdt()</span></code></a> only considers complete trios (two parents and a proband) with defined sex.</p>
<p>PAR is currently defined with respect to reference <a class="reference external" href="http://www.ncbi.nlm.nih.gov/projects/genome/assembly/grc/human/">GRCh37</a>:</p>
<ul class="simple">
<li>X: 60001-2699520</li>
<li>X: 154931044-155260560</li>
<li>Y: 10001-2649520</li>
<li>Y: 59034050-59363566</li>
</ul>
<p><a class="reference internal" href="#hail.VariantDataset.tdt" title="hail.VariantDataset.tdt"><code class="xref py py-meth docutils literal"><span class="pre">tdt()</span></code></a> assumes all contigs apart from X and Y are fully autosomal; decoys, etc. are not given special treatment.</p>
<p><strong>Annotations</strong></p>
<p><a class="reference internal" href="#hail.VariantDataset.tdt" title="hail.VariantDataset.tdt"><code class="xref py py-meth docutils literal"><span class="pre">tdt()</span></code></a> adds the following annotations:</p>
<blockquote>
<div><ul class="simple">
<li><strong>tdt.nTransmitted</strong> (<em>Int</em>) &#8211; Number of transmitted alternate alleles.</li>
<li><strong>va.tdt.nUntransmitted</strong> (<em>Int</em>) &#8211; Number of untransmitted alternate alleles.</li>
<li><strong>va.tdt.chi2</strong> (<em>Double</em>) &#8211; TDT statistic.</li>
<li><strong>va.tdt.pval</strong> (<em>Double</em>) &#8211; p-value.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fam</strong> (<em>str</em>) &#8211; Path to FAM file.</li>
<li><strong>root</strong> &#8211; Variant annotation root to store TDT result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Variant dataset with TDT association results added to variant annotations.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.variant_qc">
<code class="descname">variant_qc</code><span class="sig-paren">(</span><em>root='va.qc'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.variant_qc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.variant_qc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute common variant statistics (quality control metrics).</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The <a class="reference internal" href="#hail.VariantDataset.genotype_schema" title="hail.VariantDataset.genotype_schema"><code class="xref py py-meth docutils literal"><span class="pre">genotype_schema()</span></code></a> must be of type <a class="reference internal" href="expr/hail.expr.TGenotype.html#hail.expr.TGenotype" title="hail.expr.TGenotype"><code class="xref py py-class docutils literal"><span class="pre">TGenotype</span></code></a> in order to use this method.</p>
</div>
<p><strong>Examples</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">variant_qc</span><span class="p">()</span>
</pre></div>
</div>
<p id="variantqc-annotations"><strong>Annotations</strong></p>
<p><a class="reference internal" href="#hail.VariantDataset.variant_qc" title="hail.VariantDataset.variant_qc"><code class="xref py py-meth docutils literal"><span class="pre">variant_qc()</span></code></a> computes 18 variant statistics from the 
genotype data and stores the results as variant annotations that can be accessed 
with <code class="docutils literal"><span class="pre">va.qc.&lt;identifier&gt;</span></code> (or <code class="docutils literal"><span class="pre">&lt;root&gt;.&lt;identifier&gt;</span></code> if a non-default root was passed):</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="9%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">callRate</span></code></td>
<td>Double</td>
<td>Fraction of samples with called genotypes</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">AF</span></code></td>
<td>Double</td>
<td>Calculated minor allele frequency (q)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">AC</span></code></td>
<td>Int</td>
<td>Count of alternate alleles</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">rHeterozygosity</span></code></td>
<td>Double</td>
<td>Proportion of heterozygotes</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">rHetHomVar</span></code></td>
<td>Double</td>
<td>Ratio of heterozygotes to homozygous alternates</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">rExpectedHetFrequency</span></code></td>
<td>Double</td>
<td>Expected rHeterozygosity based on HWE</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">pHWE</span></code></td>
<td>Double</td>
<td>p-value from Hardy Weinberg Equilibrium null model</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">nHomRef</span></code></td>
<td>Int</td>
<td>Number of homozygous reference samples</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">nHet</span></code></td>
<td>Int</td>
<td>Number of heterozygous samples</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">nHomVar</span></code></td>
<td>Int</td>
<td>Number of homozygous alternate samples</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">nCalled</span></code></td>
<td>Int</td>
<td>Sum of <code class="docutils literal"><span class="pre">nHomRef</span></code>, <code class="docutils literal"><span class="pre">nHet</span></code>, and <code class="docutils literal"><span class="pre">nHomVar</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">nNotCalled</span></code></td>
<td>Int</td>
<td>Number of uncalled samples</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">nNonRef</span></code></td>
<td>Int</td>
<td>Sum of <code class="docutils literal"><span class="pre">nHet</span></code> and <code class="docutils literal"><span class="pre">nHomVar</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">rHetHomVar</span></code></td>
<td>Double</td>
<td>Het/HomVar ratio across all samples</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">dpMean</span></code></td>
<td>Double</td>
<td>Depth mean across all samples</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">dpStDev</span></code></td>
<td>Double</td>
<td>Depth standard deviation across all samples</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">gqMean</span></code></td>
<td>Double</td>
<td>The average genotype quality across all samples</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">gqStDev</span></code></td>
<td>Double</td>
<td>Genotype quality standard deviation across all samples</td>
</tr>
</tbody>
</table>
<p>Missing values <code class="docutils literal"><span class="pre">NA</span></code> may result (for example, due to division by zero) and are handled properly 
in filtering and written as &#8220;NA&#8221; in export modules. The empirical standard deviation is computed
with zero degrees of freedom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>root</strong> (<em>str</em>) &#8211; Variant annotation root for computed struct.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Annotated variant dataset with new variant QC annotations.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="hail.VariantDataset.variant_schema">
<code class="descname">variant_schema</code><a class="headerlink" href="#hail.VariantDataset.variant_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the signature of the variant annotations contained in this VDS.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">vds</span><span class="o">.</span><span class="n">variant_schema</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="expr/hail.expr.Type.html#hail.expr.Type" title="hail.expr.Type"><code class="xref py py-class docutils literal"><span class="pre">Type</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.variants_keytable">
<code class="descname">variants_keytable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.variants_keytable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.variants_keytable" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert variants and variant annotations to a KeyTable.</p>
<p>The resulting KeyTable has schema:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Struct {
  v: Variant
  va: variant annotations
}
</pre></div>
</div>
<p>with a single key <code class="docutils literal"><span class="pre">v</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Key table with variants and variant annotations.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="hail.KeyTable.html#hail.KeyTable" title="hail.KeyTable"><code class="xref py py-class docutils literal"><span class="pre">KeyTable</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.vep">
<code class="descname">vep</code><span class="sig-paren">(</span><em>config</em>, <em>block_size=1000</em>, <em>root='va.vep'</em>, <em>csq=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.vep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.vep" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate variants with VEP.</p>
<p><a class="reference internal" href="#hail.VariantDataset.vep" title="hail.VariantDataset.vep"><code class="xref py py-meth docutils literal"><span class="pre">vep()</span></code></a> runs <a class="reference external" href="http://www.ensembl.org/info/docs/tools/vep/index.html">Variant Effect Predictor</a> with
the <a class="reference external" href="https://github.com/konradjk/loftee">LOFTEE plugin</a>
on the current variant dataset and adds the result as a variant annotation.</p>
<p>If the variant annotation path defined by <code class="docutils literal"><span class="pre">root</span></code> already exists and its schema matches the VEP schema, then
Hail only runs VEP for variants for which the annotation is missing.</p>
<p><strong>Examples</strong></p>
<p>Add VEP annotations to the dataset:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds_result</span> <span class="o">=</span> <span class="n">vds</span><span class="o">.</span><span class="n">vep</span><span class="p">(</span><span class="s2">&quot;data/vep.properties&quot;</span><span class="p">)</span> 
</pre></div>
</div>
<p><strong>Configuration</strong></p>
<p><a class="reference internal" href="#hail.VariantDataset.vep" title="hail.VariantDataset.vep"><code class="xref py py-meth docutils literal"><span class="pre">vep()</span></code></a> needs a configuration file to tell it how to run
VEP. The format is a <a class="reference external" href="https://en.wikipedia.org/wiki/.properties">.properties file</a>.
Roughly, each line defines a property as a key-value pair of the form <cite>key = value</cite>. <cite>vep</cite> supports the following properties:</p>
<ul class="simple">
<li><strong>hail.vep.perl</strong> &#8211; Location of Perl. Optional, default: perl.</li>
<li><strong>hail.vep.perl5lib</strong> &#8211; Value for the PERL5LIB environment variable when invoking VEP. Optional, by default PERL5LIB is not set.</li>
<li><strong>hail.vep.path</strong> &#8211; Value of the PATH environment variable when invoking VEP.  Optional, by default PATH is not set.</li>
<li><strong>hail.vep.location</strong> &#8211; Location of the VEP Perl script.  Required.</li>
<li><strong>hail.vep.cache_dir</strong> &#8211; Location of the VEP cache dir, passed to VEP with the <cite>&#8211;dir</cite> option.  Required.</li>
<li><strong>hail.vep.fasta</strong> &#8211; Location of the FASTA file to use to look up the reference sequence, passed to VEP with the <cite>&#8211;fasta</cite> option.  Required.</li>
<li><strong>hail.vep.lof.human_ancestor</strong> &#8211; Location of the human ancestor file for the LOFTEE plugin.  Required.</li>
<li><strong>hail.vep.lof.conservation_file</strong> &#8211; Location of the conservation file for the LOFTEE plugin.  Required.</li>
</ul>
<p>Here is an example <cite>vep.properties</cite> configuration file</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>hail.vep.perl = /usr/bin/perl
hail.vep.path = /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
hail.vep.location = /path/to/vep/ensembl-tools-release-81/scripts/variant_effect_predictor/variant_effect_predictor.pl
hail.vep.cache_dir = /path/to/vep
hail.vep.lof.human_ancestor = /path/to/loftee_data/human_ancestor.fa.gz
hail.vep.lof.conservation_file = /path/to/loftee_data//phylocsf.sql
</pre></div>
</div>
<p><strong>VEP Invocation</strong></p>
<div class="highlight-text"><div class="highlight"><pre><span></span>&lt;hail.vep.perl&gt;
&lt;hail.vep.location&gt;
--format vcf
--json
--everything
--allele_number
--no_stats
--cache --offline
--dir &lt;hail.vep.cache_dir&gt;
--fasta &lt;hail.vep.cache_dir&gt;/homo_sapiens/81_GRCh37/Homo_sapiens.GRCh37.75.dna.primary_assembly.fa
--minimal
--assembly GRCh37
--plugin LoF,human_ancestor_fa:$&lt;hail.vep.lof.human_ancestor&gt;,filter_position:0.05,min_intron_size:15,conservation_file:&lt;hail.vep.lof.conservation_file&gt;
-o STDOUT
</pre></div>
</div>
<p><strong>Annotations</strong></p>
<p>Annotations with the following schema are placed in the location specified by <code class="docutils literal"><span class="pre">root</span></code>.
The schema can be confirmed with <a class="reference internal" href="#hail.VariantDataset.variant_schema" title="hail.VariantDataset.variant_schema"><code class="xref py py-attr docutils literal"><span class="pre">variant_schema</span></code></a>, <a class="reference internal" href="#hail.VariantDataset.sample_schema" title="hail.VariantDataset.sample_schema"><code class="xref py py-attr docutils literal"><span class="pre">sample_schema</span></code></a>, and <a class="reference internal" href="#hail.VariantDataset.global_schema" title="hail.VariantDataset.global_schema"><code class="xref py py-attr docutils literal"><span class="pre">global_schema</span></code></a>.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Struct{
  assembly_name: String,
  allele_string: String,
  colocated_variants: Array[Struct{
    aa_allele: String,
    aa_maf: Double,
    afr_allele: String,
    afr_maf: Double,
    allele_string: String,
    amr_allele: String,
    amr_maf: Double,
    clin_sig: Array[String],
    end: Int,
    eas_allele: String,
    eas_maf: Double,
    ea_allele: String,,
    ea_maf: Double,
    eur_allele: String,
    eur_maf: Double,
    exac_adj_allele: String,
    exac_adj_maf: Double,
    exac_allele: String,
    exac_afr_allele: String,
    exac_afr_maf: Double,
    exac_amr_allele: String,
    exac_amr_maf: Double,
    exac_eas_allele: String,
    exac_eas_maf: Double,
    exac_fin_allele: String,
    exac_fin_maf: Double,
    exac_maf: Double,
    exac_nfe_allele: String,
    exac_nfe_maf: Double,
    exac_oth_allele: String,
    exac_oth_maf: Double,
    exac_sas_allele: String,
    exac_sas_maf: Double,
    id: String,
    minor_allele: String,
    minor_allele_freq: Double,
    phenotype_or_disease: Int,
    pubmed: Array[Int],
    sas_allele: String,
    sas_maf: Double,
    somatic: Int,
    start: Int,
    strand: Int
  }],
  end: Int,
  id: String,
  input: String,
  intergenic_consequences: Array[Struct{
    allele_num: Int,
    consequence_terms: Array[String],
    impact: String,
    minimised: Int,
    variant_allele: String
  }],
  most_severe_consequence: String,
  motif_feature_consequences: Array[Struct{
    allele_num: Int,
    consequence_terms: Array[String],
    high_inf_pos: String,
    impact: String,
    minimised: Int,
    motif_feature_id: String,
    motif_name: String,
    motif_pos: Int,
    motif_score_change: Double,
    strand: Int,
    variant_allele: String
  }],
  regulatory_feature_consequences: Array[Struct{
    allele_num: Int,
    biotype: String,
    consequence_terms: Array[String],
    impact: String,
    minimised: Int,
    regulatory_feature_id: String,
    variant_allele: String
  }],
  seq_region_name: String,
  start: Int,
  strand: Int,
  transcript_consequences: Array[Struct{
    allele_num: Int,
    amino_acids: String,
    biotype: String,
    canonical: Int,
    ccds: String,
    cdna_start: Int,
    cdna_end: Int,
    cds_end: Int,
    cds_start: Int,
    codons: String,
    consequence_terms: Array[String],
    distance: Int,
    domains: Array[Struct{
      db: String
      name: String
    }],
    exon: String,
    gene_id: String,
    gene_pheno: Int,
    gene_symbol: String,
    gene_symbol_source: String,
    hgnc_id: Int,
    hgvsc: String,
    hgvsp: String,
    hgvs_offset: Int,
    impact: String,
    intron: String,
    lof: String,
    lof_flags: String,
    lof_filter: String,
    lof_info: String,
    minimised: Int,
    polyphen_prediction: String,
    polyphen_score: Double,
    protein_end: Int,
    protein_start: Int,
    protein_id: String,
    sift_prediction: String,
    sift_score: Double,
    strand: Int,
    swissprot: String,
    transcript_id: String,
    trembl: String,
    uniparc: String,
    variant_allele: String
  }],
  variant_class: String
}
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>config</strong> (<em>str</em>) &#8211; Path to VEP configuration file.</li>
<li><strong>block_size</strong> (<em>int</em>) &#8211; Number of variants to annotate per VEP invocation.</li>
<li><strong>root</strong> (<em>str</em>) &#8211; Variant annotation path to store VEP output.</li>
<li><strong>force</strong> (<em>bool</em>) &#8211; If True, force VEP annotation from scratch.</li>
<li><strong>csq</strong> (<em>bool</em>) &#8211; If True, annotates VCF CSQ field as a String.
If False, annotates with the full nested struct schema</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An annotated with variant annotations from VEP.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hail.VariantDataset" title="hail.VariantDataset"><code class="xref py py-class docutils literal"><span class="pre">VariantDataset</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.was_split">
<code class="descname">was_split</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.was_split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.was_split" title="Permalink to this definition">¶</a></dt>
<dd><p>True if multiallelic variants have been split into multiple biallelic variants.</p>
<p>Result is True if <a class="reference internal" href="#hail.VariantDataset.split_multi" title="hail.VariantDataset.split_multi"><code class="xref py py-meth docutils literal"><span class="pre">split_multi()</span></code></a> or <a class="reference internal" href="#hail.VariantDataset.filter_multi" title="hail.VariantDataset.filter_multi"><code class="xref py py-meth docutils literal"><span class="pre">filter_multi()</span></code></a> has been called on this variant dataset,
or if the variant dataset was imported with <a class="reference internal" href="hail.HailContext.html#hail.HailContext.import_plink" title="hail.HailContext.import_plink"><code class="xref py py-meth docutils literal"><span class="pre">import_plink()</span></code></a>, <a class="reference internal" href="hail.HailContext.html#hail.HailContext.import_gen" title="hail.HailContext.import_gen"><code class="xref py py-meth docutils literal"><span class="pre">import_gen()</span></code></a>,
or <a class="reference internal" href="hail.HailContext.html#hail.HailContext.import_bgen" title="hail.HailContext.import_bgen"><code class="xref py py-meth docutils literal"><span class="pre">import_bgen()</span></code></a>, or if the variant dataset was simulated with <a class="reference internal" href="hail.HailContext.html#hail.HailContext.balding_nichols_model" title="hail.HailContext.balding_nichols_model"><code class="xref py py-meth docutils literal"><span class="pre">balding_nichols_model()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hail.VariantDataset.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>output</em>, <em>overwrite=False</em>, <em>parquet_genotypes=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hail/dataset.html#VariantDataset.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hail.VariantDataset.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write variant dataset as VDS file.</p>
<p><strong>Examples</strong></p>
<p>Import data from a VCF file and then write the data to a VDS file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vds</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;output/sample.vds&quot;</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>output</strong> (<em>str</em>) &#8211; Path of VDS file to write.</li>
<li><strong>overwrite</strong> (<em>bool</em>) &#8211; If True, overwrite any existing VDS file. Cannot be used to read from and write to the same path.</li>
<li><strong>parquet_genotypes</strong> (<em>bool</em>) &#8211; If True, store genotypes as Parquet rather than Hail&#8217;s serialization.  The resulting VDS will be larger and slower in Hail but the genotypes will be accessible from other tools that support Parquet.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="hail.KeyTable.html" class="btn btn-neutral float-right" title="KeyTable" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="hail.HailContext.html" class="btn btn-neutral" title="HailContext" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Hail Team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'devel',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script type="text/javascript" src="../bootstrap.min.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
  
   

</body>
</html>